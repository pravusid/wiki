<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>컴파일러 | TIL wiki</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/wiki/assets/css/0.styles.c1d7e000.css" as="style"><link rel="preload" href="/wiki/assets/js/app.b3a0b150.js" as="script"><link rel="preload" href="/wiki/assets/js/2.989cddfe.js" as="script"><link rel="preload" href="/wiki/assets/js/127.ad1f9c7a.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.b6f777e6.js"><link rel="prefetch" href="/wiki/assets/js/100.d1a71f01.js"><link rel="prefetch" href="/wiki/assets/js/101.b70624ce.js"><link rel="prefetch" href="/wiki/assets/js/102.8e4a4a21.js"><link rel="prefetch" href="/wiki/assets/js/103.7568874d.js"><link rel="prefetch" href="/wiki/assets/js/104.20fb7cbd.js"><link rel="prefetch" href="/wiki/assets/js/105.9823a289.js"><link rel="prefetch" href="/wiki/assets/js/106.26e0f4ba.js"><link rel="prefetch" href="/wiki/assets/js/107.550c815e.js"><link rel="prefetch" href="/wiki/assets/js/108.4b416294.js"><link rel="prefetch" href="/wiki/assets/js/109.bfb0858e.js"><link rel="prefetch" href="/wiki/assets/js/11.c128894e.js"><link rel="prefetch" href="/wiki/assets/js/110.b70fb22b.js"><link rel="prefetch" href="/wiki/assets/js/111.6bd096b5.js"><link rel="prefetch" href="/wiki/assets/js/112.4c627538.js"><link rel="prefetch" href="/wiki/assets/js/113.c81c7432.js"><link rel="prefetch" href="/wiki/assets/js/114.9558a3b5.js"><link rel="prefetch" href="/wiki/assets/js/115.7135c596.js"><link rel="prefetch" href="/wiki/assets/js/116.fe7daba1.js"><link rel="prefetch" href="/wiki/assets/js/117.cff15a7c.js"><link rel="prefetch" href="/wiki/assets/js/118.10d4529e.js"><link rel="prefetch" href="/wiki/assets/js/119.e4b6449f.js"><link rel="prefetch" href="/wiki/assets/js/12.4fbd3952.js"><link rel="prefetch" href="/wiki/assets/js/120.526d5262.js"><link rel="prefetch" href="/wiki/assets/js/121.8fd73971.js"><link rel="prefetch" href="/wiki/assets/js/122.dc562250.js"><link rel="prefetch" href="/wiki/assets/js/123.815c056e.js"><link rel="prefetch" href="/wiki/assets/js/124.969d3538.js"><link rel="prefetch" href="/wiki/assets/js/125.8d8294bd.js"><link rel="prefetch" href="/wiki/assets/js/126.e78b947b.js"><link rel="prefetch" href="/wiki/assets/js/128.b04a8bf0.js"><link rel="prefetch" href="/wiki/assets/js/129.7c7cf152.js"><link rel="prefetch" href="/wiki/assets/js/13.0db2bca5.js"><link rel="prefetch" href="/wiki/assets/js/130.557f02d3.js"><link rel="prefetch" href="/wiki/assets/js/131.51b5dea3.js"><link rel="prefetch" href="/wiki/assets/js/132.754c86b1.js"><link rel="prefetch" href="/wiki/assets/js/133.7123c73a.js"><link rel="prefetch" href="/wiki/assets/js/134.390fbad6.js"><link rel="prefetch" href="/wiki/assets/js/135.4a1e66fe.js"><link rel="prefetch" href="/wiki/assets/js/136.ef85ea0f.js"><link rel="prefetch" href="/wiki/assets/js/137.806a4063.js"><link rel="prefetch" href="/wiki/assets/js/138.9b7c97d9.js"><link rel="prefetch" href="/wiki/assets/js/139.11166fd6.js"><link rel="prefetch" href="/wiki/assets/js/14.ba416922.js"><link rel="prefetch" href="/wiki/assets/js/140.e6a48fb1.js"><link rel="prefetch" href="/wiki/assets/js/141.16198cc7.js"><link rel="prefetch" href="/wiki/assets/js/142.f28f97f7.js"><link rel="prefetch" href="/wiki/assets/js/143.47fd403f.js"><link rel="prefetch" href="/wiki/assets/js/144.cdc9d361.js"><link rel="prefetch" href="/wiki/assets/js/145.2ccebd7a.js"><link rel="prefetch" href="/wiki/assets/js/146.0696bdd0.js"><link rel="prefetch" href="/wiki/assets/js/147.958a8782.js"><link rel="prefetch" href="/wiki/assets/js/148.c626005f.js"><link rel="prefetch" href="/wiki/assets/js/149.c59f0f01.js"><link rel="prefetch" href="/wiki/assets/js/15.4fc6a7f5.js"><link rel="prefetch" href="/wiki/assets/js/150.bb9473f6.js"><link rel="prefetch" href="/wiki/assets/js/151.494af6df.js"><link rel="prefetch" href="/wiki/assets/js/152.5e8b512e.js"><link rel="prefetch" href="/wiki/assets/js/153.627b3c25.js"><link rel="prefetch" href="/wiki/assets/js/154.266375a6.js"><link rel="prefetch" href="/wiki/assets/js/155.bdb81c8a.js"><link rel="prefetch" href="/wiki/assets/js/156.51d1b651.js"><link rel="prefetch" href="/wiki/assets/js/157.e2173958.js"><link rel="prefetch" href="/wiki/assets/js/158.83779547.js"><link rel="prefetch" href="/wiki/assets/js/159.415593ed.js"><link rel="prefetch" href="/wiki/assets/js/16.61c8659c.js"><link rel="prefetch" href="/wiki/assets/js/160.63d11973.js"><link rel="prefetch" href="/wiki/assets/js/161.283b6fbd.js"><link rel="prefetch" href="/wiki/assets/js/162.a1e7e5eb.js"><link rel="prefetch" href="/wiki/assets/js/163.8c2236be.js"><link rel="prefetch" href="/wiki/assets/js/164.452ab3b1.js"><link rel="prefetch" href="/wiki/assets/js/165.44f17a83.js"><link rel="prefetch" href="/wiki/assets/js/166.e0443aa5.js"><link rel="prefetch" href="/wiki/assets/js/167.3eaf0489.js"><link rel="prefetch" href="/wiki/assets/js/168.96eee2c3.js"><link rel="prefetch" href="/wiki/assets/js/169.ca3fb081.js"><link rel="prefetch" href="/wiki/assets/js/17.7c715bee.js"><link rel="prefetch" href="/wiki/assets/js/170.139cd74e.js"><link rel="prefetch" href="/wiki/assets/js/171.0fcabaae.js"><link rel="prefetch" href="/wiki/assets/js/172.7936a172.js"><link rel="prefetch" href="/wiki/assets/js/173.a9780d99.js"><link rel="prefetch" href="/wiki/assets/js/174.377e1bd2.js"><link rel="prefetch" href="/wiki/assets/js/175.1505d2fa.js"><link rel="prefetch" href="/wiki/assets/js/176.1357001a.js"><link rel="prefetch" href="/wiki/assets/js/177.728aa338.js"><link rel="prefetch" href="/wiki/assets/js/178.58c72fb8.js"><link rel="prefetch" href="/wiki/assets/js/179.97e08ac7.js"><link rel="prefetch" href="/wiki/assets/js/18.69e54107.js"><link rel="prefetch" href="/wiki/assets/js/180.256ee36f.js"><link rel="prefetch" href="/wiki/assets/js/181.54182083.js"><link rel="prefetch" href="/wiki/assets/js/182.7acbf873.js"><link rel="prefetch" href="/wiki/assets/js/183.686bbdd9.js"><link rel="prefetch" href="/wiki/assets/js/184.5d00e900.js"><link rel="prefetch" href="/wiki/assets/js/185.ec338252.js"><link rel="prefetch" href="/wiki/assets/js/186.43a02f95.js"><link rel="prefetch" href="/wiki/assets/js/187.b090eed6.js"><link rel="prefetch" href="/wiki/assets/js/188.4f0cece3.js"><link rel="prefetch" href="/wiki/assets/js/189.6e55efbb.js"><link rel="prefetch" href="/wiki/assets/js/19.6d19bc3a.js"><link rel="prefetch" href="/wiki/assets/js/190.a723a982.js"><link rel="prefetch" href="/wiki/assets/js/191.39240974.js"><link rel="prefetch" href="/wiki/assets/js/192.9db2dccc.js"><link rel="prefetch" href="/wiki/assets/js/193.b8624c07.js"><link rel="prefetch" href="/wiki/assets/js/194.5f973d23.js"><link rel="prefetch" href="/wiki/assets/js/195.45081787.js"><link rel="prefetch" href="/wiki/assets/js/196.00b2d6d8.js"><link rel="prefetch" href="/wiki/assets/js/197.35279a2b.js"><link rel="prefetch" href="/wiki/assets/js/198.9ac43a49.js"><link rel="prefetch" href="/wiki/assets/js/199.a0384fe0.js"><link rel="prefetch" href="/wiki/assets/js/20.e174cf76.js"><link rel="prefetch" href="/wiki/assets/js/200.e422f194.js"><link rel="prefetch" href="/wiki/assets/js/201.5c721fc9.js"><link rel="prefetch" href="/wiki/assets/js/202.31ba51dc.js"><link rel="prefetch" href="/wiki/assets/js/203.c0dfda57.js"><link rel="prefetch" href="/wiki/assets/js/204.87a27101.js"><link rel="prefetch" href="/wiki/assets/js/205.0dec22ef.js"><link rel="prefetch" href="/wiki/assets/js/206.e107353d.js"><link rel="prefetch" href="/wiki/assets/js/207.8895c4cc.js"><link rel="prefetch" href="/wiki/assets/js/208.56c9ebef.js"><link rel="prefetch" href="/wiki/assets/js/209.3646643b.js"><link rel="prefetch" href="/wiki/assets/js/21.5668f30f.js"><link rel="prefetch" href="/wiki/assets/js/210.215168b1.js"><link rel="prefetch" href="/wiki/assets/js/211.9fe3832a.js"><link rel="prefetch" href="/wiki/assets/js/212.0cf61a8a.js"><link rel="prefetch" href="/wiki/assets/js/213.f599427c.js"><link rel="prefetch" href="/wiki/assets/js/214.44868071.js"><link rel="prefetch" href="/wiki/assets/js/215.b0a97a29.js"><link rel="prefetch" href="/wiki/assets/js/216.554843d9.js"><link rel="prefetch" href="/wiki/assets/js/217.1174c17b.js"><link rel="prefetch" href="/wiki/assets/js/218.6e3ca1f7.js"><link rel="prefetch" href="/wiki/assets/js/219.97c1f925.js"><link rel="prefetch" href="/wiki/assets/js/22.4b4a4608.js"><link rel="prefetch" href="/wiki/assets/js/220.777cd521.js"><link rel="prefetch" href="/wiki/assets/js/221.8e3c31a2.js"><link rel="prefetch" href="/wiki/assets/js/222.1586beec.js"><link rel="prefetch" href="/wiki/assets/js/223.8fcbe59b.js"><link rel="prefetch" href="/wiki/assets/js/224.d224c1f9.js"><link rel="prefetch" href="/wiki/assets/js/225.d585aa38.js"><link rel="prefetch" href="/wiki/assets/js/226.78edf758.js"><link rel="prefetch" href="/wiki/assets/js/23.deb4127e.js"><link rel="prefetch" href="/wiki/assets/js/24.ddb394d6.js"><link rel="prefetch" href="/wiki/assets/js/25.d8d4abdd.js"><link rel="prefetch" href="/wiki/assets/js/26.19ff6588.js"><link rel="prefetch" href="/wiki/assets/js/27.775bb62a.js"><link rel="prefetch" href="/wiki/assets/js/28.8c0a0957.js"><link rel="prefetch" href="/wiki/assets/js/29.8d6f2897.js"><link rel="prefetch" href="/wiki/assets/js/3.8fdf3bdd.js"><link rel="prefetch" href="/wiki/assets/js/30.dca07c6d.js"><link rel="prefetch" href="/wiki/assets/js/31.00933b1b.js"><link rel="prefetch" href="/wiki/assets/js/32.3a961c38.js"><link rel="prefetch" href="/wiki/assets/js/33.7470e661.js"><link rel="prefetch" href="/wiki/assets/js/34.20de8dda.js"><link rel="prefetch" href="/wiki/assets/js/35.ab978e7a.js"><link rel="prefetch" href="/wiki/assets/js/36.c4db3237.js"><link rel="prefetch" href="/wiki/assets/js/37.4e47124e.js"><link rel="prefetch" href="/wiki/assets/js/38.05aa4c7c.js"><link rel="prefetch" href="/wiki/assets/js/39.854aea5e.js"><link rel="prefetch" href="/wiki/assets/js/4.b0b21059.js"><link rel="prefetch" href="/wiki/assets/js/40.4a43efae.js"><link rel="prefetch" href="/wiki/assets/js/41.cf72f9af.js"><link rel="prefetch" href="/wiki/assets/js/42.5b5fe656.js"><link rel="prefetch" href="/wiki/assets/js/43.4cd52917.js"><link rel="prefetch" href="/wiki/assets/js/44.86745131.js"><link rel="prefetch" href="/wiki/assets/js/45.8c1ba370.js"><link rel="prefetch" href="/wiki/assets/js/46.7256a87a.js"><link rel="prefetch" href="/wiki/assets/js/47.f7103af3.js"><link rel="prefetch" href="/wiki/assets/js/48.6ed36d09.js"><link rel="prefetch" href="/wiki/assets/js/49.ee12c2b7.js"><link rel="prefetch" href="/wiki/assets/js/5.d5022a2b.js"><link rel="prefetch" href="/wiki/assets/js/50.2648ed18.js"><link rel="prefetch" href="/wiki/assets/js/51.8ba7dcf9.js"><link rel="prefetch" href="/wiki/assets/js/52.79195a29.js"><link rel="prefetch" href="/wiki/assets/js/53.8e9581b5.js"><link rel="prefetch" href="/wiki/assets/js/54.5c9223ac.js"><link rel="prefetch" href="/wiki/assets/js/55.d5e3d237.js"><link rel="prefetch" href="/wiki/assets/js/56.dc5d3724.js"><link rel="prefetch" href="/wiki/assets/js/57.0b910111.js"><link rel="prefetch" href="/wiki/assets/js/58.9944b1a8.js"><link rel="prefetch" href="/wiki/assets/js/59.44a86c70.js"><link rel="prefetch" href="/wiki/assets/js/6.cc53b8cd.js"><link rel="prefetch" href="/wiki/assets/js/60.079647f2.js"><link rel="prefetch" href="/wiki/assets/js/61.41ce7ec4.js"><link rel="prefetch" href="/wiki/assets/js/62.10fe0751.js"><link rel="prefetch" href="/wiki/assets/js/63.747dbd50.js"><link rel="prefetch" href="/wiki/assets/js/64.46ecd7ed.js"><link rel="prefetch" href="/wiki/assets/js/65.ea599a8d.js"><link rel="prefetch" href="/wiki/assets/js/66.ad02af4d.js"><link rel="prefetch" href="/wiki/assets/js/67.dd83d097.js"><link rel="prefetch" href="/wiki/assets/js/68.f3f1e8a0.js"><link rel="prefetch" href="/wiki/assets/js/69.dd8bb404.js"><link rel="prefetch" href="/wiki/assets/js/7.694cb848.js"><link rel="prefetch" href="/wiki/assets/js/70.7c2dcf8b.js"><link rel="prefetch" href="/wiki/assets/js/71.f610ecd4.js"><link rel="prefetch" href="/wiki/assets/js/72.68c21cf2.js"><link rel="prefetch" href="/wiki/assets/js/73.9fc88a1f.js"><link rel="prefetch" href="/wiki/assets/js/74.a8b3c9bd.js"><link rel="prefetch" href="/wiki/assets/js/75.8c23147b.js"><link rel="prefetch" href="/wiki/assets/js/76.c7c4fa07.js"><link rel="prefetch" href="/wiki/assets/js/77.ca3a775e.js"><link rel="prefetch" href="/wiki/assets/js/78.8e73af3e.js"><link rel="prefetch" href="/wiki/assets/js/79.bb8597d5.js"><link rel="prefetch" href="/wiki/assets/js/8.c5470a72.js"><link rel="prefetch" href="/wiki/assets/js/80.d4e0c957.js"><link rel="prefetch" href="/wiki/assets/js/81.eb6b6cc3.js"><link rel="prefetch" href="/wiki/assets/js/82.8d956e75.js"><link rel="prefetch" href="/wiki/assets/js/83.23642eba.js"><link rel="prefetch" href="/wiki/assets/js/84.f54e2033.js"><link rel="prefetch" href="/wiki/assets/js/85.9e57812b.js"><link rel="prefetch" href="/wiki/assets/js/86.e96ddd20.js"><link rel="prefetch" href="/wiki/assets/js/87.e545816f.js"><link rel="prefetch" href="/wiki/assets/js/88.de116fc8.js"><link rel="prefetch" href="/wiki/assets/js/89.e786674e.js"><link rel="prefetch" href="/wiki/assets/js/9.f9c5356b.js"><link rel="prefetch" href="/wiki/assets/js/90.b46c3b6b.js"><link rel="prefetch" href="/wiki/assets/js/91.ec01b0c3.js"><link rel="prefetch" href="/wiki/assets/js/92.bf01cd66.js"><link rel="prefetch" href="/wiki/assets/js/93.e51c261a.js"><link rel="prefetch" href="/wiki/assets/js/94.03c1d46e.js"><link rel="prefetch" href="/wiki/assets/js/95.2cd40eca.js"><link rel="prefetch" href="/wiki/assets/js/96.90e5e622.js"><link rel="prefetch" href="/wiki/assets/js/97.40e4e2ce.js"><link rel="prefetch" href="/wiki/assets/js/98.98759980.js"><link rel="prefetch" href="/wiki/assets/js/99.17e75fa3.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.c1d7e000.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><!----> <span class="site-name">TIL wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/pravusid/TIL" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/pravusid/TIL" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>컴파일러</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/Lecture/compiler.html#컴파일러-개요" class="sidebar-link">컴파일러 개요</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#인터프리터" class="sidebar-link">인터프리터</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#컴파일러의-논리적-구조" class="sidebar-link">컴파일러의 논리적 구조</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#컴파일러의-물리적-구조" class="sidebar-link">컴파일러의 물리적 구조</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#간단한-컴파일러" class="sidebar-link">간단한 컴파일러</a></li></ul></li><li><a href="/wiki/Lecture/compiler.html#형식언어와-오토마타" class="sidebar-link">형식언어와 오토마타</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#형식언어의-기초" class="sidebar-link">형식언어의 기초</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#형식문법" class="sidebar-link">형식문법</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#정규표현" class="sidebar-link">정규표현</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#정규언어와-유한-오토마타-finite-automata" class="sidebar-link">정규언어와 유한 오토마타 (Finite Automata)</a></li></ul></li><li><a href="/wiki/Lecture/compiler.html#어휘분석" class="sidebar-link">어휘분석</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#어휘분석-lexical-analysis-이란" class="sidebar-link">어휘분석(lexical analysis)이란</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#어휘-분석기의-설계" class="sidebar-link">어휘 분석기의 설계</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#어휘분석기-구현-고려사항" class="sidebar-link">어휘분석기 구현 고려사항</a></li></ul></li><li><a href="/wiki/Lecture/compiler.html#context-free-언어와-문법의-효율화" class="sidebar-link">Context-Free 언어와 문법의 효율화</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#context-free-언어와-푸시다운-오토마타" class="sidebar-link">Context-Free 언어와 푸시다운 오토마타</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#유도트리" class="sidebar-link">유도트리</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#모호성" class="sidebar-link">모호성</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#불필요한-생성규칙의-제거" class="sidebar-link">불필요한 생성규칙의 제거</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#ε-생성규칙의-제거" class="sidebar-link">ε-생성규칙의 제거</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#단일-생성규칙의-제거" class="sidebar-link">단일 생성규칙의 제거</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#left-factoring" class="sidebar-link">left-factoring</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#left-recursion의-제거" class="sidebar-link">left-recursion의 제거</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#푸시다운-오토마타" class="sidebar-link">푸시다운 오토마타</a></li></ul></li><li><a href="/wiki/Lecture/compiler.html#구문분석" class="sidebar-link">구문분석</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#bottom-up-구문분석" class="sidebar-link">Bottom-up 구문분석</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#여러가지-순위문법과-용어" class="sidebar-link">여러가지 순위문법과 용어</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#단순순위-구문분석" class="sidebar-link">단순순위 구문분석</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#lr-구문분석" class="sidebar-link">LR 구문분석</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#top-down-구문분석" class="sidebar-link">Top-Down 구문분석</a></li></ul></li><li><a href="/wiki/Lecture/compiler.html#의미분석과-기호표" class="sidebar-link">의미분석과 기호표</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#의미분석-개요" class="sidebar-link">의미분석 개요</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#기호표-구성" class="sidebar-link">기호표 구성</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#상수정의와-의미분석" class="sidebar-link">상수정의와 의미분석</a></li></ul></li><li><a href="/wiki/Lecture/compiler.html#중간언어와-중간코드-생성" class="sidebar-link">중간언어와 중간코드 생성</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#중간언어의-장점" class="sidebar-link">중간언어의 장점</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#중간언어의-종류" class="sidebar-link">중간언어의 종류</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#구문지시적-변환-syntax-directed-translation" class="sidebar-link">구문지시적 변환(syntax-directed translation)</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#중간코드-생성" class="sidebar-link">중간코드 생성</a></li></ul></li><li><a href="/wiki/Lecture/compiler.html#코드최적화" class="sidebar-link">코드최적화</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#코드최적화의-개념" class="sidebar-link">코드최적화의 개념</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#실행시간을-짧게-하기-위한-최적화" class="sidebar-link">실행시간을 짧게 하기 위한 최적화</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#소요-기억용량-최적화" class="sidebar-link">소요 기억용량 최적화</a></li><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#최적화의-구현" class="sidebar-link">최적화의 구현</a></li></ul></li><li><a href="/wiki/Lecture/compiler.html#목적코드-생성" class="sidebar-link">목적코드 생성</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Lecture/compiler.html#목적코드-생성의-개요" class="sidebar-link">목적코드 생성의 개요</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="컴파일러"><a href="#컴파일러" class="header-anchor">#</a> 컴파일러</h1> <h2 id="컴파일러-개요"><a href="#컴파일러-개요" class="header-anchor">#</a> 컴파일러 개요</h2> <ul><li>원시 프로그램 -&gt; 번역기 -&gt; 목적 프로그램</li> <li>어셈블리어 프로그램 -&gt; 어셈블러 -&gt; 기계어 프로그램</li> <li>고급언어 프로그램 -&gt; 컴파일러 -&gt; 어셈블리어/기계어 프로그램</li> <li>고급언어 프로그램 -&gt; 프리프로세서 -&gt; 고급언어 프로그램</li> <li>고급언어 프로그램 -&gt; 인터프리터 -&gt; 실행결과</li></ul> <p>컴파일러는 목적코드에 따라 다음으로 분류할 수 있다</p> <ul><li><p>native compiler</p> <ul><li>일반적으로 사용되는 컴파일러</li> <li>컴파일러가 목적코드를 생산하고 나면 목적코드는 바로 컴퓨터에서 실행된다</li></ul></li> <li><p>cross compiler</p> <ul><li>임베디드 프로그램처럼 목적코드가 다른 컴퓨터나 운영체제에서 실행되도록 번역</li></ul></li> <li><p>bytecode compiler</p> <ul><li>Java 언어가 대표적이다</li> <li>원시프로그램을 자바 바이트 코드 형태로 번역한다</li> <li>바이트코드는 자바 가상 머신에서 실행될 수 있는 코드이다</li></ul></li></ul> <h3 id="인터프리터"><a href="#인터프리터" class="header-anchor">#</a> 인터프리터</h3> <p>인터프리터의 처리과정을 보면, 고급언어로 작성된 원시 프로그램을 중간코드로 변환하고,
변환된 중간코드를 명령어 단위로 가져다가 디코드하고 실행을 한다.</p> <p>그리고 명령어의 주소를 하나 늘린 후, 다음 명령어를 가져온다.</p> <ul><li>시작</li> <li>다음 명령어 호출(fetch)</li> <li>명령어 디코드(decode)</li> <li>지정된 피연산자 호출
<ul><li>원시연산 실행
<ul><li>명령어 주소 하나 증가 <code>(다음)</code></li></ul></li> <li>실행중지 연산 <code>(종료)</code></li> <li>지정된 연산으로 분기
<ul><li>원시연산 실행</li> <li>명령어 주소 하나 증가 <code>(다음)</code></li></ul></li></ul></li></ul> <h3 id="컴파일러의-논리적-구조"><a href="#컴파일러의-논리적-구조" class="header-anchor">#</a> 컴파일러의 논리적 구조</h3> <ul><li>원시 프로그램</li> <li>어휘분석</li> <li>구문분석</li> <li>의미분석</li> <li>중간코드 생성</li> <li>코드최적화</li> <li>목적코드생성</li> <li>목적프로그램</li></ul> <h4 id="어휘분석-lexical-analysis"><a href="#어휘분석-lexical-analysis" class="header-anchor">#</a> 어휘분석 (lexical analysis)</h4> <p>어휘분석 단계에서는 원시 프로그램을 읽어 문장을 구성하고 있는 최소 단위인 어휘들을 떼어,
이 어휘들이 올바른지 분석하는 일을 한다.</p> <p>따라서 모든 어휘를 정의한 문법(grammar)이 필요하다.
어휘분석 단계에서 문법에 의해 어휘가 분석되는데 올바르지 않으면 오류메시지가 출력되고,
올바른 경우 token 형태로 출력된다.</p> <p>어휘 토큰은 의미 있는 최소의 문법적 단위(syntactic entity)가 되고,
이와 같은 일을 하는 것을 어휘분석기(lexical analyzer) 혹은 스캐너(scanner)라 한다.</p> <p>토큰은 예약어(reserved word)나 상수(constant), 연산자(operator), 식별자(identifier),
괄호/따옴표/세미콜론등의 구분자(delimiter)등이 있다.</p> <h4 id="구문분석-syntax-analysis"><a href="#구문분석-syntax-analysis" class="header-anchor">#</a> 구문분석 (syntax analysis)</h4> <p>구문분석 혹은 파싱(parsing)이라고 하며,
구문분석기(syntax analyzer) 혹은 파서(parser)가
어휘분석 결과인 토큰을 입력받아 이어지는 토큰들이 올바른 문장구조를 갖고 있는지 검사한다.</p> <p>구문분석 단계에서도 문장구조를 정의할 문법이 필요하다.</p> <p>문장을 정의한 문법에 맞는지 분석하는데,
올바른 문장에 대해서는 문장에 대한 구문구조(syntatic structure)를 만들어 출력하고
올바르지 않은 문장에 대해서는 오류메시지를 출력한다.</p> <p>구문구조는 토큰들을 단말노드(terminal node)로 하는 tree 형태로 표현되는데,
이 트리를 parse tree라 한다.</p> <p>parse tree는 중간코드 생성단계에서 이용된다.
parse tree에서 불필요한 정보인 식별자, 숫자, 식 등을 제거하고
다음 단계에서 필요한 정보만으로 구성된 트리를 구문트리(syntax tree)라고 한다.</p> <h4 id="의미분석-semantic-analysis"><a href="#의미분석-semantic-analysis" class="header-anchor">#</a> 의미분석 (semantic analysis)</h4> <p>구문트리에 어떤 의미가 있고 어떤 기능을 수행하는지 분석하고,
수행환경을 조성하는 것을 의미분석기 (semantic analyzer)라 한다.</p> <p>구문트리를 보며 산술식과 각 문장의 연산자 및 피연산자를 인식하고 type checking 등을 한다.</p> <h4 id="중간코드-생성-intermediate-code-generation"><a href="#중간코드-생성-intermediate-code-generation" class="header-anchor">#</a> 중간코드 생성 (intermediate code generation)</h4> <p>중간코드 생성은 구문분석 단계에서 만들어진 구문트리를 이용하여 코드를 생성하거나,
구문지시적변환(syntax-directed translation)으로 이루어진다.</p> <p>구문지시적 변환은 문법규칙이 reduce될 때 그 규칙에 맞는 코드생성 루틴을 부름으로써
중간코드 생성기(intermediate code generator)에 의해 중간코드를 생성한다.</p> <p><code>ABC := E * 3.14 + ABC / E</code>는 구문분석에서 얻어진 parse tree에 의해 다음과 같은 quadruple 중간코드를 얻는다</p> <table><thead><tr><th>중간코드</th> <th>의미</th></tr></thead> <tbody><tr><td><code>(*, E, 3.14, T0)</code></td> <td><code>T0 = E * 3.14</code></td></tr> <tr><td><code>(/, ABC, E, T1)</code></td> <td><code>T1 = ABC / E</code></td></tr> <tr><td><code>(+, T0, T1, T2)</code></td> <td><code>T2 = T0 + T1</code></td></tr> <tr><td><code>(:=, T2, Φ, ABC)</code></td> <td><code>ABC := T2</code></td></tr></tbody></table> <h4 id="코드최적화-code-optimization"><a href="#코드최적화-code-optimization" class="header-anchor">#</a> 코드최적화 (code optimization)</h4> <p>코드를 효율적으로 만들어 코드 실행시 기억공간이나 실행시간을 절약하기 위한 단계이다.</p> <p>최적화는 방법에 따라 여러가지로 나눌 수 있다</p> <ul><li>Local(Peephole) optimization / Global optimization</li> <li>단일문 최적화 / Loop 문장에서 최적화</li> <li>실행속도 최적화 / 기억장소 최적화</li></ul> <p>지역최적화란 부분적인 관점에서 비효율적인 코드를 구분해내고, 이를 효율적으로 수정한다</p> <ul><li>중복된 LOAD, STORE 명령문 제거</li> <li>불필요한 코드 제거</li> <li>제어흐름 최적화</li> <li>식(expression)의 대수학적 간소화(algebraic simplication)</li> <li>연산의 세기경감(strenth reduction)</li> <li>상수전파(constant propagation)</li> <li>복사전파(copy propagation)</li> <li>공통부분식(common subexpression) 제거</li> <li>결합 변형</li> <li>...</li></ul> <p>전역최적화는 전체적인 관점에서 보다 효율적인 코드로 수정한다</p> <ul><li>코드 이동(code motion)</li> <li>귀납변수(induction variable) 최적화</li> <li>루프융합(loop fusion)</li> <li>루프전개(loop unrolling)</li> <li>...</li></ul> <h4 id="목적코드-생성-code-generation"><a href="#목적코드-생성-code-generation" class="header-anchor">#</a> 목적코드 생성(code generation)</h4> <p>컴파일 과정의 마지막 단계로 연산을 수행할 레지스터를 선택하거나 자료에 기억장소의 위치를 정해주며,
실제로 목적기계어에 대한 코드를 생성하는 단계이다.</p> <p>중간 코드 생성 단계에서 만들어진 중간코드들을 기계명령어(machine instruction)으로 바꾸어준다</p> <h3 id="컴파일러의-물리적-구조"><a href="#컴파일러의-물리적-구조" class="header-anchor">#</a> 컴파일러의 물리적 구조</h3> <p>컴파일러의 논리적 구조를 실제로 구현하는 경우 물리적 구조는 논리적 구조와 반드시 일치하지는 않는다.</p> <p>컴파일러 구현에서는 여러단계를 모아서 하나의 모듈로 묶을 수 있는데, 이를 pass라 한다.
컴파일러의 구현방법으로는 크게 두 가지가 있다.</p> <ul><li><p>one-pass compiler: 컴파일러의 전 과정을 하나의 패스로 구현</p> <ul><li>초창기의 컴파일러</li> <li>forward jump 처리를 위해 빈칸으로 남긴 부분을 backpatching으로 채움</li> <li>효율성이 좋고 실행속도가 빠르다</li></ul></li> <li><p>two-pass compiler: 컴파일러의 구성을 중간코드를 기점으로 하여, 전/후반부로 구분함</p> <ul><li>전반부: 어휘분석, 구문분석, 중간코드 생성</li> <li>후반부: 코드최적화, 목적코드 생성</li> <li>기계코드 표현에 제약을 받고 실행속도가 느리다</li> <li>이식성이 좋고 중간코드를 이용하여 최적화 하므로 기계와 독립적인 최적화 가능</li> <li>하나의 패스가 사용했던 공간을 재사용하므로 기억장소 절약 가능</li></ul></li></ul> <h3 id="간단한-컴파일러"><a href="#간단한-컴파일러" class="header-anchor">#</a> 간단한 컴파일러</h3> <p><code>ABC := E * 3.14 + ABC / E</code></p> <p>문제를 간단히 하기 위해 조건을 한정하자</p> <ul><li>연산결과를 저장하는 누산기는 1개</li> <li>연산자인 곱셈, 나눗셈이 덧셈, 뺄셈보다 연산순위가 높다</li> <li>연산자인 덧셈, 뺄셈은 치환연산자 (:=)보다 연산순위가 높다</li></ul> <p>순서는 다음과 같다</p> <ul><li>컴파일러는 입력장치를 통해 원시 프로그램 string을 기억장치로 읽어 들인다</li> <li>기억장치 내에 있는 문자의 열을 한 문자씩 왼쪽부터 scanning 한다</li> <li>공백은 건너뛰고, 처음 토큰부터 어휘분석기로 종류를 판별한다</li> <li>식별자를 판별하면 기호표에 기록한다 (변수, 상수 ...)</li> <li>토큰에대한 식별번호를 기록한다</li> <li>피연산자 || 연산자 스택에 기록한다</li> <li>연산자 스택에 이미 자료가 있다면 연산자 우선순위를 비교한다</li></ul> <p>스택의 TOP 연산자가 우선순위가 높다면(연산처리)</p> <ul><li>연산자 스택의 TOP 요소와 피연산자 스택 요소 2개를 꺼내 연산한다</li> <li>누산기의 계수기를 통해 다른 연산결과가 저장되어 있는지 확인한다
<ul><li>다른 결과가 있다면 누산기를 사용하기 위해서 내용을 임시저장소에 저장해야 한다</li> <li>누산기 계수기를 따라가 임시기억장소인 작업용 번지의 주소로 교체한다</li></ul></li> <li>누산기의 식별번호를 피연산자 스택에 넣는다</li> <li>누산기의 계수기에 피연산자 스택의 번지를 저장한다</li> <li>누산자 계수기를 증가시킨다</li></ul> <p>현재 연산자가 우선순위가 높다면: 연산자 스택에 기록한다</p> <p>위와 같은 과정을 반복한고, 문장이 끝났다는 구분자 <code>;</code>를 만나면 스택을 정리하기 시작한다</p> <p>스택정리는 연산처리 부분을 반복하며 이루어진다</p> <h2 id="형식언어와-오토마타"><a href="#형식언어와-오토마타" class="header-anchor">#</a> 형식언어와 오토마타</h2> <h3 id="형식언어의-기초"><a href="#형식언어의-기초" class="header-anchor">#</a> 형식언어의 기초</h3> <ul><li><p>알파벳 &lt; 문자열 &lt; 형식언어</p></li> <li><p>형식언어(formal language): 어떤 알파벳에서 얻은 symbol들로 구성되는 문자열들의 집합</p></li> <li><p>알파벳: 기호들의 유한집합</p></li> <li><p>문자열: 알파벳을 구성하는 기호가 0 또는 1개 이상 나열(sequence)된 것</p></li> <li><p>문자열의 길이: 문자열을 이루는 기호들의 개수를 문자열 길이(cardinality)라 하고 <code>|w|</code>로 표시한다</p></li> <li><p>공문자열: 문자열의 길이가 0인 것을 공문자열(empty string)이라고 한다</p></li> <li><p><code>T*</code> (star closure): 공문자열을 포함하여, T에 속하는 기호들로 이루어질 수 있는 모든 문자열의 집합</p></li> <li><p><code>T+</code> (positive closure): <code>T*</code>에서 공문자열을 제외한 모든 문자열의 집합을 나타낸다</p></li></ul> <p>앞의 정의들로 언어(language)를 정의하면</p> <blockquote><p>알파벳 T에 대한 언어 L은 <code>T*</code>의 부분집합이다</p></blockquote> <h3 id="형식문법"><a href="#형식문법" class="header-anchor">#</a> 형식문법</h3> <p>형식문법이란 형식언어를 생성하기 위한 규칙들로 다음과 같이 정의할 수 있다</p> <ul><li>형식문법 <code>G = (Vn, Vt, P, S)</code> <ul><li><code>Vn</code>: 논터미널 기호들의 유한집합</li> <li><code>Vt</code>: 터미널 기호들의 유한집합</li> <li><code>P</code>: 생성규칙의 집합: <code>a -&gt; b</code>, <code>a ∈ V+</code>, <code>b ∈ V*</code></li> <li><code>S</code>: <code>Vn</code>에 속하는 기호로 다른 논터미널과 구별하여 시작기호라고 한다</li></ul></li></ul> <p>기호들의 일반적인 표기법을 나타내면 다음과 같다.</p> <ul><li>A, B, C 와 같은 영문자 대문자로 구성된 기호와 시작기호를 나타내는 S는 논터미널 기호이다</li> <li><code>&lt;</code>와 <code>&gt;</code>로 묶어서 나타낸 기호도 논터미널 기호이다</li> <li>a, b, c와 같은 영문자 소문자로 구성된 기호와 +, -와 같은 연산자기호, 괄호나 쉼표와 같은 구분자, 0, 1, 2와 같은 아라비아 숫자들은 터미널 기호이다</li> <li>X, Y, Z와 같은 영문자 끝부분의 대문자는 터미널 기호와 논터미널 기호를 나타내는 문법기호이다</li> <li>영문자 끝부분의 소문자인 u, v, w, x, y, z 등은 터미널 기호들로 이루어진 문자열을 나타낸다</li> <li>α, β, γ와 같은 그리스어 소문자는 문법기호로 구성된 문자열을 나타낸다</li> <li>아무런 언급이 없으면 첫 번재 생성규칙의 왼쪽에 있는 기호가 시작기호이다</li></ul> <h4 id="chomsky-계층구조"><a href="#chomsky-계층구조" class="header-anchor">#</a> chomsky 계층구조</h4> <p>type0 &gt; type1 &gt; type2 &gt; type3</p> <ul><li><p>type 0: α → β: 위축형 문법 포함: 튜링기계</p></li> <li><p>type 1: α → β, |α| ≤ |β|: 비위축형 문법: linear-bounded 오토마타</p></li> <li><p>type 2 (Context Free Grammar) &lt;- BNF: A → γ, A ∈ Vn: 푸시다운 오토마타</p></li> <li><p>type 3 (Regular Grammar): <code>non-terminal → [non-terminal]terminal</code>: 유한 오토마타</p> <ul><li>우선형(우측-B 증가): A → tB, A → t</li> <li>좌선형(좌측-B 증가): A → Bt, A → t</li></ul></li></ul> <h3 id="정규표현"><a href="#정규표현" class="header-anchor">#</a> 정규표현</h3> <ul><li>Φ: 공집합</li> <li>ε</li> <li>a ∈ Vt: {a}</li> <li>만일 P, Q가 정규언어 Lp, Lq를 표현하는 정규표현이라 하면
<ul><li>(P+Q): <code>a+b</code></li> <li>(P·Q): <code>ab</code></li> <li>(P*): <code>a*</code>, <code>(ab)*</code>, <code>(a+b)*</code></li></ul></li></ul> <h3 id="정규언어와-유한-오토마타-finite-automata"><a href="#정규언어와-유한-오토마타-finite-automata" class="header-anchor">#</a> 정규언어와 유한 오토마타 (Finite Automata)</h3> <h4 id="유한-오토마타"><a href="#유한-오토마타" class="header-anchor">#</a> 유한 오토마타</h4> <blockquote><p>문자열(w) -&gt; 유한 오토마타 (<code>w ∈ L(T)</code>) -&gt; Yes | No</p></blockquote> <p>문자열 w를 입력받아서 w가 언어 L(T)의 문장이면 Yes를 답하고 그렇지 않으면 No를 답하는 프로그램이다</p> <p>일반적으로 컴파일러 중에서 어휘분석기는 대표적인 유한 오토마타이다.</p> <p>유한 오토마타를 표현하는 방법에는 다음 두 가지가 있다.</p> <ul><li><p>정의에 따라서 5가지의 구성원소를 형식에 맞게 정확히 표현하는 방법</p> <ul><li>Q: 상태들의 유한집합</li> <li>Σ: 입력기호들의 유한집합</li> <li>q0: 시작상태 또는 출발상태 (q0 ∈ Q)</li> <li>F: 종료상태들의 집합 (F ∈ Q)</li> <li>δ: 상태전이함수 (Q X Σ -&gt; 2^Q(Q의 멱집합))</li></ul></li> <li><p>상태전이도(transition diagram)라는 그림을 이용하여 비형식적으로 표현하는 방법</p> <ul><li>오토마타의 각 상태를 노드로 나타내는 그림</li> <li>상태전이도에서는 상태 q에서 p로 가는 지시선 위에 a를 표기한다</li> <li>종결상태는 이중 원으로 나타내고, 시작상태는 시작 지시선으로 표시하는 directed graph이다</li></ul></li></ul> <h4 id="dfa-결정적-유한-오토마타-nfa-비결정적-유한-오토마타"><a href="#dfa-결정적-유한-오토마타-nfa-비결정적-유한-오토마타" class="header-anchor">#</a> DFA(결정적 유한 오토마타) / NFA(비결정적 유한 오토마타)</h4> <ul><li>DFA: 하나의 입력문자열에 대하여 오직 하나의 다음 상태가 결정되는 것</li> <li>NFA: 어떤 상태에서 주어진 하나의 입력기호를 보고, 갈 수 있는 다음 상태가 하나 이상 존재할 수 있는 유한 오토마타이다</li></ul> <h4 id="dfa와-nfa의-동치관계"><a href="#dfa와-nfa의-동치관계" class="header-anchor">#</a> DFA와 NFA의 동치관계</h4> <p>NFA는 언어의 구조를 쉽게 표현할 수 있는 반면, DFA보다 프로그램으로 구현하기 어렵다.
따라서 일반적인 구현은 DFA로 하게되고 NFA에서 변환하게 된다.</p> <ul><li><p>ε-전이가 있는 NFA를 DFA로 변환</p> <ul><li>ε-closure(S): S가 한 개일 경우 S와 S로 부터 레이블이 ε인 지시선으로 도달할 수 있는 모든 상태의 집합</li> <li>T가 하나 이상의 상태집합으로 되어 있는 경우에 ε-closure(T)는 T속에 있는 각 상태에 대해 위와 같은 방법으로 집합군은 구하여 합한것</li> <li>변환
<ul><li>ε-NFA의 시작상태 q0에 대해 ε-closure(q0)를 구하고 ε-closure(q0)를 DFA의 시작상태로 놓는다</li> <li>ε-closure(q0)의 원소들에 대해서 ε-NFA에 있는 ε을 제외한 각각의 입력기호에 대해 갈 수 있는 상태집합을 T1, T2 ...</li> <li>ε-closure(T1), ε-closure(T2) ... 를 구하여 DFA의 새로운 상태로 만들고, 이전에 만들어진 상태면 지시선만 만든다</li> <li>과정을 되풀이하여 새로운 상태가 나타나지 않을 때 까지 계속한다</li> <li>만들어진 상태중에서 ε-NFA의 종료상태를 포함하는 상태는 모두 DFA의 종료상태가 된다</li></ul></li></ul></li> <li><p>ε-전이가 없는 NFA를 DFA로 변환</p> <ul><li>NFA에 의해서 인식되는 언어를 L이라 하면, L을 인식하는 DFA가 존재한다</li> <li>L을 인식하는 NFA M = (Q, Σ, δ, q0, F)라 놓으면</li> <li>DFA M' = (Q', Σ', δ', q0', F')는 다음과 같이 구성된다
<ul><li>Q' = 2^Q</li> <li>F = {M의 종료상태를 포함하는 Q'안에 있는 모든 상태의 집합}</li> <li>q0' = [q0]</li></ul></li></ul></li></ul> <h4 id="dfa의-상태수-최소화"><a href="#dfa의-상태수-최소화" class="header-anchor">#</a> DFA의 상태수 최소화</h4> <p>상태수를 최소화하는 방법은 동치관계를 이용하여 상태수를 합침(state merge)으로써 상태수를 최소화할 수 있다.</p> <ul><li>w ∈ Σ* 에 대해서 q1에서 w를 다 본 상태가 q3이고 q2에서 w를 다 본 상태가 q4일 때, q3, q4 중 하나만 종료상태에 속하면 q1은 q2로부터 구별(distinguish)된다고 말한다</li> <li>만약 상태집합 Q속에 상태가 도달 가능하지 않고, Q의 서로 다른 두 상태가 구별 가능하지 않다면 축약(reduce)될 수 있다</li></ul> <p>상태수 최소화는 다음과 같은 과정으로 이루어진다</p> <ol><li>시작상태로부터 도달 불가능한 상태를 모두 제거한다</li> <li>초기의 동치관계인 [종료상태]와 [미결상태]의 두 동치류로 분할한다</li> <li>같은 입력기호에 대해 서로 다른 동치류로 가는 지시선이 존재하면 또 다른 분할을 하여 새로운 동치류를 만든다</li> <li>3의 과정을 되풀이하여 더 이상 새로운 분할이 일어나지 않을 때까지 반복한다</li> <li>M의 종료상태에 속하는 상태가 동치류 속에 들어 있으면 이 동치류는 M'의 종료상태이다</li></ol> <h4 id="정규문법-정규표현-유한-오토마타의-동치관계"><a href="#정규문법-정규표현-유한-오토마타의-동치관계" class="header-anchor">#</a> 정규문법, 정규표현, 유한 오토마타의 동치관계</h4> <p>정규문법, 정규표현, 유한 오토마타는 서로 변환되는 동치관계이다</p> <p>정규표현을 유한 오토마타로 변환하는 과정은 다음과 같다</p> <ul><li>정규표현으로부터 NFA를 구한다</li> <li>NFA를 DFA로 변환한 다음 최호화된 DFA를 구한다</li></ul> <p>유한 오토마타를 정규문법으로 변환하는 과정은 다음과 같다</p> <ul><li>상태전이도에서 각각의 상태를 하나의 논터미널이라 하고 입력기호를 터미널 기호라 하자</li> <li>정규문법을 작성하는데 왼편에는 상태를 나타내는 논터미널을 쓴다</li> <li>오른편에는 전이지시선 위에 있는 입력기호인 터미널 기호를 쓰고 다음에 전이되는 상태를 쓴다</li></ul> <h2 id="어휘분석"><a href="#어휘분석" class="header-anchor">#</a> 어휘분석</h2> <h3 id="어휘분석-lexical-analysis-이란"><a href="#어휘분석-lexical-analysis-이란" class="header-anchor">#</a> 어휘분석(lexical analysis)이란</h3> <p>어휘분석은 원시 프로그램을 구성하는 문자들을 하나의 긴 문장열로 보고 문자를 차례대로 scanning하고 token이라는 단위로 변환하는 것이다.</p> <p>어휘분석을 담당하는 도구를 어휘분석기/scanner 라고 한다.</p> <p>토큰이란 의미 있는 문법적 단위인데, 일반적인 프로그래밍 언어에서는 5종류의 토큰을 사용한다</p> <ul><li>식별자(identifier): SUM, A, B와 같이 프로그래머가 정의하는 변수</li> <li>상수(constant): 1, 2, 3, 'abc'와 같이 정수형 상수, 실수형 상수, 문자형 상수</li> <li>예약어(reserved word): IF, WHILE과 같이 언어 구현시 이미 정의되어 있는 지정어</li> <li>연산자(operator): -, +, *, / 등고 같이 연산시 사용되는 기호</li> <li>구분자(delimiter): (, [, ; 등과 같이 단어와 단어를 구분하기 위해 사용되는 기호</li></ul> <p>일반적으로 토큰은 토큰번호와 토큰값의 순서쌍으로 표현된다.
토큰번호란 각각의 토큰을 구분하기 위해서 고유의 내부번호를 부여한 정수코드이고, 토큰값은 기호에서 토큰의 위치로 표현된다.</p> <p>어휘분석기는 토큰번호와 토큰값을 출력하기 위해서 입력에 대해 복귀 값(return value)을 갖고 있어야 하며,
주어진 모든 문법에 대한 토큰번호와 토큰값을 가지고 있어야 한다.</p> <p>그러나 프로그래머가 사용한 식별자와 상수에 대한 토큰값과 속성을 나타내는 정보는 기호표(symbol table)에 별도로 보관된다.</p> <p>어휘분석 단계에서 어휘분석기는 원시 프로그램을 분석하여 토큰열을 생산하면서 얻어진 식별자에 대해 기호표를 검색하여,
기호표에 이미 있으면 다시 작성하지 않고 없으면 기호표에 식별자를 삽입한 뒤
구문분석기에게 식별자에 대한 토큰번호와 값으로 기호표 인덱스를 전달한다.</p> <h3 id="어휘-분석기의-설계"><a href="#어휘-분석기의-설계" class="header-anchor">#</a> 어휘 분석기의 설계</h3> <p>어휘분석기를 설계하려면 우선 문법이 주어져야 한다. 문법의 형태는 앞에서 살펴본 정규문법의 형태이다.
그리고 주어진 문법의 문법단위에 대한 token table을 작성한다. token table은 어휘분석기에서 돌려 주는 값을 나타낸다.</p> <p>문법을 보고 NFA를 구성하고, NFA를 DFA로 변환한다음 DFA를 최소화시키면 어휘분석기가 된다.
여기에 최소화된 DFA에 의해 검색하면서 기호표를 작성할 수 있도록 해야 한다.</p> <h3 id="어휘분석기-구현-고려사항"><a href="#어휘분석기-구현-고려사항" class="header-anchor">#</a> 어휘분석기 구현 고려사항</h3> <p>분류한 토큰들은 항상 사용되는 것이 아니라 문법이 어떻게 주어지느냐에 따라 다르다.
그러므로 어휘분석기를 구현할 때는 문법이 어떻게 주어지는지 명확하게 정의되어야 하며,
명확하게 정의된 문법에 의해서 토큰의 종류를 나열해야 한다.</p> <p>또한 상태전이도의 순서를 어떻게 주느냐에 따라 어휘분석을 하는 시간이 달라진다.
그러므로 프로그램 작성시 어느 토큰을 많이 사용하는지를 파악하여 어휘분석기를 구현해야 한다.</p> <h2 id="context-free-언어와-문법의-효율화"><a href="#context-free-언어와-문법의-효율화" class="header-anchor">#</a> Context-Free 언어와 문법의 효율화</h2> <h3 id="context-free-언어와-푸시다운-오토마타"><a href="#context-free-언어와-푸시다운-오토마타" class="header-anchor">#</a> Context-Free 언어와 푸시다운 오토마타</h3> <p>context-free 문법은 산술식이나 블록 구조를 표헌하는데 효율적이기 때문에 프로그래밍 언어 중에서 가장 널리 사용되고 있다.
context-free 문법은 자연언어(natural language)를 표현하기 위해 도입되었다.</p> <p>context-free언어는 정규언어보다 표현범위가 넓어서, 이것을 인식하는 push-down 오토마타를 구현하는 일은 유한 오토마타를 구현하는 일보다 어렵다.</p> <h3 id="유도트리"><a href="#유도트리" class="header-anchor">#</a> 유도트리</h3> <ul><li>좌단유도(leftmost derivation): 유도과정의 각 단계에서 문장형태(sentential form)의 가장 왼쪽에 있는 논터미널 기호를 계속 대체하는 경우</li> <li>우단유도(rightmost derivation): 좌단유도와 반대로 가장 오른쪽에 있는 논터미널 기호를 계속 대체</li> <li>좌파스(left parse): 하나의 문장을 만들때 좌단유도에 의해서 적용된 일련의 생성규칙 순서</li> <li>우파스(right parse): 우단유도에 의해서 적용된 생성규칙의 순서의 역순</li></ul> <p>좌파스와 우파스는 구문분석의 방법과 깊은 연관관계가 있다.
top-down 구문분석은 좌파스를 생성하고, bottom-up 구문분석은 우파스를 생성한다.</p> <p>또한 구문분석을 하는 과정은 문장이 유도되는 과정을 트리 형태로 표현하는데, 이를 유도트리(derivation tree)혹은 파스트리(parse tree)라 한다.</p> <p>CFG(context-free grammar)에 대한 유도트리는 다음과 같이 정의한다</p> <ul><li>모든 노트(vertex, node)는 문법기호를 레이블(lable)로 갖는다</li> <li>루트(root)의 레이블은 시작기호 S이다</li> <li>만약 어떤 노드가 하나 이상의 자식노드(child node)를 갖는다면 이 노드는 논터미널 기호를 레이블로 갖는다</li> <li>왼쪽부터 순서적으로 X1, X2, ... Xn의 n개의 자식노드를 갖는 어떤 노드 A가 존재한다면 생성규칙이 존재한다</li> <li>만약 어떤 노드가 자식노드를 하나도 가지고 있지 않다면, 이 노드를 leaf(terminal node)라 한다</li></ul> <h3 id="모호성"><a href="#모호성" class="header-anchor">#</a> 모호성</h3> <p>구문분석 단계에서는 출력으로 유도트리를 생성하는데 문법이 모호한 경우에는 문장의 유도트리를 결정적으로 구성하기 어렵다.
따라서 구문분석기 구현이 복잡해지고 구문분석을하는 시간이 오래걸리는데, 이를 막기위하여 모호하지 않은 문법으로 바꿔줘야 한다.</p> <ul><li>모호한 문법에 연산자 우선순위와 결합법칙을 적용하여 모호하지 않은 문법으로 바꿀 수 있다.</li> <li>하나의 context-free 언어를 생성하는 모든 문법이 모호하다면, 이 언어를 inherently ambiguous라고 한다.</li> <li>모호성 문법 외에도 구문분석을 하는데 효율을 높이기 위해 적당한 문법으로 바꾸어줄수 있는데, 이를 context-free 문법의 단순화라고 한다.</li></ul> <h3 id="불필요한-생성규칙의-제거"><a href="#불필요한-생성규칙의-제거" class="header-anchor">#</a> 불필요한 생성규칙의 제거</h3> <p>불필요한 기호는 터미널 문자열을 생성할 수 없는 논터미널 기호이거나 시작기호로부터 도달 불가능한 기호를 말한다.
이와같이 불필요한 기호를 가지고 있는 생성규칙을 불필요한 생성규칙이라고 한다.</p> <h3 id="ε-생성규칙의-제거"><a href="#ε-생성규칙의-제거" class="header-anchor">#</a> ε-생성규칙의 제거</h3> <p>ε-생성규칙이란 A -&gt; ε 형태의 생성규칙을 갖는 것을 말한다.
만약 ε이 L(G)안에 없다면 ε-생성규칙을 완전히 제거할 수 있다.</p> <h3 id="단일-생성규칙의-제거"><a href="#단일-생성규칙의-제거" class="header-anchor">#</a> 단일 생성규칙의 제거</h3> <p>단일 생성규칙(unit production)이란 생성규칙 중 생성규칙의 오른쪽이 단 한개의 논터미널로 구성되어 있는 생성규칙이 존재하는 경우를 말한다.</p> <h3 id="left-factoring"><a href="#left-factoring" class="header-anchor">#</a> left-factoring</h3> <p>같은 기호들을 prefix로 갖는 두 개 이상의 생성규칙이 존재할 경우, 공통된 prefix를 인수분해하는 것을 left-factoring이라고 한다.</p> <h3 id="left-recursion의-제거"><a href="#left-recursion의-제거" class="header-anchor">#</a> left-recursion의 제거</h3> <p>문법이 어떤 문자열 α에 대해 A -&gt; Aα의 유도과정이 존재하는 경우를 left-recursive하다고 말하며,
이러한 문법은 top-down 구문분석 시에 같은 생성규칙이 반복적으로 적용되어 무한루프에 빠지게 되므로 구문분석을 어렵게한다.</p> <p>left-recursion에는 두 가지가 있다.</p> <ul><li>immme-diate left-recursion: A -&gt; Aα 형태의 생성규칙</li> <li>indirect left-recursion: A -&gt; Aα 유도과정이 존재하는 경우</li></ul> <h3 id="푸시다운-오토마타"><a href="#푸시다운-오토마타" class="header-anchor">#</a> 푸시다운 오토마타</h3> <p>푸시다운 오토마타의 대표적인 예로서는 구문분석기가 있다.
푸시다운 오토마타는 유한 상태제어와 입력 테이프 외에 무한정의 용량을 가진 스택으로 구성된다.</p> <p>푸시다운 오토마타에는 비결정적 푸시다운 오토마타와(NPDA)와 결정적 푸시다운 오토마타(DPDA)의 두 종류가 있다.</p> <h2 id="구문분석"><a href="#구문분석" class="header-anchor">#</a> 구문분석</h2> <p>구문구조가 주어진 규칙에 맞는지를 검사하는 것을 구문분석(syntax analysis)혹은 파싱(parsing)이라고 한다.</p> <p>이러한 구문분석을 담당하는 도구를 구문분석기(syntax analyzer, parser)라고 한다.
일반적으로 구문분석의 출력으로 생성되는 트리는 유도트리(derivation tree)와 같은 모양을 갖는데,
유도과정을 나타낼 때는 유도트리라 하고, 구문분석기에 의해 생성될 때는 파스트리라고 한다.</p> <p>구문분석은 파스트리를 어떤 순서로 만들어 가느냐에 따라 top-down 방법과 bottom-up 방법의 두 종류로 나눌 수 있다.</p> <h3 id="bottom-up-구문분석"><a href="#bottom-up-구문분석" class="header-anchor">#</a> Bottom-up 구문분석</h3> <p>bottom-up 구문분석 방법은 주어진 문자열로부터 reduce에 의해 시작기호를 찾아가는 방법이다.</p> <blockquote><p>문장 -&gt; 시작기호</p></blockquote> <p>(예) Top-down id + id * id 좌단유도 (id: identifier)</p> <ul><li>E -&gt; E + E</li> <li>-&gt; id + E</li> <li>-&gt; id + E * E</li> <li>-&gt; id + id * E</li> <li>-&gt; id + id * id</li></ul> <p>(예) Bottom-up id + id * id 우단유도 (id: identifier)</p> <ul><li>id + id * id (<code>id</code>)</li> <li>-&gt; E + id * id (<code>id</code>)</li> <li>-&gt; E + E * id (<code>id</code>)</li> <li>-&gt; E + E * E (<code>E * E</code>)</li> <li>-&gt; E + E (<code>E + E</code>)</li> <li>-&gt; E (<strong>handle</strong>)</li></ul> <h4 id="shift-reduce-구문분석"><a href="#shift-reduce-구문분석" class="header-anchor">#</a> shift-reduce 구문분석</h4> <table><thead><tr><th>단계</th> <th>스택</th> <th style="text-align:right;">입력</th> <th>구문분석 행동</th></tr></thead> <tbody><tr><td>0</td> <td>$</td> <td style="text-align:right;">id+id*id $</td> <td><code>shift id</code></td></tr> <tr><td>1</td> <td>$id</td> <td style="text-align:right;">+id*id $</td> <td><code>reduce E -&gt; id</code></td></tr> <tr><td>2</td> <td>$E</td> <td style="text-align:right;">+id*id $</td> <td><code>shift +</code></td></tr> <tr><td>3</td> <td>$E+</td> <td style="text-align:right;">id*id $</td> <td><code>shift id</code></td></tr> <tr><td>4</td> <td>$E+id</td> <td style="text-align:right;">*id $</td> <td><code>reduce E -&gt; id</code></td></tr> <tr><td>5</td> <td>$E+E</td> <td style="text-align:right;">*id $</td> <td><code>shift *</code></td></tr> <tr><td>6</td> <td>$E+E*</td> <td style="text-align:right;">id $</td> <td><code>shift id</code></td></tr> <tr><td>7</td> <td>$E+E*id</td> <td style="text-align:right;">$</td> <td><code>reduce E -&gt; id</code></td></tr> <tr><td>8</td> <td>$E+E*E</td> <td style="text-align:right;">$</td> <td><code>reduce E -&gt; E*E</code></td></tr> <tr><td>9</td> <td>$E+E</td> <td style="text-align:right;">$</td> <td><code>reduce E -&gt; E+E</code></td></tr> <tr><td>10</td> <td>$E</td> <td style="text-align:right;">$</td> <td><code>accept</code></td></tr></tbody></table> <p>스택 최상단 / 입력 좌측 순위 비교로 연산결정: 터미널-터미널 / 기호-기호</p> <h3 id="여러가지-순위문법과-용어"><a href="#여러가지-순위문법과-용어" class="header-anchor">#</a> 여러가지 순위문법과 용어</h3> <ul><li><p>FIRST(A): 문자열 A로부터 유도되어, 첫 번째로 나타날 수 있는 터미널 기호들의 집합</p> <ul><li><code>FIRST(E) = (FIRST(T) ring sum FIRST(E')</code>)</li> <li><code>A ring sum B = A if ε not ∈ A</code></li> <li><code>A ring sum B = (A-ε) ∪ B if ε ∈ A</code></li></ul></li> <li><p>FOLLOW(A): A 뒤에 나오는 터미널 기호들</p> <ul><li>if A == 출발기호, $ ∈ FOLLOW(A)</li> <li>if B -&gt; αAβ, β != ε, FOLLOW(A) ⊃ FIRST(β) (ε 제외)</li> <li>if B -&gt; αAβ &amp; B =&gt; ε, FOLLOW(A) ⊃ FOLLOW(B)</li></ul></li></ul> <h3 id="단순순위-구문분석"><a href="#단순순위-구문분석" class="header-anchor">#</a> 단순순위 구문분석</h3> <p>단순순위 문법을 가지고 구문분석을 하는 방법으로 논터미널과 터미널, 논터미널과 논터미널 사이에 순위관계를 부여해서 구문분석을 한다.
순위관계를 트리로 표현했을 때, 자식노드가 부모노드보다 순위가 높다.</p> <p>그러나 단순순위 구문분석에서는 핸들 결정 문제점때문에 부정확하다.</p> <h3 id="lr-구문분석"><a href="#lr-구문분석" class="header-anchor">#</a> LR 구문분석</h3> <ul><li>모호하지 않은 CFG이면 모두 가능</li> <li>Backtracking이 없다</li></ul> <h4 id="slr-simple-lr-구문분석"><a href="#slr-simple-lr-구문분석" class="header-anchor">#</a> SLR(Simple LR) 구문분석</h4> <h4 id="clr-canonical-lr-구문분석"><a href="#clr-canonical-lr-구문분석" class="header-anchor">#</a> CLR(Canonical LR) 구문분석</h4> <h4 id="lalr-lookahead-lr-구문분석"><a href="#lalr-lookahead-lr-구문분석" class="header-anchor">#</a> LALR(LookAhead LR) 구문분석</h4> <h3 id="top-down-구문분석"><a href="#top-down-구문분석" class="header-anchor">#</a> Top-Down 구문분석</h3> <h2 id="의미분석과-기호표"><a href="#의미분석과-기호표" class="header-anchor">#</a> 의미분석과 기호표</h2> <h3 id="의미분석-개요"><a href="#의미분석-개요" class="header-anchor">#</a> 의미분석 개요</h3> <ul><li><p>상수정의 과정</p> <ul><li>상수 이름 기호표에 등록</li> <li>이후 기억장소 배정 및 초기값 설정</li></ul></li> <li><p>유형(type)정의 과정</p> <ul><li>유형의 자료구조 구성 및 보관</li> <li>유형설명자(유형의 자료구조 크기, 성격 ...) 작성</li> <li>기억장소 배정 때 정보 제공</li></ul></li> <li><p>변수의 유형선언</p> <ul><li>변수의 유형에 따른 유형 설명자와 변수명칭이 기호표에 함께 등록</li> <li>각 변수는 기억장소 배정</li></ul></li></ul> <h3 id="기호표-구성"><a href="#기호표-구성" class="header-anchor">#</a> 기호표 구성</h3> <ul><li><p>선형리스트</p> <ul><li>가장 간단하고 쉽게 구현할 수 있는 방법</li> <li>하나의 이름 삽입 = 1/2 * n = cn</li> <li>하나의 이름을 조회 = 1/2 * n = cn</li> <li>m개의 이름을 조회 = cn * m</li> <li>n개의 이름삽입과 m개의 이름조회에 필요한 시간: <code>cn * n + cn * m = cn * (n+m)</code></li></ul></li> <li><p>트리</p> <ul><li>이진트리 조회시간</li> <li>트리 평균 높이(조회에 필요한 평균시간)
<ul><li>log n에 비례 (n = 식별자 이름의 수)</li> <li>n개의 이름 삽입 = n log n</li> <li>m개의 이름 조회 = m log n</li></ul></li> <li>전체시간: <code>(n+m)log n</code>에 비례</li> <li>n &gt; 50 이면 선형리스트보다 효율적</li></ul></li> <li><p>해쉬 테이블</p> <ul><li>가장 효율이 좋은 검색법</li> <li>추가 및 조회 시간 = <code>n / k (m + n)</code> (n: 식별자 이름 추가, m: 조회, k: 해쉬테이블 index)</li> <li>해쉬 충돌발생시 처리방법?</li></ul></li></ul> <h3 id="상수정의와-의미분석"><a href="#상수정의와-의미분석" class="header-anchor">#</a> 상수정의와 의미분석</h3> <p>유형은 식별자의 종류</p> <ul><li>CONSTID: 상수</li> <li>TYPEID: 각종타입</li> <li>SIMPLEVARID: 단순변수 유형</li> <li>FIELDID: record type에서 field-id-list 유형</li> <li>PROCID: 프로시저</li></ul> <p>상수정의 원시 프로그램 예시</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>CONST
  X = 2;
  Z = -X;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>어휘분석에서 다음 토큰으로 분리됨: <code>CONST, OTHERID, =, UNsigned_INTERGER</code></p> <p>기호표와 스택 포인터 값은 다음과 같다</p> <ul><li>인덱스: 이름: 유형</li> <li>K1: X: CONSTID
<ul><li>k2</li> <li>new</li> <li><code>+</code></li></ul></li> <li>K2: 2: CONSTID</li> <li>K3: Z: CONSTID
<ul><li>k2</li> <li>old</li> <li><code>-</code></li></ul></li></ul> <h2 id="중간언어와-중간코드-생성"><a href="#중간언어와-중간코드-생성" class="header-anchor">#</a> 중간언어와 중간코드 생성</h2> <h3 id="중간언어의-장점"><a href="#중간언어의-장점" class="header-anchor">#</a> 중간언어의 장점</h3> <ul><li>컴파일러를 기능적으로 독립적인 여러 모듈들로 구성할 수 있따</li> <li>원시 프로그래므이 이식성을 증가시킬 수 있다</li> <li>고급 원시언어와 저급 목적코드 간의 의미적 차이를 이어주는 교량 역할</li> <li>번역과정이 좀더 쉽게 표현되고 효율적으로 처리될 수 있다</li> <li>기계와 독립적인 최적화가 가능하다</li> <li>인터프리티브 컴파일링 시스템에서 인터프리터를 이용하여 실행할 수 있다</li> <li>목적코드로 직접 번역한 것 보다 컴파일 시간이 더 소요되고 비효율적인 코드를 생성함</li></ul> <h3 id="중간언어의-종류"><a href="#중간언어의-종류" class="header-anchor">#</a> 중간언어의 종류</h3> <ul><li>Polish 표기법: Postfix 표현, IR(Prefix 표현)</li> <li>3-주소 코드</li> <li>Triple, Quadruple, 간접 Triple</li> <li>트리구조 코드: AST, TCOL, Diana</li> <li>가상 기계 코드</li> <li>P-코드, EM-코드, U-코드, 바이트코드</li></ul> <h4 id="후위-postfix-표현"><a href="#후위-postfix-표현" class="header-anchor">#</a> 후위(Postfix) 표현</h4> <p><code>b * c - d</code></p> <ul><li>b * c - d</li> <li>b * c d -</li> <li>b c * d -</li></ul> <p>변환이 쉽고 빠르며 중간언어로 적합하나, 코드이동이 불가능하여 최적화 부적합</p> <h4 id="_3-주소-코드"><a href="#_3-주소-코드" class="header-anchor">#</a> 3-주소 코드</h4> <p>치환문 <code>A:= -B * (C + D)</code></p> <ul><li>T1 := -B</li> <li>T2 := C + D</li> <li>T3 := T1 * T2</li> <li>A := T3</li></ul> <p>3주소 코드는 다음 방식이 존재</p> <ul><li>TRIPLE: OP, 피연산자1, 피연산자2</li> <li>간접 TRIPLE: 수행순서 + TRIPLE</li> <li>Quadruple: TRIPLE + 결과</li></ul> <h3 id="구문지시적-변환-syntax-directed-translation"><a href="#구문지시적-변환-syntax-directed-translation" class="header-anchor">#</a> 구문지시적 변환(syntax-directed translation)</h3> <ul><li>구문분석을 하면서 구문구조에 따라 직접 중간코드를 생산하는 방법</li> <li>생성규칙 + 의미수행코드로 구성</li> <li>생성규칙이 사용될 때 마다 의미수행 규칙을 수행하게 된다</li></ul> <h4 id="계산기-예제"><a href="#계산기-예제" class="header-anchor">#</a> 계산기 예제</h4> <p>입력문자열: 23*5+4$</p> <table><thead><tr><th>생성규칙</th> <th>의미수행 규칙</th></tr></thead> <tbody><tr><td>S -&gt; E$</td> <td>{print E.VAL}</td></tr> <tr><td>E -&gt; E(1) + E(2)</td> <td>{E.VAL := E(1).VAL + E(2).VAL}</td></tr> <tr><td>E -&gt; E(1) * E(2)</td> <td>{E.VAL := E(1).VAL * E(2).VAL}</td></tr> <tr><td>E -&gt; (E(1))</td> <td>{E.VAL := E(1).VAL}</td></tr> <tr><td>E -&gt; I</td> <td>{E.VAL := I.VAL}</td></tr> <tr><td>E -&gt; I(1) digit</td> <td>{I.VAL := 10 * I(1).VAL + LEXVAL}</td></tr> <tr><td>I -&gt; digit</td> <td>{I.VAL := LEXVAL}</td></tr></tbody></table> <blockquote><p>digit: 0, 1, 2, ..., 9</p></blockquote> <h3 id="중간코드-생성"><a href="#중간코드-생성" class="header-anchor">#</a> 중간코드 생성</h3> <p>프로그램 언어의 문장부분은 다음으로 구성된다</p> <ul><li>수식: 산술식, 부울식</li> <li>치환문</li> <li>입출력문</li> <li>제어문: 조건문, 분기문</li> <li>반복문</li> <li>부프로그램: 정의와 호출문</li></ul> <h2 id="코드최적화"><a href="#코드최적화" class="header-anchor">#</a> 코드최적화</h2> <h3 id="코드최적화의-개념"><a href="#코드최적화의-개념" class="header-anchor">#</a> 코드최적화의 개념</h3> <p>목적 프로그램의 최적화(optimization)는 주어진 원시 프로그램에 대하여 가장 경제적인 목적 프로그램을 생산하도록 하는일이다.</p> <p>살펴볼 최적화는 실행시간을 짧게 하기위한 최적화와 소요 기억용량을 작게하는 최적화이다.</p> <h3 id="실행시간을-짧게-하기-위한-최적화"><a href="#실행시간을-짧게-하기-위한-최적화" class="header-anchor">#</a> 실행시간을 짧게 하기 위한 최적화</h3> <ul><li><p>공통 부분식(common subexpression)의 제거</p> <ul><li>프로그램에서 공통된 부분이 여러 번 나타나는 경우</li> <li>공통 부분식이 한 번만 계산되도록 함으로써 코드를 효율적으로 만들 수 있다</li></ul></li> <li><p>상수전파(constant propagation)</p> <ul><li>컴파일시에 상수를 퐇마하는 연산이 계산될 수 있으면 계산을 함으로써 코드를 줄이는 방법이다</li></ul></li> <li><p>코드이동(code motion)</p> <ul><li>루프를 포함하는 프로그램이 있는 경우, 루프안에 있는 명령문을 결과값이 바뀌지 않는 한도내에서 되도록이면 루프 밖으로 꺼내는 방법</li> <li>루프를 여러번 수행해도 항상 같은 결과를 갖는 루프불변(loop invariant)계산의 경우에 적용한다</li></ul></li> <li><p>루프융합(loop fusion)</p> <ul><li>여러 개의 루프를 하나의 루프로 만드는 것</li></ul></li> <li><p>루프전개(loop unrolling)</p> <ul><li>루프 계산을 빠르게 하기 위해서 루프를 펼치는 효과를 내는 것</li></ul></li> <li><p>프로시저 호출 전개</p> <ul><li>프로시저 호출 실행에는 실제인자 전달이 필요</li> <li>호출된 프로시저에서는 레지스터 교체, 자료영역 확보, 복귀 때의 레지스터 회복 등 많은 처리가 필요</li> <li>어떤 경우에는 프로시저를 호출하는 곳에서 호출되는 프로시저를 전개하면 위의 처리를 생략할 수 있다</li></ul></li> <li><p>불필요한 코드의 제거</p> <ul><li>불필요한 코드로는 도달할 수 없는 코드와 사용되지 않는 코드가 있다</li></ul></li> <li><p>복사전파(copy propagation)</p> <ul><li>치환문을 삭제하고 삭제된 치환문의 1-value 대신에 r-value를 사용하는 방법</li></ul></li> <li><p>식의 연산순서 변경(rearrangeing expression)</p> <ul><li>식의 연산순서 변경에 의해 연산이 임시결과를 저장하거나 로드 횟수를 최소화 함</li> <li>임시변수 기억공간 절약 및 효율적인 코드 생산</li></ul></li> <li><p>중복된(redundant) 로드-저장 명령문 제거</p> <ul><li>중복되는 로드 명령문이나 저장 명령문을 저거함</li></ul></li> <li><p>제어흐름(flow of control)의 최적화</p> <ul><li>불필요한 jump문을 제거하는 방법</li></ul></li> <li><p>식의 대수학적 간소화(algebraic simplication)</p> <ul><li>식을 간소화 시킨다. 즉, <code>Y := X * 1</code> 과 같은 식을 <code>Y := X</code>로 변경할 수 있다</li></ul></li> <li><p>연산의 세기 경감(reduction in strength)</p> <ul><li>보다 빠른 계산을 하기 위해서 <code>X ** 2</code>를 <code>X * X</code>로, <code>X * 2</code>를 <code>X + X</code>로 치환하는 것을 말함</li></ul></li> <li><p>결합변경</p> <ul><li>여러개의 문장들을 보다 효율적인 문장으로 변경하는 것</li></ul></li> <li><p>귀납변수 최적화(induction variable)</p> <ul><li>귀납변수는 루프를 돌 때마다 값이 일률적으로 변하는 변수</li> <li>연산의 세기 경감에 따라 최적화 할 수 있다</li></ul></li> <li><p>기타 방법</p> <ul><li>레지스터 할당, 컴퓨터의 특수명령 할당 등의 문제</li></ul></li></ul> <h3 id="소요-기억용량-최적화"><a href="#소요-기억용량-최적화" class="header-anchor">#</a> 소요 기억용량 최적화</h3> <ul><li><p>부프로그램화</p> <ul><li>프로그램중 같은 패턴이 여러 번 나타나면 부프로그램화 하는 것이 효과적</li> <li>원시 프로그램보다 중간코드에 대해서 행하는 것이 효과적임</li></ul></li> <li><p>부분식 끌어올리기(code hoisting)</p> <ul><li>같은 식의 연산이 여러 군데 있는 경우, 그것보다 먼저 나오는 어딘가 한 곳에 그 연산을 처리함</li></ul></li></ul> <h3 id="최적화의-구현"><a href="#최적화의-구현" class="header-anchor">#</a> 최적화의 구현</h3> <p>최적화 방법은 원시 프로그램이 어떤 것이냐에 따라 다른 방법을 선택해야 한다.</p> <h2 id="목적코드-생성"><a href="#목적코드-생성" class="header-anchor">#</a> 목적코드 생성</h2> <h3 id="목적코드-생성의-개요"><a href="#목적코드-생성의-개요" class="header-anchor">#</a> 목적코드 생성의 개요</h3> <p>목적코드 생성은 대상기계에 따라 다르기 때문에, 상황에 맞춰 생성방식을 결정해야 한다.
목적코드는 중간코드를 입력으로 받아 기계에 맞는 기계어로 생성할 수 있고, 어셈블리어로도 생성할 수 있다.</p> <p>목적 코드를 생성하는 데는 다음 세 가지 사항을 고려해야 한다</p> <ul><li><p>어떤 명령어(instruction)를 생성할 것인지 결정해야 함</p> <ul><li>대부분의 기계들이 같은 연산에 대하여 다양한 명령어를 가지고 있기 때문</li></ul></li> <li><p>계산과정을 어떤 순서로 하는지 결정</p> <ul><li>연산순서에 따라 레지스터의 개수나 기억장소의 요구량이 달라지기 때문</li></ul></li> <li><p>피연산자를 레지스터에 어떻게 배정할 것인지 결정해야 함</p> <ul><li>어떤 레지스터를 사용하느냐에 따라 연산의 종류에도 제한이 생기기 때문</li> <li>곱셈이나 나눗셈은 연속의 레지스터를 두 개 사용하고 그 순서가 맞아야 한다</li> <li>일반적으로 기억장소보다는 레지스터를 사용하면 연산속도가 훨씬 빨라진다</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/wiki/assets/js/app.b3a0b150.js" defer></script><script src="/wiki/assets/js/2.989cddfe.js" defer></script><script src="/wiki/assets/js/127.ad1f9c7a.js" defer></script>
  </body>
</html>
