<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP Basic | TIL wiki</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/wiki/assets/css/0.styles.28a8e502.css" as="style"><link rel="preload" href="/wiki/assets/js/app.92ee9d6a.js" as="script"><link rel="preload" href="/wiki/assets/js/2.9f07087a.js" as="script"><link rel="preload" href="/wiki/assets/js/159.c34e728e.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.20c5bdc5.js"><link rel="prefetch" href="/wiki/assets/js/100.d562b67c.js"><link rel="prefetch" href="/wiki/assets/js/101.f4ba3b78.js"><link rel="prefetch" href="/wiki/assets/js/102.33fc3951.js"><link rel="prefetch" href="/wiki/assets/js/103.c51648d8.js"><link rel="prefetch" href="/wiki/assets/js/104.09703f6c.js"><link rel="prefetch" href="/wiki/assets/js/105.b6d1805f.js"><link rel="prefetch" href="/wiki/assets/js/106.393365be.js"><link rel="prefetch" href="/wiki/assets/js/107.8e25e6a4.js"><link rel="prefetch" href="/wiki/assets/js/108.abbb4f28.js"><link rel="prefetch" href="/wiki/assets/js/109.88fba153.js"><link rel="prefetch" href="/wiki/assets/js/11.11681293.js"><link rel="prefetch" href="/wiki/assets/js/110.65ed7deb.js"><link rel="prefetch" href="/wiki/assets/js/111.1cd299bd.js"><link rel="prefetch" href="/wiki/assets/js/112.957fd9e5.js"><link rel="prefetch" href="/wiki/assets/js/113.b57c7be2.js"><link rel="prefetch" href="/wiki/assets/js/114.fc45b238.js"><link rel="prefetch" href="/wiki/assets/js/115.59f5e9ef.js"><link rel="prefetch" href="/wiki/assets/js/116.26baa650.js"><link rel="prefetch" href="/wiki/assets/js/117.194cb0a8.js"><link rel="prefetch" href="/wiki/assets/js/118.a7cda24c.js"><link rel="prefetch" href="/wiki/assets/js/119.d5e658f3.js"><link rel="prefetch" href="/wiki/assets/js/12.efe209c8.js"><link rel="prefetch" href="/wiki/assets/js/120.b69e1f5a.js"><link rel="prefetch" href="/wiki/assets/js/121.8bc60e06.js"><link rel="prefetch" href="/wiki/assets/js/122.d5dd4a95.js"><link rel="prefetch" href="/wiki/assets/js/123.3c47e2ee.js"><link rel="prefetch" href="/wiki/assets/js/124.0a9c76bf.js"><link rel="prefetch" href="/wiki/assets/js/125.0363c877.js"><link rel="prefetch" href="/wiki/assets/js/126.159c5518.js"><link rel="prefetch" href="/wiki/assets/js/127.6f0077d6.js"><link rel="prefetch" href="/wiki/assets/js/128.8c4e2e4c.js"><link rel="prefetch" href="/wiki/assets/js/129.56b9320c.js"><link rel="prefetch" href="/wiki/assets/js/13.f6c1fffd.js"><link rel="prefetch" href="/wiki/assets/js/130.0772b490.js"><link rel="prefetch" href="/wiki/assets/js/131.427804e6.js"><link rel="prefetch" href="/wiki/assets/js/132.74fb3e90.js"><link rel="prefetch" href="/wiki/assets/js/133.e949179d.js"><link rel="prefetch" href="/wiki/assets/js/134.4659673c.js"><link rel="prefetch" href="/wiki/assets/js/135.4c3feeec.js"><link rel="prefetch" href="/wiki/assets/js/136.c5dd947f.js"><link rel="prefetch" href="/wiki/assets/js/137.06a5b30b.js"><link rel="prefetch" href="/wiki/assets/js/138.aa5088e0.js"><link rel="prefetch" href="/wiki/assets/js/139.16ebcc04.js"><link rel="prefetch" href="/wiki/assets/js/14.19011e4a.js"><link rel="prefetch" href="/wiki/assets/js/140.ca99ca6f.js"><link rel="prefetch" href="/wiki/assets/js/141.e4dc914c.js"><link rel="prefetch" href="/wiki/assets/js/142.2c632914.js"><link rel="prefetch" href="/wiki/assets/js/143.221fdda9.js"><link rel="prefetch" href="/wiki/assets/js/144.71368723.js"><link rel="prefetch" href="/wiki/assets/js/145.7a0265cd.js"><link rel="prefetch" href="/wiki/assets/js/146.a0172065.js"><link rel="prefetch" href="/wiki/assets/js/147.681744ba.js"><link rel="prefetch" href="/wiki/assets/js/148.919e122d.js"><link rel="prefetch" href="/wiki/assets/js/149.a162fcf8.js"><link rel="prefetch" href="/wiki/assets/js/15.c937e7cc.js"><link rel="prefetch" href="/wiki/assets/js/150.82b5e1b4.js"><link rel="prefetch" href="/wiki/assets/js/151.6efb1f1d.js"><link rel="prefetch" href="/wiki/assets/js/152.1e4ed2be.js"><link rel="prefetch" href="/wiki/assets/js/153.b6fc8887.js"><link rel="prefetch" href="/wiki/assets/js/154.6595ba16.js"><link rel="prefetch" href="/wiki/assets/js/155.bd3efccb.js"><link rel="prefetch" href="/wiki/assets/js/156.a994fbb9.js"><link rel="prefetch" href="/wiki/assets/js/157.6635fef8.js"><link rel="prefetch" href="/wiki/assets/js/158.6a688585.js"><link rel="prefetch" href="/wiki/assets/js/16.84647c4f.js"><link rel="prefetch" href="/wiki/assets/js/160.0e573e26.js"><link rel="prefetch" href="/wiki/assets/js/161.4c6a596f.js"><link rel="prefetch" href="/wiki/assets/js/162.2091bd28.js"><link rel="prefetch" href="/wiki/assets/js/163.019c05d6.js"><link rel="prefetch" href="/wiki/assets/js/164.8e2f9b19.js"><link rel="prefetch" href="/wiki/assets/js/165.7ca6ad0b.js"><link rel="prefetch" href="/wiki/assets/js/166.991df56e.js"><link rel="prefetch" href="/wiki/assets/js/167.c7764fe4.js"><link rel="prefetch" href="/wiki/assets/js/168.a5e310c0.js"><link rel="prefetch" href="/wiki/assets/js/169.dd205edd.js"><link rel="prefetch" href="/wiki/assets/js/17.75f02ef7.js"><link rel="prefetch" href="/wiki/assets/js/170.8e2804f7.js"><link rel="prefetch" href="/wiki/assets/js/171.94f98167.js"><link rel="prefetch" href="/wiki/assets/js/172.1ed44a2f.js"><link rel="prefetch" href="/wiki/assets/js/173.4fe2cae2.js"><link rel="prefetch" href="/wiki/assets/js/174.62be12ca.js"><link rel="prefetch" href="/wiki/assets/js/175.07dbfc94.js"><link rel="prefetch" href="/wiki/assets/js/176.e6970774.js"><link rel="prefetch" href="/wiki/assets/js/177.8bde668b.js"><link rel="prefetch" href="/wiki/assets/js/178.e69ad32b.js"><link rel="prefetch" href="/wiki/assets/js/179.e652c237.js"><link rel="prefetch" href="/wiki/assets/js/18.61f60cd9.js"><link rel="prefetch" href="/wiki/assets/js/180.9829521d.js"><link rel="prefetch" href="/wiki/assets/js/181.9bf26f2f.js"><link rel="prefetch" href="/wiki/assets/js/182.707fe1c5.js"><link rel="prefetch" href="/wiki/assets/js/183.226afb9e.js"><link rel="prefetch" href="/wiki/assets/js/184.545099a8.js"><link rel="prefetch" href="/wiki/assets/js/185.a7810470.js"><link rel="prefetch" href="/wiki/assets/js/186.3a5a62a2.js"><link rel="prefetch" href="/wiki/assets/js/187.9e6841f8.js"><link rel="prefetch" href="/wiki/assets/js/188.8cc93f0c.js"><link rel="prefetch" href="/wiki/assets/js/189.565c8cf9.js"><link rel="prefetch" href="/wiki/assets/js/19.cd32b18f.js"><link rel="prefetch" href="/wiki/assets/js/190.a1b540d0.js"><link rel="prefetch" href="/wiki/assets/js/191.a042b524.js"><link rel="prefetch" href="/wiki/assets/js/192.f450653a.js"><link rel="prefetch" href="/wiki/assets/js/193.23da83d4.js"><link rel="prefetch" href="/wiki/assets/js/194.fcefe99a.js"><link rel="prefetch" href="/wiki/assets/js/195.d5b5ebe8.js"><link rel="prefetch" href="/wiki/assets/js/196.2d0a372e.js"><link rel="prefetch" href="/wiki/assets/js/197.cd8c6559.js"><link rel="prefetch" href="/wiki/assets/js/198.fbf9e54c.js"><link rel="prefetch" href="/wiki/assets/js/199.ac4b7834.js"><link rel="prefetch" href="/wiki/assets/js/20.2b975e85.js"><link rel="prefetch" href="/wiki/assets/js/200.0833dd73.js"><link rel="prefetch" href="/wiki/assets/js/201.57a76573.js"><link rel="prefetch" href="/wiki/assets/js/202.f656f85d.js"><link rel="prefetch" href="/wiki/assets/js/203.a7de0b33.js"><link rel="prefetch" href="/wiki/assets/js/204.c98ffe50.js"><link rel="prefetch" href="/wiki/assets/js/205.4234a5b6.js"><link rel="prefetch" href="/wiki/assets/js/206.7f7add00.js"><link rel="prefetch" href="/wiki/assets/js/207.0802de14.js"><link rel="prefetch" href="/wiki/assets/js/208.8fbe1262.js"><link rel="prefetch" href="/wiki/assets/js/209.8b37822f.js"><link rel="prefetch" href="/wiki/assets/js/21.cbabf94d.js"><link rel="prefetch" href="/wiki/assets/js/210.0b88f7a7.js"><link rel="prefetch" href="/wiki/assets/js/211.4fc7a4f1.js"><link rel="prefetch" href="/wiki/assets/js/212.cbe72b6c.js"><link rel="prefetch" href="/wiki/assets/js/213.c1b7da86.js"><link rel="prefetch" href="/wiki/assets/js/214.a4a31170.js"><link rel="prefetch" href="/wiki/assets/js/215.fae63edd.js"><link rel="prefetch" href="/wiki/assets/js/216.e6409b6c.js"><link rel="prefetch" href="/wiki/assets/js/217.0154fb51.js"><link rel="prefetch" href="/wiki/assets/js/218.edc304a9.js"><link rel="prefetch" href="/wiki/assets/js/219.7411f82d.js"><link rel="prefetch" href="/wiki/assets/js/22.ef199add.js"><link rel="prefetch" href="/wiki/assets/js/220.f68b9631.js"><link rel="prefetch" href="/wiki/assets/js/221.688e81e7.js"><link rel="prefetch" href="/wiki/assets/js/222.dc41f6dd.js"><link rel="prefetch" href="/wiki/assets/js/223.87f48544.js"><link rel="prefetch" href="/wiki/assets/js/224.c5fe9f5a.js"><link rel="prefetch" href="/wiki/assets/js/225.7c0ee38a.js"><link rel="prefetch" href="/wiki/assets/js/226.c7d6cab8.js"><link rel="prefetch" href="/wiki/assets/js/227.ee3db4e4.js"><link rel="prefetch" href="/wiki/assets/js/228.42e28a53.js"><link rel="prefetch" href="/wiki/assets/js/229.e9e05454.js"><link rel="prefetch" href="/wiki/assets/js/23.5d9133ee.js"><link rel="prefetch" href="/wiki/assets/js/230.933fe4af.js"><link rel="prefetch" href="/wiki/assets/js/231.6e7eac24.js"><link rel="prefetch" href="/wiki/assets/js/232.fec0968e.js"><link rel="prefetch" href="/wiki/assets/js/233.6e8eb4fe.js"><link rel="prefetch" href="/wiki/assets/js/234.82dcd8be.js"><link rel="prefetch" href="/wiki/assets/js/235.542bed81.js"><link rel="prefetch" href="/wiki/assets/js/236.a0467cf6.js"><link rel="prefetch" href="/wiki/assets/js/237.12d3f066.js"><link rel="prefetch" href="/wiki/assets/js/238.c2ee0138.js"><link rel="prefetch" href="/wiki/assets/js/239.1aa8fb6b.js"><link rel="prefetch" href="/wiki/assets/js/24.a7178450.js"><link rel="prefetch" href="/wiki/assets/js/240.49626970.js"><link rel="prefetch" href="/wiki/assets/js/241.0e6feb28.js"><link rel="prefetch" href="/wiki/assets/js/242.fac369bf.js"><link rel="prefetch" href="/wiki/assets/js/243.b875f9dd.js"><link rel="prefetch" href="/wiki/assets/js/244.f7ff6d5c.js"><link rel="prefetch" href="/wiki/assets/js/245.2cbb66d1.js"><link rel="prefetch" href="/wiki/assets/js/246.ca9d7502.js"><link rel="prefetch" href="/wiki/assets/js/247.06edd068.js"><link rel="prefetch" href="/wiki/assets/js/248.776f4ce6.js"><link rel="prefetch" href="/wiki/assets/js/249.272a92e7.js"><link rel="prefetch" href="/wiki/assets/js/25.d1429b5b.js"><link rel="prefetch" href="/wiki/assets/js/250.91c8b94c.js"><link rel="prefetch" href="/wiki/assets/js/251.992028fb.js"><link rel="prefetch" href="/wiki/assets/js/252.baf31c96.js"><link rel="prefetch" href="/wiki/assets/js/253.0bf2bf53.js"><link rel="prefetch" href="/wiki/assets/js/254.5d147ff2.js"><link rel="prefetch" href="/wiki/assets/js/255.e7bfeabf.js"><link rel="prefetch" href="/wiki/assets/js/256.b5052e95.js"><link rel="prefetch" href="/wiki/assets/js/257.b55f9045.js"><link rel="prefetch" href="/wiki/assets/js/258.8db574dc.js"><link rel="prefetch" href="/wiki/assets/js/259.8876e763.js"><link rel="prefetch" href="/wiki/assets/js/26.cfc326aa.js"><link rel="prefetch" href="/wiki/assets/js/260.19023910.js"><link rel="prefetch" href="/wiki/assets/js/261.f386cc76.js"><link rel="prefetch" href="/wiki/assets/js/262.90f3096f.js"><link rel="prefetch" href="/wiki/assets/js/263.87451b84.js"><link rel="prefetch" href="/wiki/assets/js/264.6810eb80.js"><link rel="prefetch" href="/wiki/assets/js/265.0573f486.js"><link rel="prefetch" href="/wiki/assets/js/266.486c2d56.js"><link rel="prefetch" href="/wiki/assets/js/267.e1acc572.js"><link rel="prefetch" href="/wiki/assets/js/268.22cf3951.js"><link rel="prefetch" href="/wiki/assets/js/269.5ab31b26.js"><link rel="prefetch" href="/wiki/assets/js/27.b64fa30f.js"><link rel="prefetch" href="/wiki/assets/js/270.5502dbbd.js"><link rel="prefetch" href="/wiki/assets/js/28.10470b22.js"><link rel="prefetch" href="/wiki/assets/js/29.b8beda58.js"><link rel="prefetch" href="/wiki/assets/js/3.c6da39c9.js"><link rel="prefetch" href="/wiki/assets/js/30.5070ceea.js"><link rel="prefetch" href="/wiki/assets/js/31.28a110d1.js"><link rel="prefetch" href="/wiki/assets/js/32.924a118b.js"><link rel="prefetch" href="/wiki/assets/js/33.fb56f9d3.js"><link rel="prefetch" href="/wiki/assets/js/34.cd9aeaa9.js"><link rel="prefetch" href="/wiki/assets/js/35.08072a5d.js"><link rel="prefetch" href="/wiki/assets/js/36.fb9bca02.js"><link rel="prefetch" href="/wiki/assets/js/37.229fbfce.js"><link rel="prefetch" href="/wiki/assets/js/38.528131f7.js"><link rel="prefetch" href="/wiki/assets/js/39.e29963cf.js"><link rel="prefetch" href="/wiki/assets/js/4.d15f9ece.js"><link rel="prefetch" href="/wiki/assets/js/40.a1461c3b.js"><link rel="prefetch" href="/wiki/assets/js/41.a7598892.js"><link rel="prefetch" href="/wiki/assets/js/42.f6b5631e.js"><link rel="prefetch" href="/wiki/assets/js/43.35d06df5.js"><link rel="prefetch" href="/wiki/assets/js/44.06947699.js"><link rel="prefetch" href="/wiki/assets/js/45.20496f7f.js"><link rel="prefetch" href="/wiki/assets/js/46.0d1d5b6e.js"><link rel="prefetch" href="/wiki/assets/js/47.fbd54982.js"><link rel="prefetch" href="/wiki/assets/js/48.c5b93e8c.js"><link rel="prefetch" href="/wiki/assets/js/49.0bb0eb76.js"><link rel="prefetch" href="/wiki/assets/js/5.1529c6e3.js"><link rel="prefetch" href="/wiki/assets/js/50.71d4d12d.js"><link rel="prefetch" href="/wiki/assets/js/51.3d0f892f.js"><link rel="prefetch" href="/wiki/assets/js/52.d627350e.js"><link rel="prefetch" href="/wiki/assets/js/53.689d9a27.js"><link rel="prefetch" href="/wiki/assets/js/54.96cfb15e.js"><link rel="prefetch" href="/wiki/assets/js/55.46fc2db3.js"><link rel="prefetch" href="/wiki/assets/js/56.64f4ed3e.js"><link rel="prefetch" href="/wiki/assets/js/57.530ef392.js"><link rel="prefetch" href="/wiki/assets/js/58.6e4804d4.js"><link rel="prefetch" href="/wiki/assets/js/59.a318a51a.js"><link rel="prefetch" href="/wiki/assets/js/6.8a166ea6.js"><link rel="prefetch" href="/wiki/assets/js/60.d65c58fb.js"><link rel="prefetch" href="/wiki/assets/js/61.3ca7a967.js"><link rel="prefetch" href="/wiki/assets/js/62.f6c29f13.js"><link rel="prefetch" href="/wiki/assets/js/63.4cfb2d58.js"><link rel="prefetch" href="/wiki/assets/js/64.fcd13993.js"><link rel="prefetch" href="/wiki/assets/js/65.7397ec62.js"><link rel="prefetch" href="/wiki/assets/js/66.a2937d69.js"><link rel="prefetch" href="/wiki/assets/js/67.e91c6071.js"><link rel="prefetch" href="/wiki/assets/js/68.c462f2bd.js"><link rel="prefetch" href="/wiki/assets/js/69.cd27811b.js"><link rel="prefetch" href="/wiki/assets/js/7.faba37bf.js"><link rel="prefetch" href="/wiki/assets/js/70.287500b6.js"><link rel="prefetch" href="/wiki/assets/js/71.3f5d602f.js"><link rel="prefetch" href="/wiki/assets/js/72.01caa54b.js"><link rel="prefetch" href="/wiki/assets/js/73.a3a12203.js"><link rel="prefetch" href="/wiki/assets/js/74.f59dca7f.js"><link rel="prefetch" href="/wiki/assets/js/75.a0c1fdd0.js"><link rel="prefetch" href="/wiki/assets/js/76.1f386680.js"><link rel="prefetch" href="/wiki/assets/js/77.8b3ddaac.js"><link rel="prefetch" href="/wiki/assets/js/78.9c8779cf.js"><link rel="prefetch" href="/wiki/assets/js/79.9b93dbb2.js"><link rel="prefetch" href="/wiki/assets/js/8.02087947.js"><link rel="prefetch" href="/wiki/assets/js/80.46f60083.js"><link rel="prefetch" href="/wiki/assets/js/81.55f01a3f.js"><link rel="prefetch" href="/wiki/assets/js/82.038644f5.js"><link rel="prefetch" href="/wiki/assets/js/83.3c6a0563.js"><link rel="prefetch" href="/wiki/assets/js/84.e9fce504.js"><link rel="prefetch" href="/wiki/assets/js/85.e4857d73.js"><link rel="prefetch" href="/wiki/assets/js/86.c61539d6.js"><link rel="prefetch" href="/wiki/assets/js/87.0103fb98.js"><link rel="prefetch" href="/wiki/assets/js/88.1a89ba3d.js"><link rel="prefetch" href="/wiki/assets/js/89.505e3a7a.js"><link rel="prefetch" href="/wiki/assets/js/9.f204efc6.js"><link rel="prefetch" href="/wiki/assets/js/90.0cf327f5.js"><link rel="prefetch" href="/wiki/assets/js/91.5c0d2d37.js"><link rel="prefetch" href="/wiki/assets/js/92.865f97ac.js"><link rel="prefetch" href="/wiki/assets/js/93.a71cedda.js"><link rel="prefetch" href="/wiki/assets/js/94.965fc22f.js"><link rel="prefetch" href="/wiki/assets/js/95.26160149.js"><link rel="prefetch" href="/wiki/assets/js/96.4f9bfe2d.js"><link rel="prefetch" href="/wiki/assets/js/97.dabf3e74.js"><link rel="prefetch" href="/wiki/assets/js/98.4263c604.js"><link rel="prefetch" href="/wiki/assets/js/99.3a9c5cee.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.28a8e502.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><!----> <span class="site-name">TIL wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/pravusid/TIL" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/pravusid/TIL" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>HTTP Basic</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/Network/http-basic.html#web과-network-기초" class="sidebar-link">Web과 Network 기초</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#웹은-http로-나타낸다" class="sidebar-link">웹은 HTTP로 나타낸다</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#http의-역사" class="sidebar-link">HTTP의 역사</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#웹의-성장" class="sidebar-link">웹의 성장</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#http의-정체" class="sidebar-link">HTTP의 정체</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#네트워크-tcp-ip" class="sidebar-link">네트워크: TCP/IP</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#dns" class="sidebar-link">DNS</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#uri와-url" class="sidebar-link">URI와 URL</a></li></ul></li><li><a href="/wiki/Network/http-basic.html#http-프로토콜의-구조" class="sidebar-link">HTTP 프로토콜의 구조</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#http는-상태를-유지하지-않는-프로토콜" class="sidebar-link">HTTP는 상태를 유지하지 않는 프로토콜</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#request-uri로-리소스-식별" class="sidebar-link">request URI로 리소스 식별</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#서버에-목적을-말하는-http-메소드" class="sidebar-link">서버에 목적을 말하는 HTTP 메소드</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#지속연결" class="sidebar-link">지속연결</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#쿠키를-사용한-상태관리" class="sidebar-link">쿠키를 사용한 상태관리</a></li></ul></li><li><a href="/wiki/Network/http-basic.html#http-메시지" class="sidebar-link">HTTP 메시지</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#리퀘스트-메시지와-리스폰스-메시지-구조" class="sidebar-link">리퀘스트 메시지와 리스폰스 메시지 구조</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#인코딩" class="sidebar-link">인코딩</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#레인지-리퀘스트" class="sidebar-link">레인지 리퀘스트</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#content-negotiation" class="sidebar-link">Content Negotiation</a></li></ul></li><li><a href="/wiki/Network/http-basic.html#http-상태-코드" class="sidebar-link">HTTP 상태 코드</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#request-결과" class="sidebar-link">Request 결과</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#_2xx-success" class="sidebar-link">2xx (Success)</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#_3xx-redirection" class="sidebar-link">3xx (Redirection)</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#_4xx-client-error" class="sidebar-link">4xx (Client Error)</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#_5xx-server-error" class="sidebar-link">5xx (Server Error)</a></li></ul></li><li><a href="/wiki/Network/http-basic.html#http-웹서버" class="sidebar-link">HTTP 웹서버</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#가상-호스트" class="sidebar-link">가상 호스트</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#프록시-게이트웨이-터널" class="sidebar-link">프록시, 게이트웨이, 터널</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#cache" class="sidebar-link">Cache</a></li></ul></li><li><a href="/wiki/Network/http-basic.html#http-header" class="sidebar-link">HTTP Header</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#http-메시지-헤더" class="sidebar-link">HTTP 메시지 헤더</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#http-헤더-필드" class="sidebar-link">HTTP 헤더 필드</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#이외의-헤더-필드" class="sidebar-link">이외의 헤더 필드</a></li></ul></li><li><a href="/wiki/Network/http-basic.html#https-프로토콜" class="sidebar-link">HTTPS 프로토콜</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#http의-약점" class="sidebar-link">HTTP의 약점</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#http-암호화-인증-완전성-https" class="sidebar-link">HTTP + 암호화 + 인증 + 완전성 = HTTPS</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#https-구조" class="sidebar-link">HTTPS 구조</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#https의-속도" class="sidebar-link">HTTPS의 속도</a></li></ul></li><li><a href="/wiki/Network/http-basic.html#인증" class="sidebar-link">인증</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#basic-인증" class="sidebar-link">BASIC 인증</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#digest-인증" class="sidebar-link">DIGEST 인증</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#ssl-클라이언트-인증" class="sidebar-link">SSL 클라이언트 인증</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#폼-베이스-인증" class="sidebar-link">폼 베이스 인증</a></li></ul></li><li><a href="/wiki/Network/http-basic.html#http의-추가-프로토콜" class="sidebar-link">HTTP의 추가 프로토콜</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#spdy" class="sidebar-link">SPDY</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#websocket" class="sidebar-link">WebSocket</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#webdav" class="sidebar-link">WebDAV</a></li></ul></li><li><a href="/wiki/Network/http-basic.html#웹-공격기술" class="sidebar-link">웹 공격기술</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#xss-cross-site-scripting" class="sidebar-link">XSS (Cross-Site Scripting)</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#sql-injection" class="sidebar-link">SQL Injection</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#os-command-injection" class="sidebar-link">OS Command Injection</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#http-header-injection" class="sidebar-link">HTTP Header Injection</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#mail-header-injection" class="sidebar-link">Mail Header Injection</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#directory-traversal" class="sidebar-link">Directory Traversal</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#remote-file-inclusion" class="sidebar-link">Remote File Inclusion</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#forced-browsing" class="sidebar-link">Forced Browsing</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#부적절한-에러-메시지-처리" class="sidebar-link">부적절한 에러 메시지 처리</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#open-redirect" class="sidebar-link">Open Redirect</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#session-hijack" class="sidebar-link">Session Hijack</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#session-fixation" class="sidebar-link">Session Fixation</a></li><li class="sidebar-sub-header"><a href="/wiki/Network/http-basic.html#cross-site-request-forgeries" class="sidebar-link">Cross-Site Request Forgeries</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http-basic"><a href="#http-basic" class="header-anchor">#</a> HTTP Basic</h1> <p>그림으로 배우는 HTTP network basic을 읽고 정리</p> <h2 id="web과-network-기초"><a href="#web과-network-기초" class="header-anchor">#</a> Web과 Network 기초</h2> <h3 id="웹은-http로-나타낸다"><a href="#웹은-http로-나타낸다" class="header-anchor">#</a> 웹은 HTTP로 나타낸다</h3> <p>웹브라우저(클라이언트)와 서버는 HyperText Transfer Protocol로 통신한다</p> <h3 id="http의-역사"><a href="#http의-역사" class="header-anchor">#</a> HTTP의 역사</h3> <p>1989년 3월 CERN에서 고안됨</p> <p>HyperText에 의해 상호 참조할 수 있는 World Wide Web을 구성하는 기술</p> <ul><li>HTML(HyperText Markup Language): 문서 기술 언어</li> <li>HTTP: 문서 전송 프로토콜</li> <li>URL(Uniform Resource Locator): 문서 주소 지정</li></ul> <h3 id="웹의-성장"><a href="#웹의-성장" class="header-anchor">#</a> 웹의 성장</h3> <ul><li>1993년 1월 NCSA에서 Mosaic 브라우저가 개발됨</li> <li>1994년 12월 넷스케이프 네비게이터 출시</li> <li>1995년 마이크로소프트 인터넷 익스플로러 출시</li> <li>이 무렵 웹서버 Apache 등장</li> <li>HTML 2.0 발행</li></ul> <h3 id="http의-정체"><a href="#http의-정체" class="header-anchor">#</a> HTTP의 정체</h3> <ul><li>HTTP/0.9: 1990년 정식사양 이전</li> <li>HTTP/1.0: 1996년 5월 정식사양 (RFC1945) 발행</li> <li>HTTP/1.1: 1997년 1월 공개되었고 현재 가장 많이 사용됨 (RFC2068 -&gt; RFC2616)</li> <li>HTTP/2.0: 차세대 버전, 현재 보급중</li></ul> <h3 id="네트워크-tcp-ip"><a href="#네트워크-tcp-ip" class="header-anchor">#</a> 네트워크: TCP/IP</h3> <h4 id="tcp-ip는-프로토콜의-집합"><a href="#tcp-ip는-프로토콜의-집합" class="header-anchor">#</a> TCP/IP는 프로토콜의 집합</h4> <p>컴퓨터와 네트워크 기기가 상호통신을 하기위해 규약이 있어야 함. 이를 프로토콜이라 한다.</p> <p>인터넷과 관련된 프로토콜을 모은것을 TCP/IP라고 한다.
TCP와 IP 프로토콜을 가리켜 TCP/IP라 부르기도 하지만,
IP 프로토콜을 사용한 통신에서 사용되고 있는 프로토콜을 총칭해서 TCP/IP라는 이름이 사용되고 있다.</p> <h4 id="tcp-ip의-계층"><a href="#tcp-ip의-계층" class="header-anchor">#</a> TCP/IP의 계층</h4> <p>TCP/IP는 애플리케이션 계층, 트랜스포트계층, 네트워크 계층, 링크 계층의 4계층으로 구성되어 있다.</p> <h5 id="애플리케이션-계층"><a href="#애플리케이션-계층" class="header-anchor">#</a> 애플리케이션 계층</h5> <p>애플리케이션 계층은 유저에게 제공되는 애플리케이션에서 사용하는 통신</p> <p>예를 들어 FTP, HTTP등이 해당됨</p> <h5 id="트랜스포트-계층"><a href="#트랜스포트-계층" class="header-anchor">#</a> 트랜스포트 계층</h5> <p>애플리케이션 계층에 네트워크로 접속되어 있는 컴퓨터사이 데이터 흐름을 제공함</p> <p>TCP(Transmission Control Protocol)와 UDP(User Data Protocol)의 두가지가 있음</p> <p>애플리케이션 계층에서 받은 데이터를 전송/수신하기 위해 변환함</p> <h5 id="네트워크-계층"><a href="#네트워크-계층" class="header-anchor">#</a> 네트워크 계층</h5> <p>네트워크 계층은 네트워크 상에서 패킷의 이동을 다룬다.</p> <p>수신지의 MAC 주소등을 통해 네트워크 기기간 길을 결정하는 것이 해당 계층의 역할이다.</p> <h5 id="링크-계층"><a href="#링크-계층" class="header-anchor">#</a> 링크 계층</h5> <p>네트워크에 접속하는 하드웨어적인 면을 다룬다.</p> <p>운영체제가 하드웨어를 제어하므로, 디바이스 드라이버, 네트워크 인터페이스카드(NIC)를 포함한다.
또한 케이블 및 커텍트와 같은 물리적인 영역 또한 포함한다.</p> <h4 id="tcp-ip-통신의-흐름"><a href="#tcp-ip-통신의-흐름" class="header-anchor">#</a> TCP/IP 통신의 흐름</h4> <p>TCP/IP로 통신할 때 계층을 순서대로 거쳐 상대와 통신한다.
송신과 수신에서 거쳐가는 계층은 역순이다.</p> <p>클라이언트</p> <ol><li>애플리케이션: HTTP 클라이언트 (HTTP 데이터)</li> <li>트랜스포트: TCP (+ TCP 헤더)</li> <li>네트워크: IP (+ IP 헤더)</li> <li>링크: 네트워크 (+ Ethernet 헤더)</li></ol> <p>서버</p> <ol><li>링크: 네트워크 (- Ethernet 헤더)</li> <li>네트워크: IP (- IP 헤더)</li> <li>트랜스포트: TCP (- TCP 헤더)</li> <li>애플리케이션: HTTP 서버 (HTTP 데이터)</li></ol> <h4 id="ip"><a href="#ip" class="header-anchor">#</a> IP</h4> <p>Internet Protocol은 네트워크 계층이다.</p> <p>IP 프로토콜은 다음의 정보로 개개의 패킷을 상대방에게 전달한다</p> <ul><li>IP주소 : 각 노드에 부여된 주소</li> <li>MAC주소: 네트워크 카드에 할당된 고유주소</li></ul> <p>IP 통신은 MAC주소에 의존해서 통신을 한다.
보통 네트워크간 중계를 통해 상대에게 도착하게 되는데 이때 ARP(Address Resolution Protocol) 프로토콜이 사용된다.</p> <p>ARP 프로토콜은 수신지의 IP주소를 바탕으로 MAC주소를 조사할 수 있다.</p> <p>목적지까지 중계 하는 도중 네트워크 기기는 대략의 목적지만 알고 전송되는데 이를 라우팅이라 한다.</p> <h4 id="tcp"><a href="#tcp" class="header-anchor">#</a> TCP</h4> <p>TCP는 트랜스포트 계층에 해당되는데, 신뢰성 있는 바이트 스트림 서비스를 제공한다.</p> <p>TCP는 용량이 큰 데이터를 TCP 세그먼트라 불리는 단위패킷으로 분해하여 관리하고, 도착여부의 정확성을 확인한다.</p> <p>TCP에서 상대에게 확실하게 데이터를 보내기 위해서 Three way handshaking 이라는 방법을 사용한다.
이는 패킷을 보내고 바로 끝내지 않고, 전송여부 확인을 위해 'SYN'과 'ACK'라는 TCP 플래그를 사용하는 것이다.</p> <ul><li>송신측에서 최초 SYN 플래그로 상대에게 접속함과 동시에 패킷을 보냄</li> <li>수신측에서 SYN/ACK 플래그로 송신측에 접속함과 동시에 패킷을 수신한 사실을 보냄</li> <li>송신측이 ACK 플래그를 보내 패킷 교환이 완료되었음을 알림</li> <li>통신이 끊어지면 같은 과정을 반복하며 패킷을 재전송한다</li></ul> <p>이외에도 신뢰성을 보증하기 위한 다양한 시스템이 있다</p> <h3 id="dns"><a href="#dns" class="header-anchor">#</a> DNS</h3> <p>DNS(Domain Name System)는 HTTP 같은 응용 계층 시스템에서 도메인 이름과 IP 주소 이름확인을 제공한다.</p> <h3 id="uri와-url"><a href="#uri와-url" class="header-anchor">#</a> URI와 URL</h3> <p>URI(Uniform Resource Identifier)</p> <ul><li>Uniform: 통일된 서식으로 여러 종류의 리소스 지정방법을 동일 맥락에서 구분</li> <li>Resource: 리소스는 식별 가능한 모든것이다.</li> <li>Identifier: 식별가능한 것을 참조하는 오브젝트</li></ul> <p>URI는 리소스를 식별하기 위한 문자열 전반을 나타내는데, URL은 리소스의 네트워크상 위치를 나타낸다.
즉, URL은 URI의 subset이다.</p> <p>절대 URI(필요 정보 전체를 지정) 포맷</p> <ul><li>스키마: <code>http://</code></li> <li>자격정보(옵션): <code>user:pass@</code></li> <li>서버주소: <code>www.example.com</code></li> <li>서버포트(기본 80): <code>:80</code></li> <li>계층적 경로: <code>/dir/index</code></li> <li>쿼리 문자열: <code>?id=1</code></li> <li>프래그먼트 식별자: <code>#ch1</code></li></ul> <h2 id="http-프로토콜의-구조"><a href="#http-프로토콜의-구조" class="header-anchor">#</a> HTTP 프로토콜의 구조</h2> <p>HTTP는 클라이언트와 서버 간에 통신을 한다</p> <p>HTTP는 클라이언트로부터 Request가 송신되며 그 결과 서버로부터 Response가 돌아온다.
반드시 클라이언트측으로 부터 통신이 시작된다.</p> <h3 id="http는-상태를-유지하지-않는-프로토콜"><a href="#http는-상태를-유지하지-않는-프로토콜" class="header-anchor">#</a> HTTP는 상태를 유지하지 않는 프로토콜</h3> <p>HTTP는 상태를 계속 유지하지 않는 stateless 프로토콜이다.</p> <p>HTTP에서는 새로운 request가 보내질 때마다 새로운 response가 생성된다.
프로토콜로서 과거의 request나 response 정보를 전혀 가지고 있지 않다.</p> <p>이는 많은 데이터를 빠르고 확실허게 처리하기 위한 scalability를 확보하기 위해 간단히 설계되어 있는 것이다.</p> <p>그러나 stateless 특징으로 처리하기 어려운 일이 증가하였다.</p> <p>HTTP/1.1은 여전히 stateless이지만 Cookie라는 기술이 도입되었다.</p> <h3 id="request-uri로-리소스-식별"><a href="#request-uri로-리소스-식별" class="header-anchor">#</a> request URI로 리소스 식별</h3> <p>HTTP는 URI를 사용하여 인터넷상의 리소스를 지정한다.</p> <p>클라이언트는 리소스를 호출할 때 마다 request를 송샌할 때에 request URI를 포함해야 한다.</p> <ul><li>모든 URI를 request URI에 포함: <code>GET http://google.com/index HTTP/1.1</code></li> <li>Host 헤더 필드에 네트워크 로케이션 포함: <code>GET /index HTTP/1.1 Host:google.com</code></li></ul> <p>특정 리소스가 아닌 서버 자신에게 request를 송신하는 경우 <code>*</code> 지정 가능</p> <p>HTTP 서버가 지원하는 메소드 확인: <code>OPTIONS * HTTP/1.1</code></p> <h3 id="서버에-목적을-말하는-http-메소드"><a href="#서버에-목적을-말하는-http-메소드" class="header-anchor">#</a> 서버에 목적을 말하는 HTTP 메소드</h3> <ul><li>GET 메소드: request URI로 식별된 리소스를 가져올 수 있도록 요구함</li> <li>POST 메소드: 엔티티를 전송하기 위해서 사용됨</li> <li>PUT 메소드: request중 포함된 엔티티를 request URI로 지정한 곳에 보존하도록 요구함 (파일 전송)</li> <li>HEAD 메소드: GET과 같은 기능이지만 body는 돌려주지 않는다. URI 유효성과 리소스 갱신시간 확인등의 목적으로 쓰임</li> <li>DELETE 메소드: 파일을 삭제하기 위해서 사용됨(PUT 메소드와 반대)</li> <li>OPTIONS 메소드: request URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용</li> <li>TRACE 메소드: Web 서버에 접속해서 자신에게 통신을 되돌려 받는 loop-back을 발생시킨다. (XST등의 문제로 보통사용되지 않음)</li> <li>CONNECT 메소드: 프록시에 터널 접속 확립을 요구하여 TCP 통신을 터널링 시키기 위해 사용됨</li></ul> <h3 id="지속연결"><a href="#지속연결" class="header-anchor">#</a> 지속연결</h3> <p>HTTP 초기버전에서는 매 통신마다 TCP에 의해 연결과 종료를 해야 할 필요가 있었다.</p> <p>HTTP/1.1과 일부의 HTTP/1.0에서는 이러한 문제를 해결하기 위해 Persistent Connection이라는 방법을 고안하였다.
이 경우 어느 한쪽에서 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 유지한다.</p> <p>지속 연결은 여러 request를 보낼 수 있다록 HTTP pipelining을 가능하게 한다.</p> <p>파이프라인화로 request 송신 후에 response를 수신할 때까지 대기하지 않고, 다음 request를 보낼수 있다.</p> <h3 id="쿠키를-사용한-상태관리"><a href="#쿠키를-사용한-상태관리" class="header-anchor">#</a> 쿠키를 사용한 상태관리</h3> <p>HTTP는 stateless 프로토콜이므로 과거 상태를 관리하지 못하는 단점이 존재한다.
이를 해결하기 위해 쿠키라는 시스템이 도입되었다.</p> <p>쿠키는 서버에서 response로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 된다.
다음번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신한다.</p> <p>서버는 클라이언트가 보내온 쿠키로 클라이언트를 식별하고 서버상의 기록을 확인할 수 있다.</p> <p>쿠키를 가지고 있지 않은 상태의 request</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>GET /reader HTTP/1.1
Host: www.google.com
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>서버가 쿠키를 발행한 response</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>HTTP/1.1 200 OK
Date: Thu, 12 Jul 2012 07:12:20 GMT
Server: Apache
&amp;lt;Set-Cookie: sid=1342077140226742; path=/;expires=Wed, =&gt; 10-Oct-12 07:12:20 GMT&gt;
Content-Type: text/plain; charset=UTF-8
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>클라이언트가 보관하던 쿠키를 포함한 request</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>GET /image HTTP/1.1
Host: www.google.com
Cookie: sid=1342077140226742
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="http-메시지"><a href="#http-메시지" class="header-anchor">#</a> HTTP 메시지</h2> <p>HTTP에서 교환하는 정보는 HTTP 메시지라고 하는데 request 메시지와 response 메시지로 나뉜다</p> <h3 id="리퀘스트-메시지와-리스폰스-메시지-구조"><a href="#리퀘스트-메시지와-리스폰스-메시지-구조" class="header-anchor">#</a> 리퀘스트 메시지와 리스폰스 메시지 구조</h3> <ul><li><p>메시지 헤더</p> <ul><li>리퀘스트 라인: 리퀘스트에 사용하는 메소드와 리퀘스트 URI, HTTP 버전 포함</li> <li>상태 라인: 리스폰스 결과를 나타내는 상태코드와 설명, HTTP 버전 포함</li> <li>헤더 필드: 리퀘스트와 리스폰스의 여러 조건과 속성들을 나타내는 각종 헤더필드 포함
<ul><li>일반 헤더필드</li> <li>리퀘스트 헤더 필드</li> <li>리스폰스 헤더 필드</li> <li>엔티티 헤더 필드</li></ul></li> <li>그 외: HTTP의 RFC에 없는 헤더 필드 (쿠키 ...)가 포함</li></ul></li> <li><p>개행 문자(CR + LF)</p></li> <li><p>메시지 바디: 전송되는 데이터 (반드시 존재하지는 않음)</p></li></ul> <h3 id="인코딩"><a href="#인코딩" class="header-anchor">#</a> 인코딩</h3> <p>HTTP로 데이터를 전송할 경우 인코딩을 통해 전송 효율을 높일 수도 있다.
단, 인코딩 처리를 해야하므로 CPU 등의 리소스는 보다 많이 소비하게 된다.</p> <h4 id="메시지-바디와-엔티티-바디"><a href="#메시지-바디와-엔티티-바디" class="header-anchor">#</a> 메시지 바디와 엔티티 바디</h4> <p>메시지: HTTP 통신의 기본 단위로 Octet(8bit) Sequence로 구성된다</p> <p>엔티티: 리퀘스트와 리스폰스의 payload로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성됨</p> <p>HTTP 메시지 바디의 역할은 리퀘스트/리스폰스에 관한 엔티티 바디를 운반하는 것.
기본적으로 메시지 바디와 엔티티 바디는 같지만 전송코딩이 적용된 경우에는 달라진다.</p> <h4 id="contents-coding"><a href="#contents-coding" class="header-anchor">#</a> Contents Coding</h4> <p>Contents Codings는 엔티티에 적용하는 인코딩인데, 엔티티 정보를 유지한 채로 압축한다.</p> <p>다음과 같은 콘텐츠 압축이 있다</p> <ul><li>gzip(GNU zip)</li> <li>compress(UNIX 표준 압축)</li> <li>deflate(zlib)</li> <li>identity(인코딩 없음)</li></ul> <h4 id="chunked-transfer-coding"><a href="#chunked-transfer-coding" class="header-anchor">#</a> Chunked Transfer Coding</h4> <p>큰 데이터를 전송하는 경우 데이터를 분할할 수 있는데, 엔티티 바디를 분할하는 기능을 청크 전송 코딩이라 한다.
이 경우 다음 청크 사이즈를 16진수를 사용해 단락을 표시하고 바디 끝에 CR+LF를 기록한다.</p> <h4 id="multipart"><a href="#multipart" class="header-anchor">#</a> Multipart</h4> <p>MIME(Multipurpose Internet Mail Extension)는 메일로 텍스트, 영상, 이미지 같은 다른 데이터를 다루기 위한 기능이다.</p> <p>MIME는 이미지 등의 바이너리 데이터를 ASCII 문자열에 인코딩하는 방법, 데이터 종류를 나타내는 방법등을 규정한다.</p> <p>MIME의 타입인 Multipart는 하나의 메시지 바디 내부에 엔티티를 어러개 포함시켜 보낸다.</p> <p>HTTP 메시지로 multipart를 사용할 때는 Content-Type 헤더 필드를 사용한다.
멀티파트 각각의 엔티티를 구분하기 위해 &quot;boundary&quot; 문자열을 사용하고 앞에는 <code>--</code>를 삽입한다.</p> <p>멀티파트는 파트마다 헤더필드가 포함된다. 또한 파트 중간에 파트를 내부에 포함할 수도 있다.</p> <h5 id="multipart-form-data"><a href="#multipart-form-data" class="header-anchor">#</a> multipart/form-data</h5> <p>Web의 Form으로 부터 파일 업로드에 사용됨
(user types &quot;Joe Blow&quot; in the name field)</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name=&quot;field1&quot;

Joe Blow
---AaB03x
Content-Disposition: form-data; name=&quot;pics&quot;; filename=&quot;file1.txt&quot;
Content-Type: text/plain

...(file1.txt 데이터)...
--AaB03x
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h5 id="multipart-byteranges"><a href="#multipart-byteranges" class="header-anchor">#</a> multipart/byteranges</h5> <p>상태코드 206(Partial Content) response message가 복수 범위의 내용을 포함하는 때 사용</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>HTTP/1.1 206 Partial Content
Date: Fri, 13 Jul 2012 02:45:26 GMT
Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT
Content-Type: multipart/byteranges: boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES

Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...(범위내의 데이터)...
--THIS_STRING_SEPARATES

Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...(범위내의 데이터)...
--THIS_STRING_SEPARATES
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="레인지-리퀘스트"><a href="#레인지-리퀘스트" class="header-anchor">#</a> 레인지 리퀘스트</h3> <p>엔티티의 범위를 지정해서 요청을 보내는 것을 Range Request라 한다.
Range Header Field를 사용해서 리소스 레인지를 지정한다.</p> <p><code>Range: bytes = -3000, 5001-10000</code>: 처음부터 3000바이트 까지, 그리고 5001 ~ 10000 바이트</p> <ul><li>Range Request에 대한 Response는 상태코드 206(Partial Content)이 돌아온다.</li> <li>복수 범위의 Range Request에 대해서는 <code>multipart/byteranges</code> response가 돌아온다.</li> <li>서버가 range request를 지원하지 않으면 완전한 엔티티와 함께 상태코드 200이 돌아온다</li></ul> <h3 id="content-negotiation"><a href="#content-negotiation" class="header-anchor">#</a> Content Negotiation</h3> <p>Content Negotiation은 클라이언트와 서버가 제공하는 리소스를 언어와 문자세트, 인코딩 방식을 기준으로 구분한다.</p> <p>판단기준은 다음과 같은 헤더필드 내용에 근거한다.</p> <ul><li>Accept</li> <li>Accept-Charset</li> <li>Accept-Encoding</li> <li>Accept-Language</li> <li>Content-Language</li></ul> <p>Content Negotiation의 종류는 다음이 있다.</p> <ul><li>Server-driven Negotiation: 서버측에서 리퀘스트 헤더필드의 내용을 참고해서 처리함</li> <li>Agent-driven Negotiation: 클라이언트 측에서 처리, OS 종류, 브라우저 종류, User Agent에 따라 전환하는 것등이 포함됨</li> <li>Transparent Negotiation: 서버와 에이전트 방식을 혼합한 것, 각각 Negotiation을 한다</li></ul> <h2 id="http-상태-코드"><a href="#http-상태-코드" class="header-anchor">#</a> HTTP 상태 코드</h2> <h3 id="request-결과"><a href="#request-결과" class="header-anchor">#</a> Request 결과</h3> <p>클라이언트로부터 서버로 리퀘스트를 보낼 때 서버에서 처리된 상태를 알려주는 것이 상태코드이다.</p> <p>리스폰스 클래스는 5개가 정의되어 있다</p> <ul><li>1xx (Informational): 리퀘스트를 받아 처리중</li> <li>2xx (Success): 리퀘스트를 정상적으로 처리함</li> <li>3xx (Redirection): 리퀘스트 완료를 위해 추가 동작 필요</li> <li>4xx (Client Error): 클랄이언트 원인으로 서버에서 리퀘스트 이해 불능</li> <li>5xx (Server Error): 서버에서 리퀘스트 처리 실패</li></ul> <h3 id="_2xx-success"><a href="#_2xx-success" class="header-anchor">#</a> 2xx (Success)</h3> <ul><li>200 OK: 클라이언트가 보낸 리퀘스트를 서버가 정상 처리했을 경우, HTTP 메소드에 따라 되돌아오는 데이터는 다르다</li> <li>204 No Content: 리스폰스에 entity body를 포함하지 않는 경우</li> <li>206 Partial Content: Range가 지정된 리퀘스트에 의해서 Content-Range로 지정된 범위의 엔티티가 포함</li></ul> <h3 id="_3xx-redirection"><a href="#_3xx-redirection" class="header-anchor">#</a> 3xx (Redirection)</h3> <ul><li>301 Moved Permanently: 요청된 리소스에 새로운 URI가 부여되어, 이후로 변경된 URI를 사용해야 함을 리스폰스한다</li> <li>302 Found: 요청된 리소스에 새로운 URI가 부여되어 있지만, 301과 다르게 일시적인 변경이다</li> <li>303 See Other: 요청된 리소스는 다른 URI이므로 GET 메소드를 통해 얻어야 함을 나타낸다</li> <li>304 Not Modified: 조건부 리퀘스트에서 접근은 가능하나 조건을 만족하지 않는 경우이다. 비어있는 리스폰스 바디를 반환한다.</li> <li>307 Temporary Redirect: 302 Found와 동일하다</li></ul> <p>301, 302, 303 리스폰스 코드가 오면 대부분의 브라우저는 POST를 GET으로 변경하고 엔티티 바디를 삭제하여 리퀘스트를 재송신한다.
303 코드에서 GET 메소드를 사용할 것을 명시하고 있으나 다른코드에서도 그런 방식으로 작동한다.</p> <h3 id="_4xx-client-error"><a href="#_4xx-client-error" class="header-anchor">#</a> 4xx (Client Error)</h3> <ul><li>400 Bad Request: 리퀘스트 구문이 잘못되었음을 나타낸다</li> <li>401 Unauthorized: 송신한 리퀘스트에 HTTP 인증이 필요하다는 것을 나타낸다(첫 번째), 인증에 실패했음을 표시한다(두 번째)</li> <li>403 Forbidden: 요청한 리소스의 접근이 거부되었음을 나타낸다. 거부된 이유를 엔티티 바디에 포함해 반환할 수 있다.</li> <li>404 Not Found: 요청한 리소스가 서버상에 없다는 것을 나타낸다. (혹은 이유 없이 거부할 때)</li></ul> <h3 id="_5xx-server-error"><a href="#_5xx-server-error" class="header-anchor">#</a> 5xx (Server Error)</h3> <ul><li>500 Internal Server Error: 서버에서 요청을 처리하는 도중 에러가 발생한 경우</li> <li>503 Service Unavailable: 일시적으로 서버를 사용할 수 없어 리퀘스트가 처리되지 않는 경우. Retry-After 헤더필드 값을 반환할 수 있다.</li></ul> <h2 id="http-웹서버"><a href="#http-웹서버" class="header-anchor">#</a> HTTP 웹서버</h2> <h3 id="가상-호스트"><a href="#가상-호스트" class="header-anchor">#</a> 가상 호스트</h3> <p>HTTP/1.1에서는 하나의 HTTP 서버에 여러개의 웹사이트를 실행할 수 있다.</p> <p>같은 IP 주소에서 다른 호스트/도메인명을 가진 여러개의 웹사이트가 실행되는 가상호스트 시스템이 있으므로,
HTTP 리퀘스트를 보내는 경우 호스트/도메인명을 완전히 포함한 URI를 지정하거나, Host 헤더필드에서 지정해야 한다.</p> <h3 id="프록시-게이트웨이-터널"><a href="#프록시-게이트웨이-터널" class="header-anchor">#</a> 프록시, 게이트웨이, 터널</h3> <h4 id="프록시"><a href="#프록시" class="header-anchor">#</a> 프록시</h4> <p>프록시 서버는 클라이언트로부터 받은 리퀘스트 URI를 변경하지 않고 다음 리소스를 가지고 있는 서버에 보낸다.</p> <p>실제로 리소스를 가진 서버를 Origin Server라고 한다.
오리진 서버로부터 돌아온 리스폰스는 프록시 서버를 경유하여 클라이언트로 돌아간다.</p> <p>HTTP 통신에서는 여러대의 프록시 서버를 경유하는 것도 가능하다.
프록시 서버를 통해 리퀘스트와 리스폰스를 중계할 때는 Via 헤더 필드에 경유한 호스트 정보를 추가해야 한다.</p> <h5 id="cashing-proxy"><a href="#cashing-proxy" class="header-anchor">#</a> Cashing Proxy</h5> <p>프록시에 같은 리소스에 대한 요청이 온 경우 오리진 서버로부터 리소스를 획득하지 않고, 캐시를 리스폰스로 되돌려 줄 수 있다.</p> <h5 id="transparent-proxy"><a href="#transparent-proxy" class="header-anchor">#</a> Transparent Proxy</h5> <p>리퀘스트와 리스폰스를 중계할 때 메시지 변경을 하지않는 프록시를 투명 프록시라한다.</p> <p>반대로 메시지에 변경을 가하는 프록시를 비투과 프록시라고 한다.</p> <h4 id="게이트웨이"><a href="#게이트웨이" class="header-anchor">#</a> 게이트웨이</h4> <p>게이트웨이는 프록시와 유사하지만 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 경우이다.</p> <h4 id="터널"><a href="#터널" class="header-anchor">#</a> 터널</h4> <p>더널은 다른 서버와의 통신경로를 확립한다. 이 때 HTTP 리퀘스트를 해석하지 않고 다음서버로 중계한다.</p> <h3 id="cache"><a href="#cache" class="header-anchor">#</a> Cache</h3> <p>캐시는 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스 사본을 가리킨다.
캐시를 사용하면 통신량과 통신시간을 효율적으로 관리할 수 있다.</p> <p>캐시 서버는 프록시 서버의 하나로 캐싱 프록시로 분류된다.</p> <h4 id="캐시-유효기간"><a href="#캐시-유효기간" class="header-anchor">#</a> 캐시 유효기간</h4> <p>오리진 서버의 리소스가 갱신되는 경우 캐시는 유효하지 않게 된다.</p> <p>따라서 캐시를 활용하더라도 클라이언트의 요구나 캐시 유효기간등에 의해
오리진 서버에 유효성을 확인하거나 새로운 리소스를 획득하는 경우가 있다.</p> <h4 id="클라이언트-캐시"><a href="#클라이언트-캐시" class="header-anchor">#</a> 클라이언트 캐시</h4> <p>클라이언트 측의 웹 브라우저 역시 캐시를 가지고 있을 수 있다.
마찬가지로 캐시 유효성에 의해 다시 데이터를 획득하러 갈 수도 있다.</p> <h2 id="http-header"><a href="#http-header" class="header-anchor">#</a> HTTP Header</h2> <h3 id="http-메시지-헤더"><a href="#http-메시지-헤더" class="header-anchor">#</a> HTTP 메시지 헤더</h3> <p>HTTP 리퀘스트와 리스폰스에는 반드시 메시지 헤더가 포함되어 있다.</p> <h4 id="리퀘스트-http-메시지"><a href="#리퀘스트-http-메시지" class="header-anchor">#</a> 리퀘스트 HTTP 메시지</h4> <p>메시지 헤더는 메소드, URI, HTTP 버전, HTTP 헤더필드 등으로 구성되어 있다.</p> <h4 id="리스폰스-http-메시지"><a href="#리스폰스-http-메시지" class="header-anchor">#</a> 리스폰스 HTTP 메시지</h4> <p>메시지 헤더는 HTTP버전, 상태코드, HTTP 헤더필드 등으로 구성되어 있다.</p> <h3 id="http-헤더-필드"><a href="#http-헤더-필드" class="header-anchor">#</a> HTTP 헤더 필드</h3> <p>HTTP 헤더 필드: <code>헤더필드명:헤더필드값</code></p> <p>하나의 헤더 필드가 여러 개의 필드 값을 가질 수 있으며 쉽표 <code>,</code>로 구분한다</p> <h4 id="헤더-필드의-종류"><a href="#헤더-필드의-종류" class="header-anchor">#</a> 헤더 필드의 종류</h4> <ul><li>General Header Fields: 리퀘스트/리스폰스 메시지 두 곳다 사용됨</li> <li>Request Header Fields: 클라이언트에서 서버 방향, 리퀘스트 부가정보, 클라이언트 정보, 리스폰스 콘텐츠에 관한 우선순위 등...</li> <li>Response Header Fields: 서버에서 클라이언트 방향, 리스폰스 정보와 서버 정보, 클라이언트의 추가 정보 요구 등...</li> <li>Entity Header Fields: 리퀘스트/리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠 갱신 시간 등에 관한 정보를 부가</li></ul> <h4 id="e2e-헤더와-hop-by-hop-헤더"><a href="#e2e-헤더와-hop-by-hop-헤더" class="header-anchor">#</a> E2E 헤더와 Hop-by-hop 헤더</h4> <p>HTTP 헤더 필드는 캐시와 비캐시 프록시의 동작을 정의하기 위해서 두 가지 카테고리로 분류되어 있다.</p> <h5 id="e2e-헤더"><a href="#e2e-헤더" class="header-anchor">#</a> E2E 헤더</h5> <p>E2E 분류 헤더는 리퀘스트나 리스폰스의 최종 수신자에게 전송된다.</p> <h5 id="hop-by-hop-헤더"><a href="#hop-by-hop-헤더" class="header-anchor">#</a> Hop-by-hop 헤더</h5> <p>이 카테고리의 헤더는 한 번 전송에 대해서만 유효하고 캐시와 프록시에를 통하면 전송되지 않는 것도 있다.</p> <p>사용되는 Hop-by-hop 헤더는 Connection 헤더 필드에 열거해야 한다.</p> <p>HTTP/1.1의 Hop-by-hop 헤더에는 다음과 같은 것이 있다.
다음 8개의 헤더필드 이외에는 모두 E2E 헤더로 분류된다.</p> <ul><li>Connection</li> <li>Keep-Alive</li> <li>Proxy-Authenticate</li> <li>Proxy-Authorization</li> <li>Trailer</li> <li>TE</li> <li>Transfer-Encoding</li> <li>Upgrade</li></ul> <h4 id="general-header-fields"><a href="#general-header-fields" class="header-anchor">#</a> General Header Fields</h4> <h5 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-Control</h5> <ul><li><p>디렉티브로 불리는 명령을 사용하여 캐싱동작 지정</p></li> <li><p>디렉티브는 파리미터가 있을 수도/없을 수도 있으며, 여러개를 지정하는 경우 <code>,</code>로 구분</p></li> <li><p>캐시 리퀘스트 디렉티브 (디렉티브/파라미터/설명)</p> <ul><li><code>no-cache</code>: orogin 서버에 강제적 재검증</li> <li><code>no-store</code>: 캐시는 리퀘스트/리스폰스의 일부분을 보존하면 안됨</li> <li><code>max-age=초</code>: 필수: 리스폰스 최대 보존시간, <code>Expires</code>헤더보다 우선함</li> <li><code>max-state=[초]</code>: 생략가능: 기한이 지난 리스폰스 수신, 최대 혀용기간 지정 가능</li> <li><code>min-fresh=초</code>: 필수: 지정한 시간 이상의 유효기간이 남은 리소스를 요청함</li> <li><code>no-transform</code>: 프록시 캐시는 엔티티 바디의 미디어 타입을 변경해서는 안됨</li> <li><code>only-if-cached</code>: 목적 리소스가 로컬 캐시에 있는 경우에만 리스폰스를 반환하도록 요구함</li></ul></li> <li><p>캐시 리스폰스 디렉티브 (디렉티브/파라미터/설명)</p> <ul><li><code>public</code>: 유저에게 돌려줄 수 있는 리스폰스 캐시 가능</li> <li><code>private</code>: 생략가능: 특정 유저에 대해서만 리스폰스 (public과 반대)</li> <li><code>no-cache</code>: 생략가능: origin 서버에 유효성 재확인 없이 캐시 사용불가, 파라미터로 캐시할 수 없는 헤더필드를 명시할 수 있음</li> <li><code>no-store</code>: 캐시는 리퀘스트/리스폰스 일부분을 보존하면 안됨</li> <li><code>no-transform</code>: 프록시는 미디어 타입을 변경해서는 안됨</li> <li><code>must-revalidate</code>: 캐시 가능하지만 오리진 서버에 리소스 재확인 요구, 리퀘스트의 <code>max-state</code> 헤더를 무시함</li> <li><code>proxy-revalidate</code>: 모든 캐시서버에 대해 이후의 리퀘스트로 리스폰스를 반환할 때 반드시 유효성 재확인 요구</li> <li><code>max-age=초</code>: 필수: 리스폰스 최대 보존시간, <code>Expires</code>헤더보다 우선함</li> <li><code>s-max-age=초</code>: 필수: 여러 유저가 이용하는 공유 캐시 서버 리스폰스 최대 보존시간 (이경우 <code>Expires</code>와 <code>max-age</code>는 무시됨)</li></ul></li> <li><p>확장 토큰: <code>cache-extension</code>: 디렉티브를 해석할 수 있는 서버로 보낼경우만 유효</p></li></ul> <h5 id="connection"><a href="#connection" class="header-anchor">#</a> Connection</h5> <ul><li><p>프록시에 더 이상 전송하지 않는 헤더필드(Hop-by-hop 헤더) 지정</p></li> <li><p>지속적 접속(Keep-alive) 관리</p> <ul><li>HTTP/1.1에서는 Keep-alive가 디폴트임</li> <li>서버에서 명시적으로 접속을 끊고 싶을 때 <code>Connection</code>헤더 필드에 <code>Close</code>를 지정함</li></ul></li></ul> <h5 id="date"><a href="#date" class="header-anchor">#</a> Date</h5> <p>메시지 생성 날짜를 표기하며, HTTP/1.1의 날짜 포맷은 RFC1123에 지정되어 있음</p> <p><code>Date: Tue, 03 Jul 2012 04:40:59 GMT</code></p> <h5 id="pragma"><a href="#pragma" class="header-anchor">#</a> Pragma</h5> <p>Pragma 필드는 HTTP/1.0과의 호환을 위해서만 정의되어 있음</p> <p><code>Pragma: no-cache</code>만 사용 가능하며 클라이언트 리퀘스트에서만 사용한다.
중간 서버들에 캐시된 리소스의 리스폰스가 필요없음을 알린다.</p> <h5 id="trailer"><a href="#trailer" class="header-anchor">#</a> Trailer</h5> <p>HTTP/1.1에 구현되어있는 청크 전송 인코딩을 사용하고 있는 경우,
메시지 바디 뒤에 기술되어 있는 헤더 필드를 미리 전달할 수 있다.</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>...
Trailer: Expires
...
... 메시지 바디 ...
0
Expires: Tue, 28 Sep 2004 23:59:59 GMT
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="transfer-encoding"><a href="#transfer-encoding" class="header-anchor">#</a> Transfer-Encoding</h5> <p>메시지 바디의 전송 코딩 형식을 지정하는 경우 사용된다</p> <p><code>Transfer-Encoding: chunked</code></p> <h5 id="upgrade"><a href="#upgrade" class="header-anchor">#</a> Upgrade</h5> <p>HTTP 및 다른 프로토콜의 새로운 버전이 통신에 이용되는 경우 사용된다.</p> <p>리퀘스트에서 Upgrade 헤더 필드에 명시한 프로토콜 사용을 요청한다.
요청은 인접한 서버에만 적용되므로 <code>Connection: Upgrade</code>도 함께 사용한다.</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>GET /index.html HTTP/1.1
Upgrade: TLS/1.0
Connection: Upgrade
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>서버에서는 상태코드 101 <code>Switching Protocols</code> 리스폰스로 응답한다.</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>HTTP/1.1 101 Switching Protocols
Upgrade: TLS/1.0, HTTP/1.1
Connection: Upgrade
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="via"><a href="#via" class="header-anchor">#</a> Via</h5> <p>클라이언트-서버간의 리퀘스트/리스폰스 메시지의 경로를 알기 위해서 사용됨</p> <p>프록시나 게이트웨이는 자신의 서버정보를 Via 헤더 필드에 추가한 뒤 메시지를 전송한다.
(traceroute나 메일의 Received Header와 유사)</p> <p>Via 헤더 필드는 메시지 추적과 리퀘스트 루프회피등에 사용되므로 프록시를 경유하는 경우 반드시 붙여야 할 필요가 있다.</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>GET / HTTP/1.1

GET / HTTP/1.1
Via: 1.0 gw.hackr.jr (Squid/3.1)

GET / HTTP/1.1
Via: 1.0 gw.hackr.jr (Squid/3.1), 1.1 a1.example.com (Squid/2.7)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h5 id="warning"><a href="#warning" class="header-anchor">#</a> Warning</h5> <p>Warning 헤더는 HTTP/1.0 Retry-After라 변경된 것으로, 리스폰스에 관한 추가정보를 전달한다.</p> <p><code>Warning: [경고코드][경고한호스트:포트번호]&quot;[경고문]&quot; ([날짜])</code></p> <p>HTTP/1.1에는 7개의 경고코드가 정의되어 있다(권장사항)</p> <ul><li>110: Response is state: 프록시가 유효기간이 지난 리소스 반환</li> <li>111: Revalidation failed: 프록시가 리소스의 유효성 재확인에 실패함</li> <li>112: Disconnection Operation: 프록시의 네트워크가 연결되어있지 않다</li> <li>113: Heuristic expiration: 캐시 유효기한을 경과한 리스폰스</li> <li>199: Miscellaneous warning: 임의 경고문</li> <li>214: Transformation applied: 프록시가 인코딩/미디어 타입에 대응하여 처리한 경우</li> <li>288: Miscellaneous persistent warning: 임의 경고문</li></ul> <h4 id="request-header-fields"><a href="#request-header-fields" class="header-anchor">#</a> Request Header Fields</h4> <h5 id="accept"><a href="#accept" class="header-anchor">#</a> Accept</h5> <p><code>Accept: text/html, application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</code></p> <p>유저 에이전트에 처리할 수 있는 미디어 타입과 타입 우선순위를 전달하기 위해 사용됨</p> <p>미디어 타입 지정은 <code>타입/서브타입</code>으로 한번에 여러 개를 설정할 수 있음</p> <p>미디어 타입에 우선순위를 붙이려면 세미콜론(<code>;</code>)으로 구분하고 <code>q=1(기본값(최대)</code>로 품질지수를 표기한다.</p> <ul><li><p>텍스트 파일</p> <ul><li>text/html, text/plain, text/css ...</li> <li>application/xhtml+xml, application/xml, application/json ...</li></ul></li> <li><p>이미지 파일</p> <ul><li>image/jpeg, image/gif, image/png ...</li></ul></li> <li><p>동영상 파일</p> <ul><li>vedio/mpeg, video/quicktime ...</li></ul></li> <li><p>바이너리 파일</p> <ul><li>application/octet-stream, application/zip</li></ul></li></ul> <h5 id="accept-charset"><a href="#accept-charset" class="header-anchor">#</a> Accept-Charset</h5> <p><code>Accept-Charset:iso-8859-5, unicode-1-1:q+0.8</code></p> <p>유저 에이전트에서 문자셋의 상대적 우선순위를 전달하기 위해서 사용된다.
여러개를 지정할 수 있으며, 품질지수에 의해 상대적 우선순위를 표시한다.</p> <h5 id="accept-encoding"><a href="#accept-encoding" class="header-anchor">#</a> Accept-Encoding</h5> <p><code>Accept-Encoding: gzip, deflate</code></p> <p>유저 에이전트가 처리할 수 있는 콘텐츠 코딩의 우선순위를 전달한다.</p> <p>콘텐츠 코딩은 한 번에 여러개를 지정할 수 있으며, 품질지수에 의해서 상대적인 우선순위를 표시한다.
또한 <code>*</code>를 지정하면 모든 인코딩 포맷을 가리킨다.</p> <ul><li>gzip: 파일 압축 GNU zip에서 생성된 인코딩 포맷(RFC1952)으로 LZ77 부호와 32비트 CRC 사용</li> <li>compress: UNIX 압축 compress의 인코딩 포맷으로 LZW다</li> <li>deflate: Zlib(RFC1950) 포맷과 deflate 압축 알고리다 의해 만들어진 인코딩 포맷 조합</li> <li>identity: 압축/변형을 하지 않는 디폴트 인코딩 포맷다</li></ul> <h5 id="accept-language"><a href="#accept-language" class="header-anchor">#</a> Accept-Language</h5> <p><code>Accept-Language: ko-kr, en-us;q=0.7,en;q=o.3</code></p> <p>유저 에이전트가 처리할 수 있는 자연어 세트와 세트의 우선순위를 전달한다.</p> <p>자연어 세트는 ㅎ나번에 여러개를 지정할 수 있으며, 품질지수에 의해 상대적인 우선순위를 나타낸다.</p> <h5 id="authorization"><a href="#authorization" class="header-anchor">#</a> Authorization</h5> <p><code>Authorization: Basic dWVUB3NIbjpwYXNzd29yZA==</code></p> <p>유저 에이전트의 인증 정보(크리덴셜 값)를 전달하기 위해 사용됨.</p> <h5 id="expect"><a href="#expect" class="header-anchor">#</a> Expect</h5> <p><code>Expect: 100-continue</code></p> <p>클라이언트가 서버에 특정 동작 요구를 전달한다.
기대하고 있는 요구에 서버가 응답하지 못하는 경우 417 Expectation Failed를 반환한다.</p> <h5 id="from"><a href="#from" class="header-anchor">#</a> From</h5> <p><code>From: info@hackr.jp</code></p> <p>유저 에이전트를 사용하고 있는 유저의 메일 주소를 전달한다.</p> <h5 id="host"><a href="#host" class="header-anchor">#</a> Host</h5> <p><code>Host: www.google.com</code></p> <p>리퀘스트한 리소스의 인터넷 호스트와 포트번호를 전달한다.
1대의 서버에 복수도메인 할당이 가능하므로, Host 헤더 필드는 HTTP/1.1에서 유일한 필수 헤더이다.</p> <h5 id="if-match"><a href="#if-match" class="header-anchor">#</a> If-Match</h5> <p><code>If-Match: &quot;etag&quot;</code></p> <p>조건부 리퀘스트의 하나로 서버 상의 리소스를 특정하기 위해서 엔티티 태그(ETag) 값을 전달한다.</p> <p>서버는 If-Match 필드 값과 리소스 ETag 값이 일치하는 경우에만 리퀘스트를 받아들인다.
만약 일치하지 않는경우 상태코드 412 Precondition Failed를 반환한다.</p> <p>If-Match 필드값으로 <code>*</code>를 지정하면 ETag 값과 상관없이 리소스가 존재하면 리퀘스트를 처리한다.</p> <h5 id="if-none-match"><a href="#if-none-match" class="header-anchor">#</a> If-None-Match</h5> <p>조건부 리퀘스트의 하나로 If-Match와 반대로 동작한다.</p> <p>GET과 HEAD 메소드에서 If-None-Match 헤더 필드를 사용하면 최신 리소스를 요구하는 것이 되므로
If-Modified-Since 헤더 필드를 사용하는 것과 비슷해진다.</p> <h5 id="if-modified-since"><a href="#if-modified-since" class="header-anchor">#</a> If-Modified-Since</h5> <p><code>If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT</code></p> <p>조건부 리퀘스트의 하나로 리소스 갱신날짜가 필드값 시점보다 최신인경우 리퀘스트를 받아들인다.
리소스가 outdated인 경우 상태코드 304 Not Modified 리스폰스를 반환한다.</p> <h5 id="if-unmodified-since"><a href="#if-unmodified-since" class="header-anchor">#</a> If-Unmodified-Since</h5> <p>If-Modified-Since 헤더 필드와 반대로 동작한다.</p> <p>지정된 리소스가 필드 값 시점 이전에 갱신된 리퀘스트만 받는다.</p> <h5 id="if-range"><a href="#if-range" class="header-anchor">#</a> If-Range</h5> <p>조건부 리퀘스트의 하나로 If-Range로 지정한 필드값(ETag or 날짜)과 지정 리소스의 Etag or 날짜가 일치하면 Range 리퀘스트로 처리한다.
일치하지 않는 경우 리소스 전체를 반환한다.</p> <p>만약 서버의 리소스가 갱신되어 있는 경우, If-Range 헤더 필드를 사용하지 않은 Range 리퀘스트라면 무효한 요청이되어
상태코드 412 Precondition Failed를 반환하고 클라이언트에게 다시 리퀘스트를 요청하게 된다.</p> <p>If-Range를 사용하는경우 갱신된 리소스의 경우 전체를 반환하므로 통신과정이 줄어들게 된다.</p> <h5 id="max-forwards"><a href="#max-forwards" class="header-anchor">#</a> Max-Forwards</h5> <p><code>Max-Forwards: 10</code></p> <p>TRACE 혹은 OPTIONS 메소드에 의해 리퀘스트를 할 때 거쳐갈 최대 서버 수를 10진 정수로 지정한다.</p> <p>따라서 서버는 다음 서버에 리퀘스트를 전송할 때 Max-Forwards 갑셍서 1을 빼서 보내고,
값이 0인 리퀘스트를 받은 경우 리스폰스를 반환한다.</p> <h5 id="proxy-authorization"><a href="#proxy-authorization" class="header-anchor">#</a> Proxy-Authorization</h5> <p><code>Proxy-Authorization: Basic dGIwOjkpNLAGfFY5</code></p> <p>프록시 서버에서 인증요구를 받아들인 때 인증에 필요한 클라이언트의 정보를 전달한다.</p> <p>클라이언트와 서버의 경우에 사용되는 Authorization 헤더 필드의 역할이 클라이언트와 프록시 사이에서 이루저이는 것이다.</p> <h5 id="range"><a href="#range" class="header-anchor">#</a> Range</h5> <p><code>Range: bytes=5001-10000</code></p> <p>리소스의 일부분만 취득하는 Range 리퀘스트를 할 때 지정 범위를 전달한다.</p> <p>서버가 Range 헤더필드가 있는 리퀘스트를 처리할 수 있는 경우에는 상태코드 206 Partial Content 리스폰스를 반환하고,
처리할 수 없는 경우 상태코드 200 OK 리스폰스와 함께 리소스 전체를 반환한다.</p> <h5 id="referer"><a href="#referer" class="header-anchor">#</a> Referer</h5> <p>리퀘스트가 발생한 본래 리소스의 URI를 전달한다.
브라우저 주소창에 직접 URI를 입력한 경우 전달되지 않는다.</p> <p>리소스의 URI 쿼리에 민감정보가 포함되어 있는경우 Referer를 통해 해당 정보가 보내질 수 있다.</p> <h5 id="te"><a href="#te" class="header-anchor">#</a> TE</h5> <p><code>TE; gzip, deflate;q=0.5</code></p> <p>리스폰스로 받을 수 있는 전송 코딩의 형식과 우선순위를 전달한다.</p> <p>Accept-Encoding 헤더 필드와 유사하지만, 전송 코딩에 적용된다는 점이 다르다.</p> <p>TE 헤더 필드는 전송 코딩의 지정 외에 Trailer를 동반하는 Chunk 전송 인코딩 형식을 지정할 수 있다.
이 경우 <code>TE; Trailers</code>와 같이 표기한다.</p> <h5 id="user-agent"><a href="#user-agent" class="header-anchor">#</a> User-Agent</h5> <p><code>User-Agent:Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.19 (KHTML,like Gecko) Chrome/18.0.1025.162 Safari/535.195)</code></p> <p>리퀘스트를 생성한 브라우저와 유저 에이전트의 정보를 전달하기위한 필드이다.</p> <p>로봇의 리퀘스트는 로봇 엔진의 책임자 메일주소가 들어있기도 하다.
또는 프록시를 경유한 리퀘스트의 경우 프록시 서버의 이름등이 표시되어 있기도 하다.</p> <h4 id="response-header-fields"><a href="#response-header-fields" class="header-anchor">#</a> Response Header Fields</h4> <p>서버 측으로부터 클라이언트 측으로 송신되는 리스폰스 메시지에 적용된 헤더로
리스폰스의 부가정보나 서버의 정보, 클라이언트에 부가정보 요구등을 나타냄</p> <h5 id="accept-ranges"><a href="#accept-ranges" class="header-anchor">#</a> Accept-Ranges</h5> <p><code>Accept-Range: bytes</code></p> <p>서버가 리소스의 일부분만 지정해서 취득할 수 있는 Range 리퀘스트를 받을 수 있는지 여부전달</p> <p>가능할 경우 <code>bytes</code>, 불가능할 경우 <code>none</code></p> <h5 id="age"><a href="#age" class="header-anchor">#</a> Age</h5> <p><code>Age: 600</code></p> <p>얼마나 오래 전에 오리진 서버에서 리스폰스가 생성되었는지 전달한다.</p> <p>리스폰스한 서버가 프록시 서버면 Age 헤더 필드는 필수 값이다</p> <h5 id="etag"><a href="#etag" class="header-anchor">#</a> ETag</h5> <p><code>ETag: &quot;82e22293907ce725faf67773957acd12&quot;</code></p> <p>엔티티 태그라고 불리며 리소스를 특정하기 위한 문자열을 전달한다.
서버는 리소스마다 ETag 값을 할당한다.</p> <p>리소스가 갱신되는 경우 ETag 값도 갱싱되어야 할 필요가 있다.
ETag 값은 룰이 있지는 않고 서버에 따라 다양한 값을 할당한다.</p> <p>URI만으로 캐시했던 리소스를 특정하기 어려운 경우 ETag를 참조해서 리소스를 특정할 수 있다.</p> <ul><li><p>강한 ETag 값</p> <ul><li>엔티티가 아주 조금 다르더라도 반드시 값이 변함</li> <li><code>ETag: &quot;Usagi-1234'</code></li></ul></li> <li><p>약한 ETag 값</p> <ul><li>약한 ETag 값은 리소스가 같다는 것만 나타냄</li> <li><code>ETag: W/&quot;usagi-1234&quot;</code></li></ul></li></ul> <h5 id="location"><a href="#location" class="header-anchor">#</a> Location</h5> <p><code>Location: http://www.usagidesign.jp/sample.html</code></p> <p>리스폰스의 수신자에 대해서 Request-URI 이외의 리소스 액세스를 유도하는 경우 사용됨</p> <p>기본적으로 3xx Redirection 리스폰스에 대해서 리다이렉트 URI를 기술함</p> <h5 id="proxy-authenticate"><a href="#proxy-authenticate" class="header-anchor">#</a> Proxy-Authenticate</h5> <p><code>Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</code></p> <p>프록시 서버의 인증요구를 클라이언트에 전달한다.
클라이언트와 서버의 경우 WWW-Authorization 필드와 같은역할을 한다.</p> <h5 id="retry-after"><a href="#retry-after" class="header-anchor">#</a> Retry-After</h5> <p><code>Retry-After: 120</code></p> <p>클라이언트가 일정 시간 후에 리퀘스트를 다시 시행해야 하는지를 전달함
주로 상태코드 503 Service Unavailable, 3xx Redirect 리스폰스와 함께 사용된다</p> <p>값으로는 날짜나 리스폰스 이후 지연시간(seconds)을 지정할 수 있다.</p> <h5 id="server"><a href="#server" class="header-anchor">#</a> Server</h5> <p><code>Server: Apache/2.2.17(Unix)</code></p> <p>서버에 설치되어 있는 HTTP 서버 소프트웨어를 전달함</p> <h5 id="vary"><a href="#vary" class="header-anchor">#</a> Vary</h5> <p><code>Vary: Accept-Language</code></p> <p>오리진 서버가 프록시 서버에 로컬 캐시를 사용하는 방법에 대한 지시를 전달함</p> <p>오리진 서버로부터 Vary에 지정되었던 리스폰스를 받아들인 프록시 서버는
캐시된 때의 리퀘스트와 같은 Vary 헤더필드를 가진 리퀘스트에 대해서만 캐시를 반환한다.</p> <p>리퀘스트에 Vary에 지정된 헤더 필드가 다른경우, 오리진 서버로 부터 리소스를 취득해야 한다.</p> <h5 id="www-authenticate-서버의-클라이언트-인증을-위한-정보"><a href="#www-authenticate-서버의-클라이언트-인증을-위한-정보" class="header-anchor">#</a> WWW-Authenticate: 서버의 클라이언트 인증을 위한 정보</h5> <p><code>WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</code></p> <p>HTTP 액세스 인증에 사용되고, Request-URI의 리소스에 적용할 수 있는
인증 스키마 (Basic / Digest)와 파라미터를 나타내는 challenge를 전달한다.</p> <p>WWW-Authenticate 헤더필드는 상태코드 401 Unauthorized 리스폰스에 반드시 포함된다.</p> <h4 id="entity-header-fields"><a href="#entity-header-fields" class="header-anchor">#</a> Entity Header Fields</h4> <h5 id="allow"><a href="#allow" class="header-anchor">#</a> Allow</h5> <p><code>Allow: GET, HEAD</code></p> <p>Request-URI에 지정된 리소스가 제공하는 메소드의 목록</p> <p>서버가 받을 수 없는 메소드를 수신한 경우에는 상태코드 405 Method Not Allowed 리스폰스와 함께
수신가능한 메소드 목록을 기술한 Allow 헤더필드를 반환한다.</p> <h5 id="content-encoding"><a href="#content-encoding" class="header-anchor">#</a> Content-Encoding</h5> <p><code>Content-Encoding: gzip</code></p> <p>엔티티 바디의 콘텐츠 코딩형식을 전달한다.</p> <p>주로 4가지 콘텐츠 코딩 형식이 사용된다. (Accept-Encoding 헤더 필드 항목과 동일)</p> <ul><li>Gzip</li> <li>Compress</li> <li>Deflate</li> <li>Identity</li></ul> <h5 id="content-language"><a href="#content-language" class="header-anchor">#</a> Content-Language</h5> <p><code>Content-Language: en</code></p> <p>엔티티 바디에 사용된 자연어를 전달함</p> <h5 id="content-length"><a href="#content-length" class="header-anchor">#</a> Content-Length</h5> <p><code>Content-Length: 15000</code></p> <p>엔티티 바디의 크기(bytes)를 전달한다.</p> <p>엔티티 바디에 전송 코딩이 사용된 경우 Content-Length 필드를 사용하면 안된다. (RFC2616 4.4)</p> <h5 id="content-location"><a href="#content-location" class="header-anchor">#</a> Content-Location</h5> <p><code>Content-Location: http://pravusid.kr/index.html</code></p> <p>메시지 바디에 대응하는 URI를 전달함</p> <p>Location이 리다이렉션의 대상(혹은 새롭게 만들어진 문서의 URL)을 가르키는데 반해,
Content-Location은 더 이상의 컨텐츠 협상없이, 리소스 접근에 필요한 직접적인 URL을 지시함.</p> <h5 id="content-md5"><a href="#content-md5" class="header-anchor">#</a> Content-MD5</h5> <p><code>Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</code></p> <p>메시지 바디가 변경되지 않고 도착했는지 확인하기 위해 MD5 해시값을 Base64 인코딩하여 전달한다.</p> <p>리퀘스트시 콘텐츠와 함께 MD5 해시값도 변조하여 보내는 것도 가능하므로 서버측에서 원래 의도한 데이터인지 여부와는 관계없다.</p> <h5 id="content-range"><a href="#content-range" class="header-anchor">#</a> Content-Range</h5> <p><code>Content-Range: bytes 5001-10000/10000</code></p> <p>범위를 지정해서 일부분만을 리퀘스트하는 Range 리퀘스트에 대해서 리스폰스 할 때 사용된다.</p> <p>필드 값은 반환하는 엔티티 범위와 전체사이즈이다.</p> <h5 id="content-type"><a href="#content-type" class="header-anchor">#</a> Content-Type</h5> <p><code>Content-Type: text/html; charset=UTF-8</code></p> <p>엔티티 바디에 포함되는 오브젝트의 미디어 타입을 전달한다. 필드 값은 타입/서브타입으로 구성된다.</p> <h5 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h5> <p><code>Expires: Wed, 04 Jul 2012 08:26:05 GMT</code></p> <p>리소스의 유효 기한 날짜를 전달한다.</p> <p>캐시 서버가 Expires 헤더필드를 포함한 리소스를 수신한 경우 필드 값으로 지정된 날짜까지 리스폰스의 복사본으로 리퀘스트에 응답한다.
지정된 날짜가 지나면 리퀘스트가 왔을 때 오리진 서버에 리소스를 요청한다.</p> <p><code>Cache-Control</code> 헤더필드의 <code>max-age</code> 디렉티브는 <code>Expires</code> 헤더필드보다 우선순위가 높다.</p> <h5 id="last-modified"><a href="#last-modified" class="header-anchor">#</a> Last-Modified</h5> <p><code>Last-Modified: Wed, 23 May 2012 09:59:55 GMT</code></p> <p>리소스가 마지막으로 갱신되었던 날짜 정보를 전달한다.</p> <h4 id="쿠키를-위한-헤더-필드"><a href="#쿠키를-위한-헤더-필드" class="header-anchor">#</a> 쿠키를 위한 헤더 필드</h4> <p>쿠키는 HTTP/1.1의 사양인 RFC2616에 포함된 것은 아니지만 널리 사용되고 있다.</p> <p>현재 사용되는 쿠기의 사양은 RFC6256이다.
쿠키에 관련한 헤더필드는 다음의 것이 사용되고 있다.</p> <ul><li>Set-Cookie: 리스폰스: 상태 관리 개시를 위한 쿠키 정보</li> <li>Cookie: 리퀘스트: 서버에서 수신한 쿠키 정보</li></ul> <h5 id="set-cookie"><a href="#set-cookie" class="header-anchor">#</a> Set-Cookie</h5> <p><code>Set-Cookie: status-enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; =&gt;path=/;domain=.hack.jp;</code></p> <p>서버가 클라이언트에 대해서 상태 관리를 시작할 때 정보를 전달한다.</p> <ul><li><p>NAME=VALUE</p> <ul><li>쿠키에 부여된 이름과 값</li></ul></li> <li><p>Expires=DATE</p> <ul><li>브라우저가 쿠키를 송출할 수 있는 유효기한</li> <li>값이 없으면 세션이 유지되고 있는 동안만 유효함</li> <li>한번 송출한 클라이언트 쿠키를 명시적으로 삭제하는 방법은 없고, 덮어쓰는 것으로 실질적으로 삭제가능</li></ul></li> <li><p>Path=PATH</p> <ul><li>쿠키 송출 범위를 특정 디렉토리(도메인의)에 한정할 수 있다</li></ul></li> <li><p>Domain=도메인명</p> <ul><li>domain을 지정하고 값을 비교할 때 후방 일치여부를 확인함</li></ul></li> <li><p>Secure</p> <ul><li><code>Set-Cookie: name=value; secure</code></li> <li>HTTPS에서 열렸을 때만 쿠키를 송출함</li></ul></li> <li><p>HttpOnly</p> <ul><li><code>Set-Cookie: name=value; HttpOnly</code></li> <li>자바스크립트를 경유하여 쿠키를 취득하지 못하도록 함</li> <li>XSS로부터 쿠키 도청을 막기 위함이 목적이다</li></ul></li></ul> <h5 id="cookie"><a href="#cookie" class="header-anchor">#</a> Cookie</h5> <p><code>Cookie: status=enable</code></p> <p>클라이언트가 서버로부터 수신한 쿠키를 이후의 리퀘스트에 포함해서 전달함</p> <p>쿠키를 여러개 수신하고 있다면, 여러개의 쿠키를 보내는 것도 가능하다.</p> <h3 id="이외의-헤더-필드"><a href="#이외의-헤더-필드" class="header-anchor">#</a> 이외의 헤더 필드</h3> <p>HTTP 헤더 필드는 독자적으로 확장할 수 있다.
여러곳에서 지원하는 확장 헤더 필드들은 다음과 같다.</p> <h4 id="x-frame-option"><a href="#x-frame-option" class="header-anchor">#</a> X-frame-Option</h4> <p><code>X-Frame-Option: DENY</code></p> <p>다른 웹 사이트의 프레임에서 표시를 제어하는 리스폰스 헤더로, Click jacking 공격 방지를 목적으로 한다.</p> <p>필드값으로 설정할 수 있는 값은 다음과 같다</p> <ul><li>DENY: 거부</li> <li>SAMEORIGIN: Top-level-browsing-context가 일치하는 경우에만 허가</li></ul> <h4 id="x-xss-protection"><a href="#x-xss-protection" class="header-anchor">#</a> X-XSS-Protection</h4> <p><code>X-XSS-Protection: 1</code></p> <p>크로스 사이트 스크립팅(XSS) 대책으로 브라우저의 XSS 보호기능을 제어하는 리스폰스 헤더이다</p> <p>헤더 필드에 지정할 수 있는 값은 다음과 같다</p> <ul><li>0: XSS 필터를 무효화</li> <li>1: XSS 필터를 유효화</li></ul> <h4 id="dnt"><a href="#dnt" class="header-anchor">#</a> DNT</h4> <p><code>DNT: 1</code></p> <p>Do Not Track의 약어로 개인정보 수집을 거부하는 의사를 표시하는 리퀘스트 헤더이다.</p> <p>헤더 필드에 지정할 수 있는 값은 다음과 같다</p> <ul><li>0: 트래킹 동의</li> <li>1: 트래킹 거부</li></ul> <h4 id="p3p"><a href="#p3p" class="header-anchor">#</a> P3P</h4> <p><code>P3P: CP=&quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND UNI COM NAV INT&quot;</code></p> <p>웹사이트 상의 프라이버시 정책에 The Platform for Privacy Preferences를 사용하기 위한 리스폰스 헤더이다.</p> <p>P3P 정책은 다음 순서로 실행된다</p> <ol><li>P3P 정책 작성</li> <li>P3P 정책 참조 파일을 작성하여 <code>/w3c/p3p.xml</code>에 배치</li> <li>P3P 정책으로부터 콤팩트 정책을 작성하고 HTTP 리스폰스 헤더에 출력</li></ol> <h2 id="https-프로토콜"><a href="#https-프로토콜" class="header-anchor">#</a> HTTPS 프로토콜</h2> <h3 id="http의-약점"><a href="#http의-약점" class="header-anchor">#</a> HTTP의 약점</h3> <h4 id="평문이므로-도청-가능"><a href="#평문이므로-도청-가능" class="header-anchor">#</a> 평문이므로 도청 가능</h4> <p>TCP/IP의 통신내용은 통신 경로 도중에 패킷을 수집하는 것만으로도 엿볼 수 있다.</p> <p>정보를 보호하기 위해 통신을 암호화 하거나 콘텐츠를 암호화 할 수 있다.</p> <p>통신 암호화는 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)이라는
다른 프로토콜을 조합하여 가능하다.
이렇게 SSL을 조합한 HTTP를 HTTPS(HTTP Secure)라 부른다.</p> <p>콘텐츠를 암호화하기 위해서 클라이언트와 서버가 콘텐츠 암호화 복호화 기능을 수행해야한다.</p> <h4 id="통신-상대를-확인하지-않음"><a href="#통신-상대를-확인하지-않음" class="header-anchor">#</a> 통신 상대를 확인하지 않음</h4> <p>HTTP에서는 상대가 누구인지 확인하는 처리는 없으므로 누구든지 리퀘스트를 보낼 수 있고,
리퀘스트가 오면 상대가 누구든지 리스폰스를 반환한다.</p> <p>이는 다음과 같은 문제점을 유발할 수 있다</p> <ul><li>리퀘스트를 보낸 곳이 의도와 다르게 위장한 서버일 수 있다</li> <li>리스폰스를 반환한 곳의 클라이언트가 리퀘스트를 보낼때 의도한 클라이언트인지 확인할 수 없다</li> <li>통신 상대가 접근이 허가된 상대인지를 확인할 수 없다</li> <li>어떤 곳에서 리퀘스트를 했는지 확인할 수 없다</li> <li>의미없는 리퀘스트도 모두 수신한다 (DoS 공격일지라도)</li></ul> <p>HTTP에서는 통신 상대를 확인할 수 없지만 신뢰할 수 있는 제3자가 발행한 SSL의 증명서로 상대를 확인할 수 있다.</p> <p>증명서를 이용하여 서버는 통신상대에게 통신하고자 하는 서버임을 알릴 수 있고,
클라이언트는 증명서로 본인확인을 하고 인증에 사용할 수도 있다.</p> <h4 id="변조가능"><a href="#변조가능" class="header-anchor">#</a> 변조가능</h4> <p>HTTP는 리퀘스트나 리스폰스가 발신된 후 상대가 수신하는 사이 변조되었더라도 그 사실을 확인할 수 없다.</p> <p>도중에 리퀘스트나 리스폰스를 탈취하여 변조하는 공격을 Man-in-the-Middle 공격이라고 부른다.</p> <p>변조를 피해 완전성을 확인하기 위해 일반적으로 자주 사용되는 방법은,
해시값을 확인하거나 파일의 디지털 서명을 확인하는 것이다.</p> <p>하지만 해시값이나 디지털 서명도 함께 변조될 수 있으므로 해결책이 될 수는 없다.</p> <h3 id="http-암호화-인증-완전성-https"><a href="#http-암호화-인증-완전성-https" class="header-anchor">#</a> HTTP + 암호화 + 인증 + 완전성 = HTTPS</h3> <p>HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니다.
HTTP 통신을 하는 소켓 부분을 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security) 프로토콜로 대체한 것이다.</p> <p>보통 HTTP는 직접 TCP와 통신하지만 SSL을 사용한 경우에는 HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게 된다.</p> <p>HTTPS는 공통키 암호화 공개키 암호 두 방식을 동시에 사용하여 암호화 한다.
공통키 암호는 안전하게 키를 교환하기 어렵고, 공개키 암호는 처리속도가 느리기 때문이다.</p> <p>따라서 공통키 암호의 키를 교환할 때 공개키 암호화를 사용하고 이후로는 공통키 암호화 방식을 사용한다.</p> <p>문제는 공개키가 진짜인지 아닌지를 증명할 필요도 있다는 것이다.
이 문제 해결을 위해 인증 기관(Certificate Authority)과 그 기관이 발행하는 공개키 증명서가 이용된다.</p> <p>인증 기관은 클라이언트와 서버 모두가 신뢰하는 3자 기관이다.</p> <p>인증 기관을 경유한 암호키 교환 순서는 다음과 같다</p> <ol><li>서버의 공개키를 인증기관에 등록</li> <li>인증기관의 비밀키로 서버의 공개키에 디지털 서명으로 공개키 증명서를 작성 등록</li> <li>서버의 공개키 증명서를 입수하고 디지털 서명을 인증기관의 공개키로 검증한다</li> <li>서버의 공개키로 암호화 해서 메시지를 서버로 보낸다</li> <li>서버의 비밀키로 메시지를 복호화 한다</li></ol> <blockquote><p>주요 인증기관의 공개키는 사전에 브라우저에 내장되어 있다</p></blockquote> <h4 id="ev-ssl-증명서"><a href="#ev-ssl-증명서" class="header-anchor">#</a> EV SSL 증명서</h4> <p>상대방이 실제 존재하는 기업인지 확인하는 역할을 하는 증명서를 EV SSL 증명서라 한다.
EV SSL 증명서로 증명된 웹사이트에 접속하면 주소창의 색이 녹색으로 변하는 것을 확인할 수 있다.</p> <h4 id="클라이언트-증명서"><a href="#클라이언트-증명서" class="header-anchor">#</a> 클라이언트 증명서</h4> <p>HTTPS에서는 클라이언트 증명서도 이용할 수 있다.</p> <p>그러나 클라이언트 증명서는 몇 가지 문제점이 있다.</p> <ul><li>유저가 클라이언트 증명서를 직접 구비해야 한다</li> <li>유저 수 만큼 비용이 들게된다</li> <li>클라이언트를 증명할 뿐 사용자의 존재를 증명하지는 않는다</li></ul> <h4 id="자가-인증기관"><a href="#자가-인증기관" class="header-anchor">#</a> 자가 인증기관</h4> <p>OpenSSL등을 활용하면 자체적으로 인증 기관을 구축하여 서버 증명서를 발행할 수 있다.
그러나 신뢰할 수 있는 제3자 기관이 인증하는 것이 아닌이상 증명서로 구실을 하지 못할 수 있다.</p> <p>마찬가지로 메이저 인증기관이 아닌 마이너 인증기관을 이용한다면 브라우저에 따라 인증서 신뢰성 인식에 문제가 발생할 수 있다.</p> <h3 id="https-구조"><a href="#https-구조" class="header-anchor">#</a> HTTPS 구조</h3> <ol><li><p>(C→S) Handshake: ClientHello</p> <ul><li>클라이언트가 Client Hello 메시지를 보내며 SSL 통신시작</li> <li>메시지에는 클라이언트 SSL 버전지정, Cipher Suite(사용하는 암호화의 알고리즘, 키 사이즈 등)</li></ul></li> <li><p>(C←S) Hansshake: ServerHello</p> <ul><li>서버가 SSL 통신이 가능한 경우 Server Hello 메시지로 응답</li> <li>메시지에는 SSL 버전, Cipher Suite 포함 (클라이언트에서 받은 내용에서 선택됨)</li></ul></li> <li><p>(C←S) Handshake: Certificate</p> <ul><li>서버가 공개키 증명서가 포함된 Certificate 메시지를 송신</li></ul></li> <li><p>(C←S) Handshake: ServerHelloDone</p> <ul><li>서버가 Server Hello Done 메시지를 송신하여 최초 SSL negotiation이 끝났음을 통지함</li></ul></li> <li><p>(C→S) Handshake: ClientKeyExchange</p> <ul><li>최초 SSL negotiation이 종료되면 클라이언트가 Client Key Exchange 메시지로 응답</li> <li>메시지에는 통신을 암호화하는데 사용하는 Pre-Master secret 포함</li> <li>메시지는 <code>3</code>의 공개키 증명서에서 추출한 공개키로 암호화 됨</li></ul></li> <li><p>(C→S) ChangeCipherSpec</p> <ul><li>클라이언트는 Change Cipher Spec 메시지를 송신함</li> <li>메시지 이후의 통신은 암호키를 사용하여 진행한다는 것을 표현하는 것</li></ul></li> <li><p>(C→S) Handshake: Finished</p> <ul><li>클라이언트는 Finished 메시지를 송신함</li> <li>메시지는 접속 전체의 체크 값을 포함함</li> <li>Negotiation이 성공했다면 서버가 이 메시지를 복호화 할 수 있다</li></ul></li> <li><p>(C←S) ChangeCipherSpec</p> <ul><li>서버에서도 Change Cipher Spec 메시지를 송신함</li></ul></li> <li><p>(C←S) Handshake: Finished</p> <ul><li>서버에서도 Finished 메시지를 송신함</li></ul></li> <li><p>(C→S) Application Data (HTTP)</p> <ul><li>서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL 접속이 완료됨</li> <li>이후로는 애플리케이션 계층의 프로토콜(HTTP)로 통신(HTTP 리퀘스트 송신)</li></ul></li> <li><p>(C←S) Application Data (HTTP)</p> <ul><li>HTTP 리스폰스를 송신</li></ul></li> <li><p>(C→S) Alert: warning, close notify</p> <ul><li>클라이언트가 접속을 끊으면 close notify 메시지를 송신함</li> <li>이후 TCP FIN 메시지를 보내 TCP 통신을 종료함</li></ul></li></ol> <blockquote><p>애플리케이션 계층의 데이터를 송신할 때 MAC(Message Authentication Code)라 불리는 메시지 다이제스트를 덧붙일 수 있다. MAC을 이용해 변조를 감지할 수 있다.</p></blockquote> <h4 id="ssl과-tls"><a href="#ssl과-tls" class="header-anchor">#</a> SSL과 TLS</h4> <p>SSL은 넷스케이프의 프로토콜로 현재는 IETF로 이관되었다.
SSL3.0을 기반으로하여 TLS1.0이 만들어졌고 현재 TLS1.1 TLS1.2 TLS1.3이 있다.</p> <p>TLS는 SSL을 바탕으로 한 프로토콜이고 이를 총칭해서 SSL이라 부르기도 한다.</p> <h3 id="https의-속도"><a href="#https의-속도" class="header-anchor">#</a> HTTPS의 속도</h3> <p>HTTPS를 사용하게 되면 TCP 접속과 HTTP 리퀘스트/리스폰스외에도 SSL에 필요한 통신이 추가된다.
또한 암호화 처리를 위해서 서버와 클라이언트의 리소스를 사용하게된다.</p> <p>SSL 엑셀레이터라는 하드웨어를 사용해서 이 문제를 해결하기도 한다.</p> <h2 id="인증"><a href="#인증" class="header-anchor">#</a> 인증</h2> <p>HTTP/1.1에서 사용할 수 있는 인증방식은 다음이 있다</p> <h3 id="basic-인증"><a href="#basic-인증" class="header-anchor">#</a> BASIC 인증</h3> <p>Basic 인증은 HTTP/1.0에 구현된 인증방식으로 일부 사용되고 있다.</p> <p>Basic 인증에 사용되는 Base64 인코딩은 암호화가 아니며,
인증이 한 번 이루어지면 일반 브라우저에서 로그아웃 할 수 없다는 문제가 있다.</p> <ol><li><p>Basic 인증이 필요한 리소스에 요청이 발생하면 서버는 다음 내용을 포함해 리스폰스를 반환한다</p> <ul><li>상태코드 401 Authorization Required</li> <li>WWW-Authenticate 헤더필드에 Request-URI의 보호공간을 식별하기 위한 문자열(realm)</li> <li>WWW-Authenticate 헤더필드에 인증 방식(Basic)</li></ul></li> <li><p>상태코드 401을 수신한 클라이언트는 ID와 Password를 서버로 보낸다</p> <ul><li>ID와 Password를 <code>:</code>으로 연결한 문장을 <code>Base64</code>로 인코딩한다</li> <li>Authorization 헤더필드에 인코딩한 문자열을 포함하여 리퀘스트를 보낸다</li></ul></li> <li><p>Authorization 헤더 필드가 포함된 리퀘스트를 받은 서버는</p> <ul><li>인증 정보가 정확한지 확인한다</li> <li>인증 정보가 확인되면 Request-URI 리소스를 포함한 리스폰스를 반환한다</li></ul></li></ol> <h3 id="digest-인증"><a href="#digest-인증" class="header-anchor">#</a> DIGEST 인증</h3> <p>HTTP/1.1에 소개된 Basic 인증의 단점을 보완한 방식이다, 그러나 보안성이 높지않아 많이 사용되지 않는다.</p> <p>Digest 인증에서 사용하는 챌린지 리스폰스 방식은,
최초 상대에게 인증 요구를 보내고 상대방 측에서 받은 챌린지 코드를 사용해서 리스폰스를 계산한 후 상대에게 보낸다.</p> <ol><li><p>인증이 필요한 리소스에 요청이 발생하면 서버는 다음 내용을 포함해 리스폰스를 반환한다</p> <ul><li>상태코드 401 Authorization Required</li> <li>WWW-Authenticate 헤더필드에 Request-URI의 보호공간을 식별하기 위한 문자열(realm)</li> <li>WWW-Authenticate 헤더필드에 챌린지 코드(nonce): 401 반환할 때마다 새로 생성됨</li></ul></li> <li><p>상태코드 401을 수신한 클라이언트는 Digest 인증에 필요한 정보를 서버로 보낸다</p> <ul><li>Authorization 헤더필드에 username, realm, nonce, uri, response를 포함한다</li> <li>username은 realm에서 인증가능한 사용자 이름이다</li> <li>프록시에 의해 Request-URI가 변경되는 경우를 대비하여 digest-uri에 복사한다</li> <li>response는 Request-Digest라고 불리며 nonce를 활용하여 패스워드 문자열을 MD5로 계산한 것이다</li></ul></li> <li><p>Authorization 헤더 필드가 포함된 리퀘스트를 받은 서버는</p> <ul><li>인증 정보가 정확한지 확인한다</li> <li>인증 정보가 확인되면 Request-URI 리소스를 포함한 리스폰스를 반환한다</li> <li>리스폰스의 Authentication-Info 헤더필드에 인증정보를 추가할 떄도 있다</li></ul></li></ol> <h3 id="ssl-클라이언트-인증"><a href="#ssl-클라이언트-인증" class="header-anchor">#</a> SSL 클라이언트 인증</h3> <p>인증 도중 정보가 탈취되었을 때를 방지하기 위한 대책 중 하나이다</p> <p>SSL 클라이언트 인증을 위해서는 사전에 클라이언트에 클라이언트 증명서를 배포해야 한다</p> <ol><li><p>인증이 필요한 리소스에 요청이 발생하면 서버는 클라이언트 증명서를 요구하는 Certificate Request라는 메시지를 보낸다</p></li> <li><p>증명서 요구를 받은 클라이언트 측에서는 클라이언트 증명서와 Client Certificate 메시지를 서버로 보낸다</p></li> <li><p>서버는 클라이언트 증명서를 검증하여 검증결과가 정확하다면 클라이언트의 공개키를 취득하고 HTTPS에 의한 암호를 개시한다</p></li></ol> <h3 id="폼-베이스-인증"><a href="#폼-베이스-인증" class="header-anchor">#</a> 폼 베이스 인증</h3> <p>HTTP 프로토콜에 정의된 사양의 인증방식은 아니지만 일반적으로 사용되는 방식이다
폼 베이스 인증은 표준 사양은 없으나 일반적으로 쿠키를 사용하여 세션관리를 한다.</p> <ol><li><p>클라이언트에서는 서버로 인증을 위해 다음 방식의 리퀘스트르 보낸다</p> <ul><li>ID나 패스워드 등의 자격 정보를 포함한 데이터</li> <li>보통은 POST 메소드가 사용되어 엔티티 바디에 정보를 저장한다</li> <li>입력 데이터의 송신에는 HTTPS를 이용한다</li></ul></li> <li><p>서버는 유저를 식별하기 위해서 세션ID를 발행한다</p> <ul><li>클라이언트로 부터 수신한 인증정보를 검증한다</li> <li>인증 상태를 세션ID와 연결하여 서버측에 기록한다</li> <li>클라이언트에 송신할 때는 Set-Cookie 헤더 필드에 세션ID(PHPSESSID / JSESSIONID ...)를 포함한다</li> <li>세션ID는 유저를 구별하기 위한 것으로 탈취/유추가 어렵도록 해야한다</li> <li>XSS등의 취약성을 대비하기 위해 쿠키는 httponly 속성을 부여한다</li></ul></li> <li><p>클라이언트는 서버에서 받은 세션ID를 쿠키로 저장해둔다</p></li></ol> <h2 id="http의-추가-프로토콜"><a href="#http의-추가-프로토콜" class="header-anchor">#</a> HTTP의 추가 프로토콜</h2> <p>HTTP 규격이 만들어졌을 때의 예상과 다르게, 다방면으로 사용되면서 프로토콜의 한계를 보완하려는 움직임이 있다</p> <h3 id="spdy"><a href="#spdy" class="header-anchor">#</a> SPDY</h3> <p>Google이 2010년 발표한 SPDY(SPeeDY)는 HTTP의 병목현상을 해소한다는 목표로 개발되고 있다.</p> <p>HTTP에서는 서버의 정보가 갱신되었는지를 알기위해서 클라이언트가 항상 서버에 확인을 요청해야 한다.
따라서 정보가 갱신되지 않은경우 불필요한 통신이 발생하게 된다.</p> <h4 id="http의-병목"><a href="#http의-병목" class="header-anchor">#</a> HTTP의 병목</h4> <p>현재의 조건에서 다음과 같은 HTTP의 사양이 병목을 일으킬 수 있다</p> <ul><li>1개의 커넥션으로 1개의 리퀘스트만 보낼 수 있다</li> <li>리퀘스트는 클라이언트에서만 시작할 수 있다. 리스폰스만 받는것은 불가능하다</li> <li>리퀘스트/리스폰스 헤더를 압축하지 않은 채로 보낸다. 헤더의 정보가 많을 수록 느려진다</li> <li>장황한 헤더를 보내며, 이를 매번 반복한다</li> <li>데이터 압축 여부를 선택할 수 있다 (강제적이지 않다)</li></ul> <p>이를 해결 하기위해 다음의 방법을 사용할 수 있다</p> <ul><li>Ajax로 해결: 기존의 동기식 통신에 비해 페이지의 일부만 갱신되므로 교환되는 데이터의 양이 줄어든다</li> <li>Comet으로 해결: Comet에서는 리스폰스를 보류 상태로 해 두고 서버의 콘텐츠가 갱신되었을 때 리스폰스를 반환한다</li></ul> <p>두 방식다 HTTP 프로토콜의 제약을 없앨 수 없고 나름의 단점이 존재한다.</p> <h4 id="spdy-설계와-기능"><a href="#spdy-설계와-기능" class="header-anchor">#</a> SPDY 설계와 기능</h4> <p>SPDY는 HTTP를 완전히 바꾸는 것이아니라 TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 새로운 세션 계층을 추가하는 형태이다.
SPDY가 세션 계층으로 들어가서 데이터 흐름을 제어하지만 HTTP 커넥션은 존재한다.</p> <p>SPDY를 사용하면 다음과 같은 기능을 사용할 수 있다</p> <ul><li>다중화 스트림: 단일 TCP 접속을 통해 복수의 HTTP 리퀘스트를 무제한 처리할 수 있다</li> <li>리퀘스트 우선순위 부여: SPDY는 무제한 리퀘스트 병렬처리가 가능하고, 각 리퀘스트에 우선순위를 할당할 수 있다</li> <li>HTTP 헤더 압축: 리퀘스트/리스폰스 HTTP 헤더를 압축한다</li> <li>서버 푸시: 서버에서 클라이언트로 데이터를 Push하는 서버푸시를 지원한다</li> <li>서버 힌트: 서버가 클라이언트에게 리퀘스트 해야할 리소스를 제안할 수 있다</li></ul> <h4 id="spdy-결론"><a href="#spdy-결론" class="header-anchor">#</a> SPDY 결론</h4> <p>SPDY를 사용하려면 브라우저와 웹 서버가 이를 지원해야 한다.</p> <p>또한, SPDY는 기본적으로 한 개의 도메인(IP 주소)과의 통신을 다중화 할 뿐이므로,
하나의 웹 사이트에서 복수의 도메인으로 리소스를 사용하는 경우 그 효과는 한정적이다.</p> <h3 id="websocket"><a href="#websocket" class="header-anchor">#</a> WebSocket</h3> <p>2011년 12월 11일 WebSocket의 단독 사양이 RFC 6455-The WebSocket Protocol로 출시되었다</p> <h4 id="websocket의-설계와-기능"><a href="#websocket의-설계와-기능" class="header-anchor">#</a> WebSocket의 설계와 기능</h4> <p>웹소켓은 웹 브라우저와 웹 서버를 위한 양방향 통신 규격으로
웹소켓 프로토콜을 IETF가 책정하고 웹소켓 API를 W3C가 책정하고 있다.</p> <p>주로 Ajax나 Comet에서 사용하는 XMLHttpRequest의 결점을 해결하는 것에 초점이 맞춰져 있다.</p> <h4 id="websocket-프로토콜"><a href="#websocket-프로토콜" class="header-anchor">#</a> WebSocket 프로토콜</h4> <p>웹소켓은 웹 서버와 클라이언트가 한번 접속을 확립하면 그 뒤의 통신은 모두 전용프로토콜로 진행한다.</p> <p>웹소켓 프로토콜의 특징은 다음과 같다</p> <ul><li><p>서버 푸시: 서버에서 클라이언트에게 데이터를 푸시할 수 있다</p></li> <li><p>통신량 감소: 웹소켓은 한번 접속하면 유지할 수 있으므로 HTTP에 비해 빈번한 접속으로 인한 오버헤드가 없어진다</p></li> <li><p>핸드쉐이크/리퀘스트: 웹소켓 통신을 하려면 HTTP의 Upgrade 헤더 필드를 사용해서 프로토콜을 변경하는 것으로 핸드쉐이크를 실시한다</p> <ul><li>Sec-WebSocket-Key 헤더: 핸드쉐이크에 필요한 키</li> <li>Set-WebSocket-Protocol 헤더: 사용하는 서브 프로토콜(커넥션을 여러개로 구분할 때 사용)</li></ul></li> <li><p>핸드쉐이크/리스폰스: 웹소켓 리퀘스트에 대한 리스폰스는 상태코드 101 Switching Protocols</p> <ul><li>Sec-WebSocket-Accept 헤더: Sec-WebSocket-Key 헤더 값으로 부터 생성된 값이 저장된다</li> <li>웹소켓 연결이 확립되면 HTTP가 아닌 웹소켓 독자 데이터 프레임으로 통신한다</li></ul></li></ul> <p>JavaScript에서 WebSocket 프로토콜을 사용하기위해 W3C 사양인 WebSocket 인터페이스를 사용한다</p> <h3 id="webdav"><a href="#webdav" class="header-anchor">#</a> WebDAV</h3> <p>Web-based Distributed Authoring and Versioning은
웹서버의 콘텐츠를 직접 복사/편집할 수 있는 HTTP/1.1 확장 프로토콜이다.</p> <p>서버상의 리소스에 대해 WebDAV에서 새롭게 추가된 개념은 다음이 있다</p> <ul><li>Collection: 여러개의 리소스를 한꺼번에 관리하기 위한 개념</li> <li>Resource: 파일이나 컬렉션을 리소스라 칭함</li> <li>Property: 리소스의 프로퍼티를 정의한 것 (<code>이름=값</code>)</li> <li>Lock: 파일을 편집할 수 없는 상태</li></ul> <p>WebDAV에서 추가된 메소드는 다음과 같다</p> <ul><li>PROPFIND: 프로퍼티 취득</li> <li>PROPPATCH: 프로퍼티 변경</li> <li>MKCOL: 컬렉션 작성</li> <li>COPY: 리소스 및 프로퍼티 복제</li> <li>MOVE: 리소스 이동</li> <li>LOCK: 리소스 잠금</li> <li>UNLOCK: 리소스 잠금 해제</li></ul> <p>WebDAV에서 확장된 상태코드는 다음과 같다</p> <ul><li>102 Processing: 리퀘스트는 수신하였으나 처리중이다</li> <li>207 Multi-Status: 복수의 상태</li> <li>422 Unprocessable Entity: 서식은 맞지만 내용은 틀리다</li> <li>423 Locked: 리소스가 잠겨있다</li> <li>424 Failed Dependency: 리퀘스트와 연관된 리퀘스트가 실패했다</li> <li>507 Insufficient Storage: 기억영역이 부족하다</li></ul> <h2 id="웹-공격기술"><a href="#웹-공격기술" class="header-anchor">#</a> 웹 공격기술</h2> <p>HTTP는 보안과 관련된 기능이 없으며,
리퀘스트가 탈취되어 쿼리, 폼, 헤더, 쿠키등의 정보에 포함된 취약점 공격을 받을 수 있다</p> <p>애플리케이션의 보안을 점검해야 하는 위치는 다음과 같다</p> <ul><li><p>클라이언트</p></li> <li><p>서버</p> <ul><li>서버의 입력값</li> <li>서버의 출력값</li></ul></li></ul> <p>클라이언트 체크는 변조되거나 무효화 될 가능성이 있으므로 근본적인 보안 대책이 될 수 없다.</p> <h3 id="xss-cross-site-scripting"><a href="#xss-cross-site-scripting" class="header-anchor">#</a> XSS (Cross-Site Scripting)</h3> <p>취약성이 있는 웹사이트를 방문한 사용자의 브라우저에서 공격을 위한 HTML 태그나 JavaScript등을 동작시키는 공격이다.</p> <p>공격자가 작성한 스크립트가 유저의 브라우저 상에서 작동하는 수동적 공격이다.</p> <p>다음과 같은 경우에 발생할 수 있다</p> <ul><li>가짜 입력 폼 등에 의해 유저의 개인 정보를 도둑 맞는다</li> <li>스크립트에 의해 유저의 쿠키 값이 도둑맞거나 피해자가 의도하지 않은 리퀘스트가 송신된다</li> <li>가짜 문장이나 이미지 등이 표시된다</li></ul> <h3 id="sql-injection"><a href="#sql-injection" class="header-anchor">#</a> SQL Injection</h3> <p>웹어플리케이션에서 이용하고 있는 데이터베이스에 SQL을 부적절하게 실행하는 공격이다.</p> <p>SQL문에 전달될 데이터에 SQL문의 취약점을 공격할 수 있는 문자열을 넣어서 보낸다</p> <ul><li><code>--</code>를 사용하여 주어진 문자열 이후의 statement를 주석처리하여 무효화 할 수 있다</li> <li><code>and 1 = 1</code>과 같은 항상 true인 조건을 보내 조건 처리를 무효화 할 수 있다</li></ul> <p>이외에도 여러가지 공격 방식이 존재한다</p> <h3 id="os-command-injection"><a href="#os-command-injection" class="header-anchor">#</a> OS Command Injection</h3> <p>웹 애플리케이션에게 부적절한 OS 명령어를 보내 실행하는 것이다.</p> <p>쉘을 호출하는 함수가 있는 경우라면 공격에 노출 될 수 있다.</p> <h3 id="http-header-injection"><a href="#http-header-injection" class="header-anchor">#</a> HTTP Header Injection</h3> <p>리스폰스 헤더 필드에 개행 문자등을 삽입하여 임의의 리스폰스 헤더 필드나 바디를 추가하는 공격이다.</p> <p>예를 들어, 링크를 클릭하면 Location 헤더 필드가 바뀌면서 리다이렉트 되는 경우,
쿼리 스트링에 개행문자와 공격을 위한 헤더를 추가할 수 있다</p> <p><code>%0D%0A(개행문자)Set-Cookie: SID=123456789</code></p> <p>또는 개행문자를 연속하여 두 개 입력하여(<code>%0D%0A%0D%0A</code>)
HTTP 헤더와 바디의 경계선으로 인식하도록 하고 가짜 바디를 보낼 수 있다.</p> <h3 id="mail-header-injection"><a href="#mail-header-injection" class="header-anchor">#</a> Mail Header Injection</h3> <p>웹 어플리케이션의 메일 송신 기능에 임의의 To, Subject 등의 메일 헤더를 추가하는 공격이다.</p> <p>마찬가지로 메일헤더에서 개행문자인 (<code>%0D%0A</code>)를 입력하여 헤더추가, 본문변조등을 시도할 수 있다.</p> <h3 id="directory-traversal"><a href="#directory-traversal" class="header-anchor">#</a> Directory Traversal</h3> <p>웹 어플리케이션의 파일을 조작하는 처리에서 외부 파일이름을 지정하여 처리하는 경우에
처리가 취약하면 파일의 상대경로나, 절대경로 입력을 통해 임의의 파일/디렉토리에 액세스 할 수 있다.</p> <p>예를 들어, 쿼리스트링에 직접 읽어올 파일명을 지정하는 경우 파일이름 대신 경로를 요청할 수 있다</p> <p><code>http://example.com/read?file=../../etc/passwd</code></p> <h3 id="remote-file-inclusion"><a href="#remote-file-inclusion" class="header-anchor">#</a> Remote File Inclusion</h3> <p>스크립트의 일부를 다른 파일에서 읽어올 때
공격자가 지정한 외부 서버의 URL을 파일에서 읽게 하여 임의의 스크립트를 동작시키는 경우이다.</p> <h3 id="forced-browsing"><a href="#forced-browsing" class="header-anchor">#</a> Forced Browsing</h3> <p>웹 서버의 공개 디렉토리 중에서 공개의도가 없는 파일이 노출되는 경우이다</p> <h3 id="부적절한-에러-메시지-처리"><a href="#부적절한-에러-메시지-처리" class="header-anchor">#</a> 부적절한 에러 메시지 처리</h3> <p>웹 애플리케이션이나 데이터베이스의 에러메시지가 출력되어 공격자에게 유리한 내용이 표시되는 경우이다</p> <h3 id="open-redirect"><a href="#open-redirect" class="header-anchor">#</a> Open Redirect</h3> <p>파라미터로 리다이렉트할 URL을 지정하는 기능을 사용하는 경우 발생할 수 있다</p> <h3 id="session-hijack"><a href="#session-hijack" class="header-anchor">#</a> Session Hijack</h3> <p>공격자가 다른 유저의 세션ID를 탈취해서 약용하는 것으로 다른 유저로 위장한 공격을 하게된다</p> <p>XSS와 같은 취약점 공격으로 쿠키에 포함된 세션ID를 탈취하여 공격자의 헤더에 세션 ID를 포함할 수 있다.</p> <h3 id="session-fixation"><a href="#session-fixation" class="header-anchor">#</a> Session Fixation</h3> <p>지정한 세션 ID를 유저에게 강제적으로 사용하게 하는 공격방식이다</p> <p>미리 준비한 세션을 유저가 사용하도록 유도하고,
유저가 해당 세션에서 인증을 하면 인증된 세션으로 공격자가 접근하는 방식이다.</p> <h3 id="cross-site-request-forgeries"><a href="#cross-site-request-forgeries" class="header-anchor">#</a> Cross-Site Request Forgeries</h3> <p>인증된 유저가 개인정보나 설정정보 등을 공격자가 설치해둔 함정을 통해 작동시키는 공격이다.</p> <ul><li>인증된 유저 권한으로 설정 정보를 갱신</li> <li>인증된 유저 권한으로 상품을 구입</li> <li>인증된 유저 권한으로 게시물 작성</li></ul> <p>등이 발생할 수 있다.</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/wiki/assets/js/app.92ee9d6a.js" defer></script><script src="/wiki/assets/js/2.9f07087a.js" defer></script><script src="/wiki/assets/js/159.c34e728e.js" defer></script>
  </body>
</html>
