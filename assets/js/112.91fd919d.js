(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{483:function(e,t,o){"use strict";o.r(t);var r=o(28),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"javascript-symbol-type"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#javascript-symbol-type"}},[e._v("#")]),e._v(" JavaScript Symbol Type")]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Glossary/Symbol",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developer.mozilla.org/en-US/docs/Glossary/Symbol"),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"http://hacks.mozilla.or.kr/2015/09/es6-in-depth-symbols/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://hacks.mozilla.or.kr/2015/09/es6-in-depth-symbols/"),o("OutboundLink")],1)])]),e._v(" "),o("p",[o("code",[e._v("Symbol")]),e._v("은 ES6에서 추가된 primitive type이다.")]),e._v(" "),o("p",[o("strong",[e._v("심볼")]),e._v(" 원시 데이터 타입(primitive data type)은,\n클래스나 객체 형식(objet type)의 내부에서만 접근할 수 있도록 전용(private) 객체 속성의 키(key)로 사용된다.")]),e._v(" "),o("h2",{attrs:{id:"필요성"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#필요성"}},[e._v("#")]),e._v(" 필요성")]),e._v(" "),o("p",[e._v("객체를 구분하기 위해서 속성 구분자를 사용할 수도 있다. (예: 속성 중 "),o("code",[e._v("isKorean")]),e._v(")\n그러나 속성을 추가했을 때 발생할 수 있는 문제가 있다.")]),e._v(" "),o("ul",[o("li",[e._v("프로퍼티를 순회하는 "),o("code",[e._v("for..in")]),e._v(", "),o("code",[e._v("Object.keys()")]),e._v(", "),o("code",[e._v("Object.entries()")]),e._v(" 등을 사용했을 때 해당 프로퍼티가 잘못 사용될 수 있다")]),e._v(" "),o("li",[e._v("다른 라이브러리와 충돌할 수 있다")]),e._v(" "),o("li",[e._v("자바스크립트 표준에 해당 프로퍼티가 추가될 수 있다")])]),e._v(" "),o("p",[e._v("이를 해결하기 위해 이름 충돌 위험없이 프로퍼티 key 값으로 사용할 수 있는 값이 Symbol 값이다.")]),e._v(" "),o("p",[e._v("예를 들어, "),o("code",[e._v("iterator")]),e._v("를 사용하려면 "),o("code",[e._v("for..of")]),e._v(" 반복문을 사용하는데, 반복문에서는 "),o("code",[e._v("[Symbol.iterator]()")]),e._v(" 메소드를 호출한다.\n단순히 "),o("code",[e._v("iterator()")]),e._v(" 메소드를 추가해서 사용하지 않고 심볼을 사용하면 기존 코드와 충돌을 회피할 수 있다(하위 호환성 보장).")]),e._v(" "),o("h2",{attrs:{id:"사용"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#사용"}},[e._v("#")]),e._v(" 사용")]),e._v(" "),o("p",[e._v("심볼은 고유하고 다른 심볼과 구별된다. (동일한 description이 있더라도 다른 심볼이다)\n심볼은 생성되면 변경되지 않고, 속성을 부여할 수 없다. 또한 "),o("code",[e._v("string")]),e._v("으로 자동 변환되지 않는다.")]),e._v(" "),o("ul",[o("li",[o("p",[o("code",[e._v("Symbol()")])]),e._v(" "),o("ul",[o("li",[o("code",[e._v("new")]),e._v(" 키워드로 생성자를 호출하지 않고, 함수만을 호출한다(class-like)")]),e._v(" "),o("li",[e._v("호출마다 새 고유한 심볼(동적으로 익명의 고유한 값)을 반환한다")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Symbol.for(string)")])]),e._v(" "),o("ul",[o("li",[e._v("symbol registry(global symbol table)를 참고하여 심볼을 반환한다")]),e._v(" "),o("li",[e._v("레지스트리에 호출한 심볼이 존재하면 존재하는 심볼을 반환한다")]),e._v(" "),o("li",[e._v("레지스트리에 호출한 심볼이 존재하지 않는다면 생성하여 레지스트리에 등록하고 반환한다")])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("Symbol.keyFor(symbol)")])]),e._v(" "),o("ul",[o("li",[e._v("symbol을 symbol registry(global symbol table)에서 찾은 뒤 "),o("code",[e._v("shared symbol key")]),e._v("를 반환한다")])])]),e._v(" "),o("li",[o("p",[e._v("표준 "),o("code",[e._v("Symbol")]),e._v(" 사용")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("Symbol.iterator")]),e._v(", "),o("code",[e._v("Symbol.asyncIterator")]),e._v(", "),o("code",[e._v("Symbol.search")]),e._v(" 처럼 언어 내장 Symbol을 바로 사용할 수 있다")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://tc39.es/ecma262/#sec-well-known-symbols",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://tc39.es/ecma262/#sec-well-known-symbols"),o("OutboundLink")],1)])])])]),e._v(" "),o("h2",{attrs:{id:"가시성"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#가시성"}},[e._v("#")]),e._v(" 가시성")]),e._v(" "),o("ul",[o("li",[e._v("비열거형이기 때문에 "),o("code",[e._v("for..in")]),e._v(" 반복문 내에서 멤버로 사용될 수 없다")]),e._v(" "),o("li",[e._v("속성이 익명이기 때문에 "),o("code",[e._v("Object.getOwnPropertyNames()")]),e._v("가 반환하는 배열에 들어갈 수 없다")]),e._v(" "),o("li",[e._v("심볼 속성 접근은 알고있는 심볼 값을 직접 이용하거나 "),o("code",[e._v("Object.getOwnPropertySymbols()")]),e._v("가 반환하는 배열을 사용한다")])]),e._v(" "),o("h2",{attrs:{id:"언어상-사례"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#언어상-사례"}},[e._v("#")]),e._v(" 언어상 사례")]),e._v(" "),o("h3",{attrs:{id:"instanceof-확장"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#instanceof-확장"}},[e._v("#")]),e._v(" "),o("code",[e._v("instanceof")]),e._v(" 확장")]),e._v(" "),o("p",[e._v("ES6에서, "),o("code",[e._v("object instanceof constructor")]),e._v(" 구문은 생성자(constructor)의 메소드인 "),o("code",[e._v("constructor[Symbol.hasInstance](object)")]),e._v("로 규정됨")]),e._v(" "),o("h3",{attrs:{id:"새로운-종류의-문자열-검색-string-matching-을-지원"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#새로운-종류의-문자열-검색-string-matching-을-지원"}},[e._v("#")]),e._v(" 새로운 종류의 문자열 검색(string-matching)을 지원")]),e._v(" "),o("p",[e._v("ES6에서 "),o("code",[e._v("str.match(myObject)")]),e._v(" 코드는 우선 "),o("code",[e._v("myObject")]),e._v("가 "),o("code",[e._v("myObject[Symbol.match](str)")]),e._v(" 메소드를 갖고 있는지 확인한다.")]),e._v(" "),o("p",[e._v("심볼로 정의된 메소드로 "),o("code",[e._v("RegExp")]),e._v(" 객체가 사용되는 모든 곳에 커스텀 문자열 파싱(string-parsing)을 제공할 수 있다.")]),e._v(" "),o("h3",{attrs:{id:"새로운-기능과-이전-코드의-충돌-방지"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#새로운-기능과-이전-코드의-충돌-방지"}},[e._v("#")]),e._v(" 새로운 기능과 이전 코드의 충돌 방지")]),e._v(" "),o("p",[e._v("새로운 기능이 추가되었을 때동작 오류의 주요 원인은 동적 스코핑(dynamic scoping) 기능 때문이었다.")]),e._v(" "),o("p",[e._v("웹 표준은 "),o("code",[e._v("Symbol.unscopables")]),e._v("을 이용해서 특정 메소드들이 동적 스코핑에 관여되는 것을 방지한다.")])])}),[],!1,null,null,null);t.default=v.exports}}]);