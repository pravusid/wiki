(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{502:function(v,_,t){"use strict";t.r(_);var i=t(28),a=Object(i.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"컴파일러"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#컴파일러"}},[v._v("#")]),v._v(" 컴파일러")]),v._v(" "),t("h2",{attrs:{id:"컴파일러-개요"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#컴파일러-개요"}},[v._v("#")]),v._v(" 컴파일러 개요")]),v._v(" "),t("ul",[t("li",[v._v("원시 프로그램 -> 번역기 -> 목적 프로그램")]),v._v(" "),t("li",[v._v("어셈블리어 프로그램 -> 어셈블러 -> 기계어 프로그램")]),v._v(" "),t("li",[v._v("고급언어 프로그램 -> 컴파일러 -> 어셈블리어/기계어 프로그램")]),v._v(" "),t("li",[v._v("고급언어 프로그램 -> 프리프로세서 -> 고급언어 프로그램")]),v._v(" "),t("li",[v._v("고급언어 프로그램 -> 인터프리터 -> 실행결과")])]),v._v(" "),t("p",[v._v("컴파일러는 목적코드에 따라 다음으로 분류할 수 있다")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("native compiler")]),v._v(" "),t("ul",[t("li",[v._v("일반적으로 사용되는 컴파일러")]),v._v(" "),t("li",[v._v("컴파일러가 목적코드를 생산하고 나면 목적코드는 바로 컴퓨터에서 실행된다")])])]),v._v(" "),t("li",[t("p",[v._v("cross compiler")]),v._v(" "),t("ul",[t("li",[v._v("임베디드 프로그램처럼 목적코드가 다른 컴퓨터나 운영체제에서 실행되도록 번역")])])]),v._v(" "),t("li",[t("p",[v._v("bytecode compiler")]),v._v(" "),t("ul",[t("li",[v._v("Java 언어가 대표적이다")]),v._v(" "),t("li",[v._v("원시프로그램을 자바 바이트 코드 형태로 번역한다")]),v._v(" "),t("li",[v._v("바이트코드는 자바 가상 머신에서 실행될 수 있는 코드이다")])])])]),v._v(" "),t("h3",{attrs:{id:"인터프리터"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#인터프리터"}},[v._v("#")]),v._v(" 인터프리터")]),v._v(" "),t("p",[v._v("인터프리터의 처리과정을 보면, 고급언어로 작성된 원시 프로그램을 중간코드로 변환하고,\n변환된 중간코드를 명령어 단위로 가져다가 디코드하고 실행을 한다.")]),v._v(" "),t("p",[v._v("그리고 명령어의 주소를 하나 늘린 후, 다음 명령어를 가져온다.")]),v._v(" "),t("ul",[t("li",[v._v("시작")]),v._v(" "),t("li",[v._v("다음 명령어 호출(fetch)")]),v._v(" "),t("li",[v._v("명령어 디코드(decode)")]),v._v(" "),t("li",[v._v("지정된 피연산자 호출\n"),t("ul",[t("li",[v._v("원시연산 실행\n"),t("ul",[t("li",[v._v("명령어 주소 하나 증가 "),t("code",[v._v("(다음)")])])])]),v._v(" "),t("li",[v._v("실행중지 연산 "),t("code",[v._v("(종료)")])]),v._v(" "),t("li",[v._v("지정된 연산으로 분기\n"),t("ul",[t("li",[v._v("원시연산 실행")]),v._v(" "),t("li",[v._v("명령어 주소 하나 증가 "),t("code",[v._v("(다음)")])])])])])])]),v._v(" "),t("h3",{attrs:{id:"컴파일러의-논리적-구조"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#컴파일러의-논리적-구조"}},[v._v("#")]),v._v(" 컴파일러의 논리적 구조")]),v._v(" "),t("ul",[t("li",[v._v("원시 프로그램")]),v._v(" "),t("li",[v._v("어휘분석")]),v._v(" "),t("li",[v._v("구문분석")]),v._v(" "),t("li",[v._v("의미분석")]),v._v(" "),t("li",[v._v("중간코드 생성")]),v._v(" "),t("li",[v._v("코드최적화")]),v._v(" "),t("li",[v._v("목적코드생성")]),v._v(" "),t("li",[v._v("목적프로그램")])]),v._v(" "),t("h4",{attrs:{id:"어휘분석-lexical-analysis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#어휘분석-lexical-analysis"}},[v._v("#")]),v._v(" 어휘분석 (lexical analysis)")]),v._v(" "),t("p",[v._v("어휘분석 단계에서는 원시 프로그램을 읽어 문장을 구성하고 있는 최소 단위인 어휘들을 떼어,\n이 어휘들이 올바른지 분석하는 일을 한다.")]),v._v(" "),t("p",[v._v("따라서 모든 어휘를 정의한 문법(grammar)이 필요하다.\n어휘분석 단계에서 문법에 의해 어휘가 분석되는데 올바르지 않으면 오류메시지가 출력되고,\n올바른 경우 token 형태로 출력된다.")]),v._v(" "),t("p",[v._v("어휘 토큰은 의미 있는 최소의 문법적 단위(syntactic entity)가 되고,\n이와 같은 일을 하는 것을 어휘분석기(lexical analyzer) 혹은 스캐너(scanner)라 한다.")]),v._v(" "),t("p",[v._v("토큰은 예약어(reserved word)나 상수(constant), 연산자(operator), 식별자(identifier),\n괄호/따옴표/세미콜론등의 구분자(delimiter)등이 있다.")]),v._v(" "),t("h4",{attrs:{id:"구문분석-syntax-analysis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#구문분석-syntax-analysis"}},[v._v("#")]),v._v(" 구문분석 (syntax analysis)")]),v._v(" "),t("p",[v._v("구문분석 혹은 파싱(parsing)이라고 하며,\n구문분석기(syntax analyzer) 혹은 파서(parser)가\n어휘분석 결과인 토큰을 입력받아 이어지는 토큰들이 올바른 문장구조를 갖고 있는지 검사한다.")]),v._v(" "),t("p",[v._v("구문분석 단계에서도 문장구조를 정의할 문법이 필요하다.")]),v._v(" "),t("p",[v._v("문장을 정의한 문법에 맞는지 분석하는데,\n올바른 문장에 대해서는 문장에 대한 구문구조(syntatic structure)를 만들어 출력하고\n올바르지 않은 문장에 대해서는 오류메시지를 출력한다.")]),v._v(" "),t("p",[v._v("구문구조는 토큰들을 단말노드(terminal node)로 하는 tree 형태로 표현되는데,\n이 트리를 parse tree라 한다.")]),v._v(" "),t("p",[v._v("parse tree는 중간코드 생성단계에서 이용된다.\nparse tree에서 불필요한 정보인 식별자, 숫자, 식 등을 제거하고\n다음 단계에서 필요한 정보만으로 구성된 트리를 구문트리(syntax tree)라고 한다.")]),v._v(" "),t("h4",{attrs:{id:"의미분석-semantic-analysis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#의미분석-semantic-analysis"}},[v._v("#")]),v._v(" 의미분석 (semantic analysis)")]),v._v(" "),t("p",[v._v("구문트리에 어떤 의미가 있고 어떤 기능을 수행하는지 분석하고,\n수행환경을 조성하는 것을 의미분석기 (semantic analyzer)라 한다.")]),v._v(" "),t("p",[v._v("구문트리를 보며 산술식과 각 문장의 연산자 및 피연산자를 인식하고 type checking 등을 한다.")]),v._v(" "),t("h4",{attrs:{id:"중간코드-생성-intermediate-code-generation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#중간코드-생성-intermediate-code-generation"}},[v._v("#")]),v._v(" 중간코드 생성 (intermediate code generation)")]),v._v(" "),t("p",[v._v("중간코드 생성은 구문분석 단계에서 만들어진 구문트리를 이용하여 코드를 생성하거나,\n구문지시적변환(syntax-directed translation)으로 이루어진다.")]),v._v(" "),t("p",[v._v("구문지시적 변환은 문법규칙이 reduce될 때 그 규칙에 맞는 코드생성 루틴을 부름으로써\n중간코드 생성기(intermediate code generator)에 의해 중간코드를 생성한다.")]),v._v(" "),t("p",[t("code",[v._v("ABC := E * 3.14 + ABC / E")]),v._v("는 구문분석에서 얻어진 parse tree에 의해 다음과 같은 quadruple 중간코드를 얻는다")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("중간코드")]),v._v(" "),t("th",[v._v("의미")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[t("code",[v._v("(*, E, 3.14, T0)")])]),v._v(" "),t("td",[t("code",[v._v("T0 = E * 3.14")])])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("(/, ABC, E, T1)")])]),v._v(" "),t("td",[t("code",[v._v("T1 = ABC / E")])])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("(+, T0, T1, T2)")])]),v._v(" "),t("td",[t("code",[v._v("T2 = T0 + T1")])])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("(:=, T2, Φ, ABC)")])]),v._v(" "),t("td",[t("code",[v._v("ABC := T2")])])])])]),v._v(" "),t("h4",{attrs:{id:"코드최적화-code-optimization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#코드최적화-code-optimization"}},[v._v("#")]),v._v(" 코드최적화 (code optimization)")]),v._v(" "),t("p",[v._v("코드를 효율적으로 만들어 코드 실행시 기억공간이나 실행시간을 절약하기 위한 단계이다.")]),v._v(" "),t("p",[v._v("최적화는 방법에 따라 여러가지로 나눌 수 있다")]),v._v(" "),t("ul",[t("li",[v._v("Local(Peephole) optimization / Global optimization")]),v._v(" "),t("li",[v._v("단일문 최적화 / Loop 문장에서 최적화")]),v._v(" "),t("li",[v._v("실행속도 최적화 / 기억장소 최적화")])]),v._v(" "),t("p",[v._v("지역최적화란 부분적인 관점에서 비효율적인 코드를 구분해내고, 이를 효율적으로 수정한다")]),v._v(" "),t("ul",[t("li",[v._v("중복된 LOAD, STORE 명령문 제거")]),v._v(" "),t("li",[v._v("불필요한 코드 제거")]),v._v(" "),t("li",[v._v("제어흐름 최적화")]),v._v(" "),t("li",[v._v("식(expression)의 대수학적 간소화(algebraic simplication)")]),v._v(" "),t("li",[v._v("연산의 세기경감(strenth reduction)")]),v._v(" "),t("li",[v._v("상수전파(constant propagation)")]),v._v(" "),t("li",[v._v("복사전파(copy propagation)")]),v._v(" "),t("li",[v._v("공통부분식(common subexpression) 제거")]),v._v(" "),t("li",[v._v("결합 변형")]),v._v(" "),t("li",[v._v("...")])]),v._v(" "),t("p",[v._v("전역최적화는 전체적인 관점에서 보다 효율적인 코드로 수정한다")]),v._v(" "),t("ul",[t("li",[v._v("코드 이동(code motion)")]),v._v(" "),t("li",[v._v("귀납변수(induction variable) 최적화")]),v._v(" "),t("li",[v._v("루프융합(loop fusion)")]),v._v(" "),t("li",[v._v("루프전개(loop unrolling)")]),v._v(" "),t("li",[v._v("...")])]),v._v(" "),t("h4",{attrs:{id:"목적코드-생성-code-generation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#목적코드-생성-code-generation"}},[v._v("#")]),v._v(" 목적코드 생성(code generation)")]),v._v(" "),t("p",[v._v("컴파일 과정의 마지막 단계로 연산을 수행할 레지스터를 선택하거나 자료에 기억장소의 위치를 정해주며,\n실제로 목적기계어에 대한 코드를 생성하는 단계이다.")]),v._v(" "),t("p",[v._v("중간 코드 생성 단계에서 만들어진 중간코드들을 기계명령어(machine instruction)으로 바꾸어준다")]),v._v(" "),t("h3",{attrs:{id:"컴파일러의-물리적-구조"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#컴파일러의-물리적-구조"}},[v._v("#")]),v._v(" 컴파일러의 물리적 구조")]),v._v(" "),t("p",[v._v("컴파일러의 논리적 구조를 실제로 구현하는 경우 물리적 구조는 논리적 구조와 반드시 일치하지는 않는다.")]),v._v(" "),t("p",[v._v("컴파일러 구현에서는 여러단계를 모아서 하나의 모듈로 묶을 수 있는데, 이를 pass라 한다.\n컴파일러의 구현방법으로는 크게 두 가지가 있다.")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("one-pass compiler: 컴파일러의 전 과정을 하나의 패스로 구현")]),v._v(" "),t("ul",[t("li",[v._v("초창기의 컴파일러")]),v._v(" "),t("li",[v._v("forward jump 처리를 위해 빈칸으로 남긴 부분을 backpatching으로 채움")]),v._v(" "),t("li",[v._v("효율성이 좋고 실행속도가 빠르다")])])]),v._v(" "),t("li",[t("p",[v._v("two-pass compiler: 컴파일러의 구성을 중간코드를 기점으로 하여, 전/후반부로 구분함")]),v._v(" "),t("ul",[t("li",[v._v("전반부: 어휘분석, 구문분석, 중간코드 생성")]),v._v(" "),t("li",[v._v("후반부: 코드최적화, 목적코드 생성")]),v._v(" "),t("li",[v._v("기계코드 표현에 제약을 받고 실행속도가 느리다")]),v._v(" "),t("li",[v._v("이식성이 좋고 중간코드를 이용하여 최적화 하므로 기계와 독립적인 최적화 가능")]),v._v(" "),t("li",[v._v("하나의 패스가 사용했던 공간을 재사용하므로 기억장소 절약 가능")])])])]),v._v(" "),t("h3",{attrs:{id:"간단한-컴파일러"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#간단한-컴파일러"}},[v._v("#")]),v._v(" 간단한 컴파일러")]),v._v(" "),t("p",[t("code",[v._v("ABC := E * 3.14 + ABC / E")])]),v._v(" "),t("p",[v._v("문제를 간단히 하기 위해 조건을 한정하자")]),v._v(" "),t("ul",[t("li",[v._v("연산결과를 저장하는 누산기는 1개")]),v._v(" "),t("li",[v._v("연산자인 곱셈, 나눗셈이 덧셈, 뺄셈보다 연산순위가 높다")]),v._v(" "),t("li",[v._v("연산자인 덧셈, 뺄셈은 치환연산자 (:=)보다 연산순위가 높다")])]),v._v(" "),t("p",[v._v("순서는 다음과 같다")]),v._v(" "),t("ul",[t("li",[v._v("컴파일러는 입력장치를 통해 원시 프로그램 string을 기억장치로 읽어 들인다")]),v._v(" "),t("li",[v._v("기억장치 내에 있는 문자의 열을 한 문자씩 왼쪽부터 scanning 한다")]),v._v(" "),t("li",[v._v("공백은 건너뛰고, 처음 토큰부터 어휘분석기로 종류를 판별한다")]),v._v(" "),t("li",[v._v("식별자를 판별하면 기호표에 기록한다 (변수, 상수 ...)")]),v._v(" "),t("li",[v._v("토큰에대한 식별번호를 기록한다")]),v._v(" "),t("li",[v._v("피연산자 || 연산자 스택에 기록한다")]),v._v(" "),t("li",[v._v("연산자 스택에 이미 자료가 있다면 연산자 우선순위를 비교한다")])]),v._v(" "),t("p",[v._v("스택의 TOP 연산자가 우선순위가 높다면(연산처리)")]),v._v(" "),t("ul",[t("li",[v._v("연산자 스택의 TOP 요소와 피연산자 스택 요소 2개를 꺼내 연산한다")]),v._v(" "),t("li",[v._v("누산기의 계수기를 통해 다른 연산결과가 저장되어 있는지 확인한다\n"),t("ul",[t("li",[v._v("다른 결과가 있다면 누산기를 사용하기 위해서 내용을 임시저장소에 저장해야 한다")]),v._v(" "),t("li",[v._v("누산기 계수기를 따라가 임시기억장소인 작업용 번지의 주소로 교체한다")])])]),v._v(" "),t("li",[v._v("누산기의 식별번호를 피연산자 스택에 넣는다")]),v._v(" "),t("li",[v._v("누산기의 계수기에 피연산자 스택의 번지를 저장한다")]),v._v(" "),t("li",[v._v("누산자 계수기를 증가시킨다")])]),v._v(" "),t("p",[v._v("현재 연산자가 우선순위가 높다면: 연산자 스택에 기록한다")]),v._v(" "),t("p",[v._v("위와 같은 과정을 반복한고, 문장이 끝났다는 구분자 "),t("code",[v._v(";")]),v._v("를 만나면 스택을 정리하기 시작한다")]),v._v(" "),t("p",[v._v("스택정리는 연산처리 부분을 반복하며 이루어진다")]),v._v(" "),t("h2",{attrs:{id:"형식언어와-오토마타"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#형식언어와-오토마타"}},[v._v("#")]),v._v(" 형식언어와 오토마타")]),v._v(" "),t("h3",{attrs:{id:"형식언어의-기초"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#형식언어의-기초"}},[v._v("#")]),v._v(" 형식언어의 기초")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("알파벳 < 문자열 < 형식언어")])]),v._v(" "),t("li",[t("p",[v._v("형식언어(formal language): 어떤 알파벳에서 얻은 symbol들로 구성되는 문자열들의 집합")])]),v._v(" "),t("li",[t("p",[v._v("알파벳: 기호들의 유한집합")])]),v._v(" "),t("li",[t("p",[v._v("문자열: 알파벳을 구성하는 기호가 0 또는 1개 이상 나열(sequence)된 것")])]),v._v(" "),t("li",[t("p",[v._v("문자열의 길이: 문자열을 이루는 기호들의 개수를 문자열 길이(cardinality)라 하고 "),t("code",[v._v("|w|")]),v._v("로 표시한다")])]),v._v(" "),t("li",[t("p",[v._v("공문자열: 문자열의 길이가 0인 것을 공문자열(empty string)이라고 한다")])]),v._v(" "),t("li",[t("p",[t("code",[v._v("T*")]),v._v(" (star closure): 공문자열을 포함하여, T에 속하는 기호들로 이루어질 수 있는 모든 문자열의 집합")])]),v._v(" "),t("li",[t("p",[t("code",[v._v("T+")]),v._v(" (positive closure): "),t("code",[v._v("T*")]),v._v("에서 공문자열을 제외한 모든 문자열의 집합을 나타낸다")])])]),v._v(" "),t("p",[v._v("앞의 정의들로 언어(language)를 정의하면")]),v._v(" "),t("blockquote",[t("p",[v._v("알파벳 T에 대한 언어 L은 "),t("code",[v._v("T*")]),v._v("의 부분집합이다")])]),v._v(" "),t("h3",{attrs:{id:"형식문법"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#형식문법"}},[v._v("#")]),v._v(" 형식문법")]),v._v(" "),t("p",[v._v("형식문법이란 형식언어를 생성하기 위한 규칙들로 다음과 같이 정의할 수 있다")]),v._v(" "),t("ul",[t("li",[v._v("형식문법 "),t("code",[v._v("G = (Vn, Vt, P, S)")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("Vn")]),v._v(": 논터미널 기호들의 유한집합")]),v._v(" "),t("li",[t("code",[v._v("Vt")]),v._v(": 터미널 기호들의 유한집합")]),v._v(" "),t("li",[t("code",[v._v("P")]),v._v(": 생성규칙의 집합: "),t("code",[v._v("a -> b")]),v._v(", "),t("code",[v._v("a ∈ V+")]),v._v(", "),t("code",[v._v("b ∈ V*")])]),v._v(" "),t("li",[t("code",[v._v("S")]),v._v(": "),t("code",[v._v("Vn")]),v._v("에 속하는 기호로 다른 논터미널과 구별하여 시작기호라고 한다")])])])]),v._v(" "),t("p",[v._v("기호들의 일반적인 표기법을 나타내면 다음과 같다.")]),v._v(" "),t("ul",[t("li",[v._v("A, B, C 와 같은 영문자 대문자로 구성된 기호와 시작기호를 나타내는 S는 논터미널 기호이다")]),v._v(" "),t("li",[t("code",[v._v("<")]),v._v("와 "),t("code",[v._v(">")]),v._v("로 묶어서 나타낸 기호도 논터미널 기호이다")]),v._v(" "),t("li",[v._v("a, b, c와 같은 영문자 소문자로 구성된 기호와 +, -와 같은 연산자기호, 괄호나 쉼표와 같은 구분자, 0, 1, 2와 같은 아라비아 숫자들은 터미널 기호이다")]),v._v(" "),t("li",[v._v("X, Y, Z와 같은 영문자 끝부분의 대문자는 터미널 기호와 논터미널 기호를 나타내는 문법기호이다")]),v._v(" "),t("li",[v._v("영문자 끝부분의 소문자인 u, v, w, x, y, z 등은 터미널 기호들로 이루어진 문자열을 나타낸다")]),v._v(" "),t("li",[v._v("α, β, γ와 같은 그리스어 소문자는 문법기호로 구성된 문자열을 나타낸다")]),v._v(" "),t("li",[v._v("아무런 언급이 없으면 첫 번재 생성규칙의 왼쪽에 있는 기호가 시작기호이다")])]),v._v(" "),t("h4",{attrs:{id:"chomsky-계층구조"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chomsky-계층구조"}},[v._v("#")]),v._v(" chomsky 계층구조")]),v._v(" "),t("p",[v._v("type0 > type1 > type2 > type3")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("type 0: α → β: 위축형 문법 포함: 튜링기계")])]),v._v(" "),t("li",[t("p",[v._v("type 1: α → β, |α| ≤ |β|: 비위축형 문법: linear-bounded 오토마타")])]),v._v(" "),t("li",[t("p",[v._v("type 2 (Context Free Grammar) <- BNF: A → γ, A ∈ Vn: 푸시다운 오토마타")])]),v._v(" "),t("li",[t("p",[v._v("type 3 (Regular Grammar): "),t("code",[v._v("non-terminal → [non-terminal]terminal")]),v._v(": 유한 오토마타")]),v._v(" "),t("ul",[t("li",[v._v("우선형(우측-B 증가): A → tB, A → t")]),v._v(" "),t("li",[v._v("좌선형(좌측-B 증가): A → Bt, A → t")])])])]),v._v(" "),t("h3",{attrs:{id:"정규표현"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#정규표현"}},[v._v("#")]),v._v(" 정규표현")]),v._v(" "),t("ul",[t("li",[v._v("Φ: 공집합")]),v._v(" "),t("li",[v._v("ε")]),v._v(" "),t("li",[v._v("a ∈ Vt: {a}")]),v._v(" "),t("li",[v._v("만일 P, Q가 정규언어 Lp, Lq를 표현하는 정규표현이라 하면\n"),t("ul",[t("li",[v._v("(P+Q): "),t("code",[v._v("a+b")])]),v._v(" "),t("li",[v._v("(P·Q): "),t("code",[v._v("ab")])]),v._v(" "),t("li",[v._v("(P*): "),t("code",[v._v("a*")]),v._v(", "),t("code",[v._v("(ab)*")]),v._v(", "),t("code",[v._v("(a+b)*")])])])])]),v._v(" "),t("h3",{attrs:{id:"정규언어와-유한-오토마타-finite-automata"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#정규언어와-유한-오토마타-finite-automata"}},[v._v("#")]),v._v(" 정규언어와 유한 오토마타 (Finite Automata)")]),v._v(" "),t("h4",{attrs:{id:"유한-오토마타"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#유한-오토마타"}},[v._v("#")]),v._v(" 유한 오토마타")]),v._v(" "),t("blockquote",[t("p",[v._v("문자열(w) -> 유한 오토마타 ("),t("code",[v._v("w ∈ L(T)")]),v._v(") -> Yes | No")])]),v._v(" "),t("p",[v._v("문자열 w를 입력받아서 w가 언어 L(T)의 문장이면 Yes를 답하고 그렇지 않으면 No를 답하는 프로그램이다")]),v._v(" "),t("p",[v._v("일반적으로 컴파일러 중에서 어휘분석기는 대표적인 유한 오토마타이다.")]),v._v(" "),t("p",[v._v("유한 오토마타를 표현하는 방법에는 다음 두 가지가 있다.")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("정의에 따라서 5가지의 구성원소를 형식에 맞게 정확히 표현하는 방법")]),v._v(" "),t("ul",[t("li",[v._v("Q: 상태들의 유한집합")]),v._v(" "),t("li",[v._v("Σ: 입력기호들의 유한집합")]),v._v(" "),t("li",[v._v("q0: 시작상태 또는 출발상태 (q0 ∈ Q)")]),v._v(" "),t("li",[v._v("F: 종료상태들의 집합 (F ∈ Q)")]),v._v(" "),t("li",[v._v("δ: 상태전이함수 (Q X Σ -> 2^Q(Q의 멱집합))")])])]),v._v(" "),t("li",[t("p",[v._v("상태전이도(transition diagram)라는 그림을 이용하여 비형식적으로 표현하는 방법")]),v._v(" "),t("ul",[t("li",[v._v("오토마타의 각 상태를 노드로 나타내는 그림")]),v._v(" "),t("li",[v._v("상태전이도에서는 상태 q에서 p로 가는 지시선 위에 a를 표기한다")]),v._v(" "),t("li",[v._v("종결상태는 이중 원으로 나타내고, 시작상태는 시작 지시선으로 표시하는 directed graph이다")])])])]),v._v(" "),t("h4",{attrs:{id:"dfa-결정적-유한-오토마타-nfa-비결정적-유한-오토마타"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dfa-결정적-유한-오토마타-nfa-비결정적-유한-오토마타"}},[v._v("#")]),v._v(" DFA(결정적 유한 오토마타) / NFA(비결정적 유한 오토마타)")]),v._v(" "),t("ul",[t("li",[v._v("DFA: 하나의 입력문자열에 대하여 오직 하나의 다음 상태가 결정되는 것")]),v._v(" "),t("li",[v._v("NFA: 어떤 상태에서 주어진 하나의 입력기호를 보고, 갈 수 있는 다음 상태가 하나 이상 존재할 수 있는 유한 오토마타이다")])]),v._v(" "),t("h4",{attrs:{id:"dfa와-nfa의-동치관계"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dfa와-nfa의-동치관계"}},[v._v("#")]),v._v(" DFA와 NFA의 동치관계")]),v._v(" "),t("p",[v._v("NFA는 언어의 구조를 쉽게 표현할 수 있는 반면, DFA보다 프로그램으로 구현하기 어렵다.\n따라서 일반적인 구현은 DFA로 하게되고 NFA에서 변환하게 된다.")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("ε-전이가 있는 NFA를 DFA로 변환")]),v._v(" "),t("ul",[t("li",[v._v("ε-closure(S): S가 한 개일 경우 S와 S로 부터 레이블이 ε인 지시선으로 도달할 수 있는 모든 상태의 집합")]),v._v(" "),t("li",[v._v("T가 하나 이상의 상태집합으로 되어 있는 경우에 ε-closure(T)는 T속에 있는 각 상태에 대해 위와 같은 방법으로 집합군은 구하여 합한것")]),v._v(" "),t("li",[v._v("변환\n"),t("ul",[t("li",[v._v("ε-NFA의 시작상태 q0에 대해 ε-closure(q0)를 구하고 ε-closure(q0)를 DFA의 시작상태로 놓는다")]),v._v(" "),t("li",[v._v("ε-closure(q0)의 원소들에 대해서 ε-NFA에 있는 ε을 제외한 각각의 입력기호에 대해 갈 수 있는 상태집합을 T1, T2 ...")]),v._v(" "),t("li",[v._v("ε-closure(T1), ε-closure(T2) ... 를 구하여 DFA의 새로운 상태로 만들고, 이전에 만들어진 상태면 지시선만 만든다")]),v._v(" "),t("li",[v._v("과정을 되풀이하여 새로운 상태가 나타나지 않을 때 까지 계속한다")]),v._v(" "),t("li",[v._v("만들어진 상태중에서 ε-NFA의 종료상태를 포함하는 상태는 모두 DFA의 종료상태가 된다")])])])])]),v._v(" "),t("li",[t("p",[v._v("ε-전이가 없는 NFA를 DFA로 변환")]),v._v(" "),t("ul",[t("li",[v._v("NFA에 의해서 인식되는 언어를 L이라 하면, L을 인식하는 DFA가 존재한다")]),v._v(" "),t("li",[v._v("L을 인식하는 NFA M = (Q, Σ, δ, q0, F)라 놓으면")]),v._v(" "),t("li",[v._v("DFA M' = (Q', Σ', δ', q0', F')는 다음과 같이 구성된다\n"),t("ul",[t("li",[v._v("Q' = 2^Q")]),v._v(" "),t("li",[v._v("F = {M의 종료상태를 포함하는 Q'안에 있는 모든 상태의 집합}")]),v._v(" "),t("li",[v._v("q0' = [q0]")])])])])])]),v._v(" "),t("h4",{attrs:{id:"dfa의-상태수-최소화"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dfa의-상태수-최소화"}},[v._v("#")]),v._v(" DFA의 상태수 최소화")]),v._v(" "),t("p",[v._v("상태수를 최소화하는 방법은 동치관계를 이용하여 상태수를 합침(state merge)으로써 상태수를 최소화할 수 있다.")]),v._v(" "),t("ul",[t("li",[v._v("w ∈ Σ* 에 대해서 q1에서 w를 다 본 상태가 q3이고 q2에서 w를 다 본 상태가 q4일 때, q3, q4 중 하나만 종료상태에 속하면 q1은 q2로부터 구별(distinguish)된다고 말한다")]),v._v(" "),t("li",[v._v("만약 상태집합 Q속에 상태가 도달 가능하지 않고, Q의 서로 다른 두 상태가 구별 가능하지 않다면 축약(reduce)될 수 있다")])]),v._v(" "),t("p",[v._v("상태수 최소화는 다음과 같은 과정으로 이루어진다")]),v._v(" "),t("ol",[t("li",[v._v("시작상태로부터 도달 불가능한 상태를 모두 제거한다")]),v._v(" "),t("li",[v._v("초기의 동치관계인 [종료상태]와 [미결상태]의 두 동치류로 분할한다")]),v._v(" "),t("li",[v._v("같은 입력기호에 대해 서로 다른 동치류로 가는 지시선이 존재하면 또 다른 분할을 하여 새로운 동치류를 만든다")]),v._v(" "),t("li",[v._v("3의 과정을 되풀이하여 더 이상 새로운 분할이 일어나지 않을 때까지 반복한다")]),v._v(" "),t("li",[v._v("M의 종료상태에 속하는 상태가 동치류 속에 들어 있으면 이 동치류는 M'의 종료상태이다")])]),v._v(" "),t("h4",{attrs:{id:"정규문법-정규표현-유한-오토마타의-동치관계"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#정규문법-정규표현-유한-오토마타의-동치관계"}},[v._v("#")]),v._v(" 정규문법, 정규표현, 유한 오토마타의 동치관계")]),v._v(" "),t("p",[v._v("정규문법, 정규표현, 유한 오토마타는 서로 변환되는 동치관계이다")]),v._v(" "),t("p",[v._v("정규표현을 유한 오토마타로 변환하는 과정은 다음과 같다")]),v._v(" "),t("ul",[t("li",[v._v("정규표현으로부터 NFA를 구한다")]),v._v(" "),t("li",[v._v("NFA를 DFA로 변환한 다음 최호화된 DFA를 구한다")])]),v._v(" "),t("p",[v._v("유한 오토마타를 정규문법으로 변환하는 과정은 다음과 같다")]),v._v(" "),t("ul",[t("li",[v._v("상태전이도에서 각각의 상태를 하나의 논터미널이라 하고 입력기호를 터미널 기호라 하자")]),v._v(" "),t("li",[v._v("정규문법을 작성하는데 왼편에는 상태를 나타내는 논터미널을 쓴다")]),v._v(" "),t("li",[v._v("오른편에는 전이지시선 위에 있는 입력기호인 터미널 기호를 쓰고 다음에 전이되는 상태를 쓴다")])]),v._v(" "),t("h2",{attrs:{id:"어휘분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#어휘분석"}},[v._v("#")]),v._v(" 어휘분석")]),v._v(" "),t("h3",{attrs:{id:"어휘분석-lexical-analysis-이란"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#어휘분석-lexical-analysis-이란"}},[v._v("#")]),v._v(" 어휘분석(lexical analysis)이란")]),v._v(" "),t("p",[v._v("어휘분석은 원시 프로그램을 구성하는 문자들을 하나의 긴 문장열로 보고 문자를 차례대로 scanning하고 token이라는 단위로 변환하는 것이다.")]),v._v(" "),t("p",[v._v("어휘분석을 담당하는 도구를 어휘분석기/scanner 라고 한다.")]),v._v(" "),t("p",[v._v("토큰이란 의미 있는 문법적 단위인데, 일반적인 프로그래밍 언어에서는 5종류의 토큰을 사용한다")]),v._v(" "),t("ul",[t("li",[v._v("식별자(identifier): SUM, A, B와 같이 프로그래머가 정의하는 변수")]),v._v(" "),t("li",[v._v("상수(constant): 1, 2, 3, 'abc'와 같이 정수형 상수, 실수형 상수, 문자형 상수")]),v._v(" "),t("li",[v._v("예약어(reserved word): IF, WHILE과 같이 언어 구현시 이미 정의되어 있는 지정어")]),v._v(" "),t("li",[v._v("연산자(operator): -, +, *, / 등고 같이 연산시 사용되는 기호")]),v._v(" "),t("li",[v._v("구분자(delimiter): (, [, ; 등과 같이 단어와 단어를 구분하기 위해 사용되는 기호")])]),v._v(" "),t("p",[v._v("일반적으로 토큰은 토큰번호와 토큰값의 순서쌍으로 표현된다.\n토큰번호란 각각의 토큰을 구분하기 위해서 고유의 내부번호를 부여한 정수코드이고, 토큰값은 기호에서 토큰의 위치로 표현된다.")]),v._v(" "),t("p",[v._v("어휘분석기는 토큰번호와 토큰값을 출력하기 위해서 입력에 대해 복귀 값(return value)을 갖고 있어야 하며,\n주어진 모든 문법에 대한 토큰번호와 토큰값을 가지고 있어야 한다.")]),v._v(" "),t("p",[v._v("그러나 프로그래머가 사용한 식별자와 상수에 대한 토큰값과 속성을 나타내는 정보는 기호표(symbol table)에 별도로 보관된다.")]),v._v(" "),t("p",[v._v("어휘분석 단계에서 어휘분석기는 원시 프로그램을 분석하여 토큰열을 생산하면서 얻어진 식별자에 대해 기호표를 검색하여,\n기호표에 이미 있으면 다시 작성하지 않고 없으면 기호표에 식별자를 삽입한 뒤\n구문분석기에게 식별자에 대한 토큰번호와 값으로 기호표 인덱스를 전달한다.")]),v._v(" "),t("h3",{attrs:{id:"어휘-분석기의-설계"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#어휘-분석기의-설계"}},[v._v("#")]),v._v(" 어휘 분석기의 설계")]),v._v(" "),t("p",[v._v("어휘분석기를 설계하려면 우선 문법이 주어져야 한다. 문법의 형태는 앞에서 살펴본 정규문법의 형태이다.\n그리고 주어진 문법의 문법단위에 대한 token table을 작성한다. token table은 어휘분석기에서 돌려 주는 값을 나타낸다.")]),v._v(" "),t("p",[v._v("문법을 보고 NFA를 구성하고, NFA를 DFA로 변환한다음 DFA를 최소화시키면 어휘분석기가 된다.\n여기에 최소화된 DFA에 의해 검색하면서 기호표를 작성할 수 있도록 해야 한다.")]),v._v(" "),t("h3",{attrs:{id:"어휘분석기-구현-고려사항"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#어휘분석기-구현-고려사항"}},[v._v("#")]),v._v(" 어휘분석기 구현 고려사항")]),v._v(" "),t("p",[v._v("분류한 토큰들은 항상 사용되는 것이 아니라 문법이 어떻게 주어지느냐에 따라 다르다.\n그러므로 어휘분석기를 구현할 때는 문법이 어떻게 주어지는지 명확하게 정의되어야 하며,\n명확하게 정의된 문법에 의해서 토큰의 종류를 나열해야 한다.")]),v._v(" "),t("p",[v._v("또한 상태전이도의 순서를 어떻게 주느냐에 따라 어휘분석을 하는 시간이 달라진다.\n그러므로 프로그램 작성시 어느 토큰을 많이 사용하는지를 파악하여 어휘분석기를 구현해야 한다.")]),v._v(" "),t("h2",{attrs:{id:"context-free-언어와-문법의-효율화"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#context-free-언어와-문법의-효율화"}},[v._v("#")]),v._v(" Context-Free 언어와 문법의 효율화")]),v._v(" "),t("h3",{attrs:{id:"context-free-언어와-푸시다운-오토마타"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#context-free-언어와-푸시다운-오토마타"}},[v._v("#")]),v._v(" Context-Free 언어와 푸시다운 오토마타")]),v._v(" "),t("p",[v._v("context-free 문법은 산술식이나 블록 구조를 표헌하는데 효율적이기 때문에 프로그래밍 언어 중에서 가장 널리 사용되고 있다.\ncontext-free 문법은 자연언어(natural language)를 표현하기 위해 도입되었다.")]),v._v(" "),t("p",[v._v("context-free언어는 정규언어보다 표현범위가 넓어서, 이것을 인식하는 push-down 오토마타를 구현하는 일은 유한 오토마타를 구현하는 일보다 어렵다.")]),v._v(" "),t("h3",{attrs:{id:"유도트리"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#유도트리"}},[v._v("#")]),v._v(" 유도트리")]),v._v(" "),t("ul",[t("li",[v._v("좌단유도(leftmost derivation): 유도과정의 각 단계에서 문장형태(sentential form)의 가장 왼쪽에 있는 논터미널 기호를 계속 대체하는 경우")]),v._v(" "),t("li",[v._v("우단유도(rightmost derivation): 좌단유도와 반대로 가장 오른쪽에 있는 논터미널 기호를 계속 대체")]),v._v(" "),t("li",[v._v("좌파스(left parse): 하나의 문장을 만들때 좌단유도에 의해서 적용된 일련의 생성규칙 순서")]),v._v(" "),t("li",[v._v("우파스(right parse): 우단유도에 의해서 적용된 생성규칙의 순서의 역순")])]),v._v(" "),t("p",[v._v("좌파스와 우파스는 구문분석의 방법과 깊은 연관관계가 있다.\ntop-down 구문분석은 좌파스를 생성하고, bottom-up 구문분석은 우파스를 생성한다.")]),v._v(" "),t("p",[v._v("또한 구문분석을 하는 과정은 문장이 유도되는 과정을 트리 형태로 표현하는데, 이를 유도트리(derivation tree)혹은 파스트리(parse tree)라 한다.")]),v._v(" "),t("p",[v._v("CFG(context-free grammar)에 대한 유도트리는 다음과 같이 정의한다")]),v._v(" "),t("ul",[t("li",[v._v("모든 노트(vertex, node)는 문법기호를 레이블(lable)로 갖는다")]),v._v(" "),t("li",[v._v("루트(root)의 레이블은 시작기호 S이다")]),v._v(" "),t("li",[v._v("만약 어떤 노드가 하나 이상의 자식노드(child node)를 갖는다면 이 노드는 논터미널 기호를 레이블로 갖는다")]),v._v(" "),t("li",[v._v("왼쪽부터 순서적으로 X1, X2, ... Xn의 n개의 자식노드를 갖는 어떤 노드 A가 존재한다면 생성규칙이 존재한다")]),v._v(" "),t("li",[v._v("만약 어떤 노드가 자식노드를 하나도 가지고 있지 않다면, 이 노드를 leaf(terminal node)라 한다")])]),v._v(" "),t("h3",{attrs:{id:"모호성"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#모호성"}},[v._v("#")]),v._v(" 모호성")]),v._v(" "),t("p",[v._v("구문분석 단계에서는 출력으로 유도트리를 생성하는데 문법이 모호한 경우에는 문장의 유도트리를 결정적으로 구성하기 어렵다.\n따라서 구문분석기 구현이 복잡해지고 구문분석을하는 시간이 오래걸리는데, 이를 막기위하여 모호하지 않은 문법으로 바꿔줘야 한다.")]),v._v(" "),t("ul",[t("li",[v._v("모호한 문법에 연산자 우선순위와 결합법칙을 적용하여 모호하지 않은 문법으로 바꿀 수 있다.")]),v._v(" "),t("li",[v._v("하나의 context-free 언어를 생성하는 모든 문법이 모호하다면, 이 언어를 inherently ambiguous라고 한다.")]),v._v(" "),t("li",[v._v("모호성 문법 외에도 구문분석을 하는데 효율을 높이기 위해 적당한 문법으로 바꾸어줄수 있는데, 이를 context-free 문법의 단순화라고 한다.")])]),v._v(" "),t("h3",{attrs:{id:"불필요한-생성규칙의-제거"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#불필요한-생성규칙의-제거"}},[v._v("#")]),v._v(" 불필요한 생성규칙의 제거")]),v._v(" "),t("p",[v._v("불필요한 기호는 터미널 문자열을 생성할 수 없는 논터미널 기호이거나 시작기호로부터 도달 불가능한 기호를 말한다.\n이와같이 불필요한 기호를 가지고 있는 생성규칙을 불필요한 생성규칙이라고 한다.")]),v._v(" "),t("h3",{attrs:{id:"ε-생성규칙의-제거"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ε-생성규칙의-제거"}},[v._v("#")]),v._v(" ε-생성규칙의 제거")]),v._v(" "),t("p",[v._v("ε-생성규칙이란 A -> ε 형태의 생성규칙을 갖는 것을 말한다.\n만약 ε이 L(G)안에 없다면 ε-생성규칙을 완전히 제거할 수 있다.")]),v._v(" "),t("h3",{attrs:{id:"단일-생성규칙의-제거"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#단일-생성규칙의-제거"}},[v._v("#")]),v._v(" 단일 생성규칙의 제거")]),v._v(" "),t("p",[v._v("단일 생성규칙(unit production)이란 생성규칙 중 생성규칙의 오른쪽이 단 한개의 논터미널로 구성되어 있는 생성규칙이 존재하는 경우를 말한다.")]),v._v(" "),t("h3",{attrs:{id:"left-factoring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#left-factoring"}},[v._v("#")]),v._v(" left-factoring")]),v._v(" "),t("p",[v._v("같은 기호들을 prefix로 갖는 두 개 이상의 생성규칙이 존재할 경우, 공통된 prefix를 인수분해하는 것을 left-factoring이라고 한다.")]),v._v(" "),t("h3",{attrs:{id:"left-recursion의-제거"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#left-recursion의-제거"}},[v._v("#")]),v._v(" left-recursion의 제거")]),v._v(" "),t("p",[v._v("문법이 어떤 문자열 α에 대해 A -> Aα의 유도과정이 존재하는 경우를 left-recursive하다고 말하며,\n이러한 문법은 top-down 구문분석 시에 같은 생성규칙이 반복적으로 적용되어 무한루프에 빠지게 되므로 구문분석을 어렵게한다.")]),v._v(" "),t("p",[v._v("left-recursion에는 두 가지가 있다.")]),v._v(" "),t("ul",[t("li",[v._v("immme-diate left-recursion: A -> Aα 형태의 생성규칙")]),v._v(" "),t("li",[v._v("indirect left-recursion: A -> Aα 유도과정이 존재하는 경우")])]),v._v(" "),t("h3",{attrs:{id:"푸시다운-오토마타"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#푸시다운-오토마타"}},[v._v("#")]),v._v(" 푸시다운 오토마타")]),v._v(" "),t("p",[v._v("푸시다운 오토마타의 대표적인 예로서는 구문분석기가 있다.\n푸시다운 오토마타는 유한 상태제어와 입력 테이프 외에 무한정의 용량을 가진 스택으로 구성된다.")]),v._v(" "),t("p",[v._v("푸시다운 오토마타에는 비결정적 푸시다운 오토마타와(NPDA)와 결정적 푸시다운 오토마타(DPDA)의 두 종류가 있다.")]),v._v(" "),t("h2",{attrs:{id:"구문분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#구문분석"}},[v._v("#")]),v._v(" 구문분석")]),v._v(" "),t("p",[v._v("구문구조가 주어진 규칙에 맞는지를 검사하는 것을 구문분석(syntax analysis)혹은 파싱(parsing)이라고 한다.")]),v._v(" "),t("p",[v._v("이러한 구문분석을 담당하는 도구를 구문분석기(syntax analyzer, parser)라고 한다.\n일반적으로 구문분석의 출력으로 생성되는 트리는 유도트리(derivation tree)와 같은 모양을 갖는데,\n유도과정을 나타낼 때는 유도트리라 하고, 구문분석기에 의해 생성될 때는 파스트리라고 한다.")]),v._v(" "),t("p",[v._v("구문분석은 파스트리를 어떤 순서로 만들어 가느냐에 따라 top-down 방법과 bottom-up 방법의 두 종류로 나눌 수 있다.")]),v._v(" "),t("h3",{attrs:{id:"bottom-up-구문분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bottom-up-구문분석"}},[v._v("#")]),v._v(" Bottom-up 구문분석")]),v._v(" "),t("p",[v._v("bottom-up 구문분석 방법은 주어진 문자열로부터 reduce에 의해 시작기호를 찾아가는 방법이다.")]),v._v(" "),t("blockquote",[t("p",[v._v("문장 -> 시작기호")])]),v._v(" "),t("p",[v._v("(예) Top-down id + id * id 좌단유도 (id: identifier)")]),v._v(" "),t("ul",[t("li",[v._v("E -> E + E")]),v._v(" "),t("li",[v._v("-> id + E")]),v._v(" "),t("li",[v._v("-> id + E * E")]),v._v(" "),t("li",[v._v("-> id + id * E")]),v._v(" "),t("li",[v._v("-> id + id * id")])]),v._v(" "),t("p",[v._v("(예) Bottom-up id + id * id 우단유도 (id: identifier)")]),v._v(" "),t("ul",[t("li",[v._v("id + id * id ("),t("code",[v._v("id")]),v._v(")")]),v._v(" "),t("li",[v._v("-> E + id * id ("),t("code",[v._v("id")]),v._v(")")]),v._v(" "),t("li",[v._v("-> E + E * id ("),t("code",[v._v("id")]),v._v(")")]),v._v(" "),t("li",[v._v("-> E + E * E ("),t("code",[v._v("E * E")]),v._v(")")]),v._v(" "),t("li",[v._v("-> E + E ("),t("code",[v._v("E + E")]),v._v(")")]),v._v(" "),t("li",[v._v("-> E ("),t("strong",[v._v("handle")]),v._v(")")])]),v._v(" "),t("h4",{attrs:{id:"shift-reduce-구문분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shift-reduce-구문분석"}},[v._v("#")]),v._v(" shift-reduce 구문분석")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("단계")]),v._v(" "),t("th",[v._v("스택")]),v._v(" "),t("th",{staticStyle:{"text-align":"right"}},[v._v("입력")]),v._v(" "),t("th",[v._v("구문분석 행동")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("0")]),v._v(" "),t("td",[v._v("$")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("id+id*id $")]),v._v(" "),t("td",[t("code",[v._v("shift id")])])]),v._v(" "),t("tr",[t("td",[v._v("1")]),v._v(" "),t("td",[v._v("$id")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("+id*id $")]),v._v(" "),t("td",[t("code",[v._v("reduce E -> id")])])]),v._v(" "),t("tr",[t("td",[v._v("2")]),v._v(" "),t("td",[v._v("$E")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("+id*id $")]),v._v(" "),t("td",[t("code",[v._v("shift +")])])]),v._v(" "),t("tr",[t("td",[v._v("3")]),v._v(" "),t("td",[v._v("$E+")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("id*id $")]),v._v(" "),t("td",[t("code",[v._v("shift id")])])]),v._v(" "),t("tr",[t("td",[v._v("4")]),v._v(" "),t("td",[v._v("$E+id")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("*id $")]),v._v(" "),t("td",[t("code",[v._v("reduce E -> id")])])]),v._v(" "),t("tr",[t("td",[v._v("5")]),v._v(" "),t("td",[v._v("$E+E")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("*id $")]),v._v(" "),t("td",[t("code",[v._v("shift *")])])]),v._v(" "),t("tr",[t("td",[v._v("6")]),v._v(" "),t("td",[v._v("$E+E*")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("id $")]),v._v(" "),t("td",[t("code",[v._v("shift id")])])]),v._v(" "),t("tr",[t("td",[v._v("7")]),v._v(" "),t("td",[v._v("$E+E*id")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("$")]),v._v(" "),t("td",[t("code",[v._v("reduce E -> id")])])]),v._v(" "),t("tr",[t("td",[v._v("8")]),v._v(" "),t("td",[v._v("$E+E*E")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("$")]),v._v(" "),t("td",[t("code",[v._v("reduce E -> E*E")])])]),v._v(" "),t("tr",[t("td",[v._v("9")]),v._v(" "),t("td",[v._v("$E+E")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("$")]),v._v(" "),t("td",[t("code",[v._v("reduce E -> E+E")])])]),v._v(" "),t("tr",[t("td",[v._v("10")]),v._v(" "),t("td",[v._v("$E")]),v._v(" "),t("td",{staticStyle:{"text-align":"right"}},[v._v("$")]),v._v(" "),t("td",[t("code",[v._v("accept")])])])])]),v._v(" "),t("p",[v._v("스택 최상단 / 입력 좌측 순위 비교로 연산결정: 터미널-터미널 / 기호-기호")]),v._v(" "),t("h3",{attrs:{id:"여러가지-순위문법과-용어"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#여러가지-순위문법과-용어"}},[v._v("#")]),v._v(" 여러가지 순위문법과 용어")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("FIRST(A): 문자열 A로부터 유도되어, 첫 번째로 나타날 수 있는 터미널 기호들의 집합")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("FIRST(E) = (FIRST(T) ring sum FIRST(E')")]),v._v(")")]),v._v(" "),t("li",[t("code",[v._v("A ring sum B = A if ε not ∈ A")])]),v._v(" "),t("li",[t("code",[v._v("A ring sum B = (A-ε) ∪ B if ε ∈ A")])])])]),v._v(" "),t("li",[t("p",[v._v("FOLLOW(A): A 뒤에 나오는 터미널 기호들")]),v._v(" "),t("ul",[t("li",[v._v("if A == 출발기호, $ ∈ FOLLOW(A)")]),v._v(" "),t("li",[v._v("if B -> αAβ, β != ε, FOLLOW(A) ⊃ FIRST(β) (ε 제외)")]),v._v(" "),t("li",[v._v("if B -> αAβ & B => ε, FOLLOW(A) ⊃ FOLLOW(B)")])])])]),v._v(" "),t("h3",{attrs:{id:"단순순위-구문분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#단순순위-구문분석"}},[v._v("#")]),v._v(" 단순순위 구문분석")]),v._v(" "),t("p",[v._v("단순순위 문법을 가지고 구문분석을 하는 방법으로 논터미널과 터미널, 논터미널과 논터미널 사이에 순위관계를 부여해서 구문분석을 한다.\n순위관계를 트리로 표현했을 때, 자식노드가 부모노드보다 순위가 높다.")]),v._v(" "),t("p",[v._v("그러나 단순순위 구문분석에서는 핸들 결정 문제점때문에 부정확하다.")]),v._v(" "),t("h3",{attrs:{id:"lr-구문분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lr-구문분석"}},[v._v("#")]),v._v(" LR 구문분석")]),v._v(" "),t("ul",[t("li",[v._v("모호하지 않은 CFG이면 모두 가능")]),v._v(" "),t("li",[v._v("Backtracking이 없다")])]),v._v(" "),t("h4",{attrs:{id:"slr-simple-lr-구문분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#slr-simple-lr-구문분석"}},[v._v("#")]),v._v(" SLR(Simple LR) 구문분석")]),v._v(" "),t("h4",{attrs:{id:"clr-canonical-lr-구문분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clr-canonical-lr-구문분석"}},[v._v("#")]),v._v(" CLR(Canonical LR) 구문분석")]),v._v(" "),t("h4",{attrs:{id:"lalr-lookahead-lr-구문분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lalr-lookahead-lr-구문분석"}},[v._v("#")]),v._v(" LALR(LookAhead LR) 구문분석")]),v._v(" "),t("h3",{attrs:{id:"top-down-구문분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#top-down-구문분석"}},[v._v("#")]),v._v(" Top-Down 구문분석")]),v._v(" "),t("h2",{attrs:{id:"의미분석과-기호표"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#의미분석과-기호표"}},[v._v("#")]),v._v(" 의미분석과 기호표")]),v._v(" "),t("h3",{attrs:{id:"의미분석-개요"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#의미분석-개요"}},[v._v("#")]),v._v(" 의미분석 개요")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("상수정의 과정")]),v._v(" "),t("ul",[t("li",[v._v("상수 이름 기호표에 등록")]),v._v(" "),t("li",[v._v("이후 기억장소 배정 및 초기값 설정")])])]),v._v(" "),t("li",[t("p",[v._v("유형(type)정의 과정")]),v._v(" "),t("ul",[t("li",[v._v("유형의 자료구조 구성 및 보관")]),v._v(" "),t("li",[v._v("유형설명자(유형의 자료구조 크기, 성격 ...) 작성")]),v._v(" "),t("li",[v._v("기억장소 배정 때 정보 제공")])])]),v._v(" "),t("li",[t("p",[v._v("변수의 유형선언")]),v._v(" "),t("ul",[t("li",[v._v("변수의 유형에 따른 유형 설명자와 변수명칭이 기호표에 함께 등록")]),v._v(" "),t("li",[v._v("각 변수는 기억장소 배정")])])])]),v._v(" "),t("h3",{attrs:{id:"기호표-구성"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#기호표-구성"}},[v._v("#")]),v._v(" 기호표 구성")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("선형리스트")]),v._v(" "),t("ul",[t("li",[v._v("가장 간단하고 쉽게 구현할 수 있는 방법")]),v._v(" "),t("li",[v._v("하나의 이름 삽입 = 1/2 * n = cn")]),v._v(" "),t("li",[v._v("하나의 이름을 조회 = 1/2 * n = cn")]),v._v(" "),t("li",[v._v("m개의 이름을 조회 = cn * m")]),v._v(" "),t("li",[v._v("n개의 이름삽입과 m개의 이름조회에 필요한 시간: "),t("code",[v._v("cn * n + cn * m = cn * (n+m)")])])])]),v._v(" "),t("li",[t("p",[v._v("트리")]),v._v(" "),t("ul",[t("li",[v._v("이진트리 조회시간")]),v._v(" "),t("li",[v._v("트리 평균 높이(조회에 필요한 평균시간)\n"),t("ul",[t("li",[v._v("log n에 비례 (n = 식별자 이름의 수)")]),v._v(" "),t("li",[v._v("n개의 이름 삽입 = n log n")]),v._v(" "),t("li",[v._v("m개의 이름 조회 = m log n")])])]),v._v(" "),t("li",[v._v("전체시간: "),t("code",[v._v("(n+m)log n")]),v._v("에 비례")]),v._v(" "),t("li",[v._v("n > 50 이면 선형리스트보다 효율적")])])]),v._v(" "),t("li",[t("p",[v._v("해쉬 테이블")]),v._v(" "),t("ul",[t("li",[v._v("가장 효율이 좋은 검색법")]),v._v(" "),t("li",[v._v("추가 및 조회 시간 = "),t("code",[v._v("n / k (m + n)")]),v._v(" (n: 식별자 이름 추가, m: 조회, k: 해쉬테이블 index)")]),v._v(" "),t("li",[v._v("해쉬 충돌발생시 처리방법?")])])])]),v._v(" "),t("h3",{attrs:{id:"상수정의와-의미분석"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#상수정의와-의미분석"}},[v._v("#")]),v._v(" 상수정의와 의미분석")]),v._v(" "),t("p",[v._v("유형은 식별자의 종류")]),v._v(" "),t("ul",[t("li",[v._v("CONSTID: 상수")]),v._v(" "),t("li",[v._v("TYPEID: 각종타입")]),v._v(" "),t("li",[v._v("SIMPLEVARID: 단순변수 유형")]),v._v(" "),t("li",[v._v("FIELDID: record type에서 field-id-list 유형")]),v._v(" "),t("li",[v._v("PROCID: 프로시저")])]),v._v(" "),t("p",[v._v("상수정의 원시 프로그램 예시")]),v._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("CONST\n  X = 2;\n  Z = -X;\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br")])]),t("p",[v._v("어휘분석에서 다음 토큰으로 분리됨: "),t("code",[v._v("CONST, OTHERID, =, UNsigned_INTERGER")])]),v._v(" "),t("p",[v._v("기호표와 스택 포인터 값은 다음과 같다")]),v._v(" "),t("ul",[t("li",[v._v("인덱스: 이름: 유형")]),v._v(" "),t("li",[v._v("K1: X: CONSTID\n"),t("ul",[t("li",[v._v("k2")]),v._v(" "),t("li",[v._v("new")]),v._v(" "),t("li",[t("code",[v._v("+")])])])]),v._v(" "),t("li",[v._v("K2: 2: CONSTID")]),v._v(" "),t("li",[v._v("K3: Z: CONSTID\n"),t("ul",[t("li",[v._v("k2")]),v._v(" "),t("li",[v._v("old")]),v._v(" "),t("li",[t("code",[v._v("-")])])])])]),v._v(" "),t("h2",{attrs:{id:"중간언어와-중간코드-생성"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#중간언어와-중간코드-생성"}},[v._v("#")]),v._v(" 중간언어와 중간코드 생성")]),v._v(" "),t("h3",{attrs:{id:"중간언어의-장점"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#중간언어의-장점"}},[v._v("#")]),v._v(" 중간언어의 장점")]),v._v(" "),t("ul",[t("li",[v._v("컴파일러를 기능적으로 독립적인 여러 모듈들로 구성할 수 있따")]),v._v(" "),t("li",[v._v("원시 프로그래므이 이식성을 증가시킬 수 있다")]),v._v(" "),t("li",[v._v("고급 원시언어와 저급 목적코드 간의 의미적 차이를 이어주는 교량 역할")]),v._v(" "),t("li",[v._v("번역과정이 좀더 쉽게 표현되고 효율적으로 처리될 수 있다")]),v._v(" "),t("li",[v._v("기계와 독립적인 최적화가 가능하다")]),v._v(" "),t("li",[v._v("인터프리티브 컴파일링 시스템에서 인터프리터를 이용하여 실행할 수 있다")]),v._v(" "),t("li",[v._v("목적코드로 직접 번역한 것 보다 컴파일 시간이 더 소요되고 비효율적인 코드를 생성함")])]),v._v(" "),t("h3",{attrs:{id:"중간언어의-종류"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#중간언어의-종류"}},[v._v("#")]),v._v(" 중간언어의 종류")]),v._v(" "),t("ul",[t("li",[v._v("Polish 표기법: Postfix 표현, IR(Prefix 표현)")]),v._v(" "),t("li",[v._v("3-주소 코드")]),v._v(" "),t("li",[v._v("Triple, Quadruple, 간접 Triple")]),v._v(" "),t("li",[v._v("트리구조 코드: AST, TCOL, Diana")]),v._v(" "),t("li",[v._v("가상 기계 코드")]),v._v(" "),t("li",[v._v("P-코드, EM-코드, U-코드, 바이트코드")])]),v._v(" "),t("h4",{attrs:{id:"후위-postfix-표현"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#후위-postfix-표현"}},[v._v("#")]),v._v(" 후위(Postfix) 표현")]),v._v(" "),t("p",[t("code",[v._v("b * c - d")])]),v._v(" "),t("ul",[t("li",[v._v("b * c - d")]),v._v(" "),t("li",[v._v("b * c d -")]),v._v(" "),t("li",[v._v("b c * d -")])]),v._v(" "),t("p",[v._v("변환이 쉽고 빠르며 중간언어로 적합하나, 코드이동이 불가능하여 최적화 부적합")]),v._v(" "),t("h4",{attrs:{id:"_3-주소-코드"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-주소-코드"}},[v._v("#")]),v._v(" 3-주소 코드")]),v._v(" "),t("p",[v._v("치환문 "),t("code",[v._v("A:= -B * (C + D)")])]),v._v(" "),t("ul",[t("li",[v._v("T1 := -B")]),v._v(" "),t("li",[v._v("T2 := C + D")]),v._v(" "),t("li",[v._v("T3 := T1 * T2")]),v._v(" "),t("li",[v._v("A := T3")])]),v._v(" "),t("p",[v._v("3주소 코드는 다음 방식이 존재")]),v._v(" "),t("ul",[t("li",[v._v("TRIPLE: OP, 피연산자1, 피연산자2")]),v._v(" "),t("li",[v._v("간접 TRIPLE: 수행순서 + TRIPLE")]),v._v(" "),t("li",[v._v("Quadruple: TRIPLE + 결과")])]),v._v(" "),t("h3",{attrs:{id:"구문지시적-변환-syntax-directed-translation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#구문지시적-변환-syntax-directed-translation"}},[v._v("#")]),v._v(" 구문지시적 변환(syntax-directed translation)")]),v._v(" "),t("ul",[t("li",[v._v("구문분석을 하면서 구문구조에 따라 직접 중간코드를 생산하는 방법")]),v._v(" "),t("li",[v._v("생성규칙 + 의미수행코드로 구성")]),v._v(" "),t("li",[v._v("생성규칙이 사용될 때 마다 의미수행 규칙을 수행하게 된다")])]),v._v(" "),t("h4",{attrs:{id:"계산기-예제"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#계산기-예제"}},[v._v("#")]),v._v(" 계산기 예제")]),v._v(" "),t("p",[v._v("입력문자열: 23*5+4$")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("생성규칙")]),v._v(" "),t("th",[v._v("의미수행 규칙")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("S -> E$")]),v._v(" "),t("td",[v._v("{print E.VAL}")])]),v._v(" "),t("tr",[t("td",[v._v("E -> E(1) + E(2)")]),v._v(" "),t("td",[v._v("{E.VAL := E(1).VAL + E(2).VAL}")])]),v._v(" "),t("tr",[t("td",[v._v("E -> E(1) * E(2)")]),v._v(" "),t("td",[v._v("{E.VAL := E(1).VAL * E(2).VAL}")])]),v._v(" "),t("tr",[t("td",[v._v("E -> (E(1))")]),v._v(" "),t("td",[v._v("{E.VAL := E(1).VAL}")])]),v._v(" "),t("tr",[t("td",[v._v("E -> I")]),v._v(" "),t("td",[v._v("{E.VAL := I.VAL}")])]),v._v(" "),t("tr",[t("td",[v._v("E -> I(1) digit")]),v._v(" "),t("td",[v._v("{I.VAL := 10 * I(1).VAL + LEXVAL}")])]),v._v(" "),t("tr",[t("td",[v._v("I -> digit")]),v._v(" "),t("td",[v._v("{I.VAL := LEXVAL}")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("digit: 0, 1, 2, ..., 9")])]),v._v(" "),t("h3",{attrs:{id:"중간코드-생성"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#중간코드-생성"}},[v._v("#")]),v._v(" 중간코드 생성")]),v._v(" "),t("p",[v._v("프로그램 언어의 문장부분은 다음으로 구성된다")]),v._v(" "),t("ul",[t("li",[v._v("수식: 산술식, 부울식")]),v._v(" "),t("li",[v._v("치환문")]),v._v(" "),t("li",[v._v("입출력문")]),v._v(" "),t("li",[v._v("제어문: 조건문, 분기문")]),v._v(" "),t("li",[v._v("반복문")]),v._v(" "),t("li",[v._v("부프로그램: 정의와 호출문")])]),v._v(" "),t("h2",{attrs:{id:"코드최적화"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#코드최적화"}},[v._v("#")]),v._v(" 코드최적화")]),v._v(" "),t("h3",{attrs:{id:"코드최적화의-개념"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#코드최적화의-개념"}},[v._v("#")]),v._v(" 코드최적화의 개념")]),v._v(" "),t("p",[v._v("목적 프로그램의 최적화(optimization)는 주어진 원시 프로그램에 대하여 가장 경제적인 목적 프로그램을 생산하도록 하는일이다.")]),v._v(" "),t("p",[v._v("살펴볼 최적화는 실행시간을 짧게 하기위한 최적화와 소요 기억용량을 작게하는 최적화이다.")]),v._v(" "),t("h3",{attrs:{id:"실행시간을-짧게-하기-위한-최적화"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#실행시간을-짧게-하기-위한-최적화"}},[v._v("#")]),v._v(" 실행시간을 짧게 하기 위한 최적화")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("공통 부분식(common subexpression)의 제거")]),v._v(" "),t("ul",[t("li",[v._v("프로그램에서 공통된 부분이 여러 번 나타나는 경우")]),v._v(" "),t("li",[v._v("공통 부분식이 한 번만 계산되도록 함으로써 코드를 효율적으로 만들 수 있다")])])]),v._v(" "),t("li",[t("p",[v._v("상수전파(constant propagation)")]),v._v(" "),t("ul",[t("li",[v._v("컴파일시에 상수를 퐇마하는 연산이 계산될 수 있으면 계산을 함으로써 코드를 줄이는 방법이다")])])]),v._v(" "),t("li",[t("p",[v._v("코드이동(code motion)")]),v._v(" "),t("ul",[t("li",[v._v("루프를 포함하는 프로그램이 있는 경우, 루프안에 있는 명령문을 결과값이 바뀌지 않는 한도내에서 되도록이면 루프 밖으로 꺼내는 방법")]),v._v(" "),t("li",[v._v("루프를 여러번 수행해도 항상 같은 결과를 갖는 루프불변(loop invariant)계산의 경우에 적용한다")])])]),v._v(" "),t("li",[t("p",[v._v("루프융합(loop fusion)")]),v._v(" "),t("ul",[t("li",[v._v("여러 개의 루프를 하나의 루프로 만드는 것")])])]),v._v(" "),t("li",[t("p",[v._v("루프전개(loop unrolling)")]),v._v(" "),t("ul",[t("li",[v._v("루프 계산을 빠르게 하기 위해서 루프를 펼치는 효과를 내는 것")])])]),v._v(" "),t("li",[t("p",[v._v("프로시저 호출 전개")]),v._v(" "),t("ul",[t("li",[v._v("프로시저 호출 실행에는 실제인자 전달이 필요")]),v._v(" "),t("li",[v._v("호출된 프로시저에서는 레지스터 교체, 자료영역 확보, 복귀 때의 레지스터 회복 등 많은 처리가 필요")]),v._v(" "),t("li",[v._v("어떤 경우에는 프로시저를 호출하는 곳에서 호출되는 프로시저를 전개하면 위의 처리를 생략할 수 있다")])])]),v._v(" "),t("li",[t("p",[v._v("불필요한 코드의 제거")]),v._v(" "),t("ul",[t("li",[v._v("불필요한 코드로는 도달할 수 없는 코드와 사용되지 않는 코드가 있다")])])]),v._v(" "),t("li",[t("p",[v._v("복사전파(copy propagation)")]),v._v(" "),t("ul",[t("li",[v._v("치환문을 삭제하고 삭제된 치환문의 1-value 대신에 r-value를 사용하는 방법")])])]),v._v(" "),t("li",[t("p",[v._v("식의 연산순서 변경(rearrangeing expression)")]),v._v(" "),t("ul",[t("li",[v._v("식의 연산순서 변경에 의해 연산이 임시결과를 저장하거나 로드 횟수를 최소화 함")]),v._v(" "),t("li",[v._v("임시변수 기억공간 절약 및 효율적인 코드 생산")])])]),v._v(" "),t("li",[t("p",[v._v("중복된(redundant) 로드-저장 명령문 제거")]),v._v(" "),t("ul",[t("li",[v._v("중복되는 로드 명령문이나 저장 명령문을 저거함")])])]),v._v(" "),t("li",[t("p",[v._v("제어흐름(flow of control)의 최적화")]),v._v(" "),t("ul",[t("li",[v._v("불필요한 jump문을 제거하는 방법")])])]),v._v(" "),t("li",[t("p",[v._v("식의 대수학적 간소화(algebraic simplication)")]),v._v(" "),t("ul",[t("li",[v._v("식을 간소화 시킨다. 즉, "),t("code",[v._v("Y := X * 1")]),v._v(" 과 같은 식을 "),t("code",[v._v("Y := X")]),v._v("로 변경할 수 있다")])])]),v._v(" "),t("li",[t("p",[v._v("연산의 세기 경감(reduction in strength)")]),v._v(" "),t("ul",[t("li",[v._v("보다 빠른 계산을 하기 위해서 "),t("code",[v._v("X ** 2")]),v._v("를 "),t("code",[v._v("X * X")]),v._v("로, "),t("code",[v._v("X * 2")]),v._v("를 "),t("code",[v._v("X + X")]),v._v("로 치환하는 것을 말함")])])]),v._v(" "),t("li",[t("p",[v._v("결합변경")]),v._v(" "),t("ul",[t("li",[v._v("여러개의 문장들을 보다 효율적인 문장으로 변경하는 것")])])]),v._v(" "),t("li",[t("p",[v._v("귀납변수 최적화(induction variable)")]),v._v(" "),t("ul",[t("li",[v._v("귀납변수는 루프를 돌 때마다 값이 일률적으로 변하는 변수")]),v._v(" "),t("li",[v._v("연산의 세기 경감에 따라 최적화 할 수 있다")])])]),v._v(" "),t("li",[t("p",[v._v("기타 방법")]),v._v(" "),t("ul",[t("li",[v._v("레지스터 할당, 컴퓨터의 특수명령 할당 등의 문제")])])])]),v._v(" "),t("h3",{attrs:{id:"소요-기억용량-최적화"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#소요-기억용량-최적화"}},[v._v("#")]),v._v(" 소요 기억용량 최적화")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("부프로그램화")]),v._v(" "),t("ul",[t("li",[v._v("프로그램중 같은 패턴이 여러 번 나타나면 부프로그램화 하는 것이 효과적")]),v._v(" "),t("li",[v._v("원시 프로그램보다 중간코드에 대해서 행하는 것이 효과적임")])])]),v._v(" "),t("li",[t("p",[v._v("부분식 끌어올리기(code hoisting)")]),v._v(" "),t("ul",[t("li",[v._v("같은 식의 연산이 여러 군데 있는 경우, 그것보다 먼저 나오는 어딘가 한 곳에 그 연산을 처리함")])])])]),v._v(" "),t("h3",{attrs:{id:"최적화의-구현"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#최적화의-구현"}},[v._v("#")]),v._v(" 최적화의 구현")]),v._v(" "),t("p",[v._v("최적화 방법은 원시 프로그램이 어떤 것이냐에 따라 다른 방법을 선택해야 한다.")]),v._v(" "),t("h2",{attrs:{id:"목적코드-생성"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#목적코드-생성"}},[v._v("#")]),v._v(" 목적코드 생성")]),v._v(" "),t("h3",{attrs:{id:"목적코드-생성의-개요"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#목적코드-생성의-개요"}},[v._v("#")]),v._v(" 목적코드 생성의 개요")]),v._v(" "),t("p",[v._v("목적코드 생성은 대상기계에 따라 다르기 때문에, 상황에 맞춰 생성방식을 결정해야 한다.\n목적코드는 중간코드를 입력으로 받아 기계에 맞는 기계어로 생성할 수 있고, 어셈블리어로도 생성할 수 있다.")]),v._v(" "),t("p",[v._v("목적 코드를 생성하는 데는 다음 세 가지 사항을 고려해야 한다")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("어떤 명령어(instruction)를 생성할 것인지 결정해야 함")]),v._v(" "),t("ul",[t("li",[v._v("대부분의 기계들이 같은 연산에 대하여 다양한 명령어를 가지고 있기 때문")])])]),v._v(" "),t("li",[t("p",[v._v("계산과정을 어떤 순서로 하는지 결정")]),v._v(" "),t("ul",[t("li",[v._v("연산순서에 따라 레지스터의 개수나 기억장소의 요구량이 달라지기 때문")])])]),v._v(" "),t("li",[t("p",[v._v("피연산자를 레지스터에 어떻게 배정할 것인지 결정해야 함")]),v._v(" "),t("ul",[t("li",[v._v("어떤 레지스터를 사용하느냐에 따라 연산의 종류에도 제한이 생기기 때문")]),v._v(" "),t("li",[v._v("곱셈이나 나눗셈은 연속의 레지스터를 두 개 사용하고 그 순서가 맞아야 한다")]),v._v(" "),t("li",[v._v("일반적으로 기억장소보다는 레지스터를 사용하면 연산속도가 훨씬 빨라진다")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);