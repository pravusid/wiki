(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{412:function(v,_,a){"use strict";a.r(_);var l=a(28),i=Object(l.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"sql-anti-patterns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql-anti-patterns"}},[v._v("#")]),v._v(" SQL Anti Patterns")]),v._v(" "),a("h2",{attrs:{id:"무단횡단"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#무단횡단"}},[v._v("#")]),v._v(" 무단횡단")]),v._v(" "),a("p",[v._v("다대다 관계를 위한 교차테이블 생성을 피하기 위해 쉼표로 구분된 목록을 사용하는 경우")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-쉼표로-구분된-목록에-저장"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-쉼표로-구분된-목록에-저장"}},[v._v("#")]),v._v(" 안티패턴: 쉼표로 구분된 목록에 저장")]),v._v(" "),a("ul",[a("li",[v._v("해당 데이터에서 일치하는 데이터를 검색하는 경우")]),v._v(" "),a("li",[v._v("해당 데이터를 FK로 사용해서 연관 데이터를 조회하는 경우 조인 자체도 어려울 뿐더러 조인시 인덱스를 활용할 기회가 사라진다")]),v._v(" "),a("li",[v._v("집계쿼리는 행의 그룹에 대해 사용하도록 되어 있으므로 사용이 어렵다")]),v._v(" "),a("li",[v._v("데이터 목록 정렬이 어렵다")]),v._v(" "),a("li",[v._v("연관 데이터의 갱신이 어렵다")]),v._v(" "),a("li",[v._v("입력 데이터의 유효성 검증이 어렵다")]),v._v(" "),a("li",[v._v("구분자 문자로 어떤것을 선택해야 할지에 대한 문제(comma를 사용한다면 본문의 comma는 어떻게 처리할 것인가?)")]),v._v(" "),a("li",[v._v("데이터 타입에 따라 목록 저장 길이 제한이 존재한다")])]),v._v(" "),a("h3",{attrs:{id:"쉼표로-구분된-목록-저장-사용이-합당한-경우"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#쉼표로-구분된-목록-저장-사용이-합당한-경우"}},[v._v("#")]),v._v(" 쉼표로 구분된 목록 저장 사용이 합당한 경우")]),v._v(" "),a("ul",[a("li",[v._v("특정 쿼리는 역정규화를 적용해 성능을 높일 수 있다")]),v._v(" "),a("li",[v._v("이 경우 목록안의 개별항목에 접근할 필요가 없어야 한다")]),v._v(" "),a("li",[v._v("역정규화 적용은 보수적으로 접근해야 한다")])]),v._v(" "),a("h3",{attrs:{id:"해법-교차-테이블-생성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-교차-테이블-생성"}},[v._v("#")]),v._v(" 해법: 교차 테이블 생성")]),v._v(" "),a("ul",[a("li",[v._v("어떤 테이블이 FK로 두 테이블을 참조할 때 이를 교차 테이블이라 한다")]),v._v(" "),a("li",[v._v("별도의 테이블에 각각의 행으로 저장하고 두 테이블 사이 다대다 관계를 생성한다")]),v._v(" "),a("li",[v._v("목록에 항목 추가/삭제는 교차 테이블에 행 삽입 삭제로 할 수 있다")])]),v._v(" "),a("h2",{attrs:{id:"순진한-트리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#순진한-트리"}},[v._v("#")]),v._v(" 순진한 트리")]),v._v(" "),a("p",[v._v("데이터가 재귀적 관계를 가지는 것은 흔한일이다. 데이터는 트리나 계층적 구조가 될 수 있다.\n이러한 데이터를 조회할 때는 개별항목을 조회, 관련 부분만 조회, 전체를 조회하는 경우가 존재한다.")]),v._v(" "),a("p",[v._v("무한 계층 댓글, 조직도 등이 해당 자료구조라 할 수 있다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-항상-부모에-의존"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-항상-부모에-의존"}},[v._v("#")]),v._v(" 안티패턴: 항상 부모에 의존")]),v._v(" "),a("ul",[a("li",[v._v("계층 데이터를 저장할 때 부모 데이터 id를 갖고 있는 방식의 설계를 인접 목록 (adjacency list)라 한다")]),v._v(" "),a("li",[v._v("인접목록에서 모든 자식 조회하기를 제대로 수행하지 못한다면 안티패턴이 된다\n"),a("ul",[a("li",[v._v("JOIN은 횟수가 정해져 있으므로 모든 계층을 가져온다면 많은 수행이 필요하고, 계층 제한이 없다면 실행조차 어렵다")]),v._v(" "),a("li",[v._v("전체 데이터를 가져와 애플리케이션에서 계층을 생성하는 것은 느리고 매우 비효율적이다")])])]),v._v(" "),a("li",[v._v("인접 목록에서 노드 추가나 이동은 간단한 편이다. 그러나 삭제는 상당히 복잡하다.")])]),v._v(" "),a("h3",{attrs:{id:"항상-부모에-의존-사용이-합당한-경우"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#항상-부모에-의존-사용이-합당한-경우"}},[v._v("#")]),v._v(" 항상 부모에 의존 사용이 합당한 경우")]),v._v(" "),a("p",[v._v("주어진 노드의 부모나 자식을 바로 얻거나 새로운 노드 추가만 주로 이루어지는 경우 인접목록 사용이 적합할 수도 있다.")]),v._v(" "),a("p",[v._v("어떤 DBMS는 인접 목록 형식으로 젖아된 계층 구조를 지원하기 위한 SQL 확장기능을 지원한다.\nSQL-99 표준에는 WITH 키워드에 Common Table Expression을 사용한 재퀴적 쿼리문법이 있다.")]),v._v(" "),a("h3",{attrs:{id:"해법-대안-트리-모델-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-대안-트리-모델-사용"}},[v._v("#")]),v._v(" 해법: 대안 트리 모델 사용")]),v._v(" "),a("p",[v._v("계층 데이터 저장시 인접 목록의 대안으로 경로 열거, 중첩집합, 클로저 테이블 등이 있다.")]),v._v(" "),a("h4",{attrs:{id:"경로-열거-path-enumeration"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#경로-열거-path-enumeration"}},[v._v("#")]),v._v(" 경로 열거(Path Enumeration)")]),v._v(" "),a("p",[v._v("인접목록의 약점중 하나는 트리에서 노드의 조상을 얻는데 비용이 크다는 것이다.\n경로 열거 방법에서는 일련의 조상을 각 노드의 속성으로 저장해서 해결한다. (디렉토리 경로가 일종의 경로 열거 형태)")]),v._v(" "),a("p",[v._v("데이터 노드의 경로도 root 부터 시작해 "),a("code",[v._v("/")]),v._v("로 구분하여 하나의 속성으로 저장가능하다.")]),v._v(" "),a("p",[v._v("새로운 노드를 삽입할 때 다른 노드를 수정하지 않고 non-leaf 노드를 삽입할 수 있다.\n(새노드의 부모 경로에 새로운 노드의 id를 덧붙이기만 하면 된다)")]),v._v(" "),a("p",[v._v("만약 구분자 사이 요소길이가 같은 경우 데이터를 계층구조에 따라 쉽게 정렬할 수 있다. (단순히 문자를 정렬하는 것과 같다)")]),v._v(" "),a("p",[v._v("경로 열거는 무단횡단과 비슷한 단점이 있다.\n경로 문자열을 유지하는 것이 애플리케이션 코드에 종속되고, 검증에 비용이 많이 든다. 또한 길이도 제한된다.")]),v._v(" "),a("h4",{attrs:{id:"중첩집합-nested-sets"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#중첩집합-nested-sets"}},[v._v("#")]),v._v(" 중첩집합(Nested Sets)")]),v._v(" "),a("p",[v._v("중첩 집합은 각 노드가 자신의 부모대신 자손의 집합에 대한 정보를 저장한다.")]),v._v(" "),a("p",[v._v("각 노드는 nleft, nright (다른이름도 상관 없음)라는 두 숫자를 가진다.\nnleft는 모든 자식 노드의 nleft 수 보다 작고, lright는 모든 자식 노드의 nright 수 보다 크다.")]),v._v(" "),a("p",[v._v("이 경우 현재 노드의 nleft와 nright 사이의 값을, nleft 값으로 가진 노드를 찾으면 모든 자식 노드를 찾는 것이다.\n반대로 nleft와 nright 사이의 값으로 현재 노드의 nleft값을 가지는 노드를 찾으면 모든 조상 노드를 찾을 수 있다.")]),v._v(" "),a("p",[v._v("중첩 집합 모델의 강점은, 자식을 가진 노드를 삭제 했을 때 그 자손이 자동으로 삭제 노드의 부모 자손이 된다는 점이다.")]),v._v(" "),a("p",[v._v("그러나 직접적인 자식이나 부모조회는 복잡하다.\n어떤 노드가 직계 조상/후손 노드인지 알 수 없으므로 두 노드사이의 조상/후손이 있는 지를 비교하여 없는 경우를 찾아야 한다.")]),v._v(" "),a("p",[v._v("노드 추가/이동도 복잡하다. 이 경우 새 노드의 left보다 큰 모든 노드의 left, right 값을 재계산 해야 한다.")]),v._v(" "),a("h4",{attrs:{id:"클로저-테이블-closure-table"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#클로저-테이블-closure-table"}},[v._v("#")]),v._v(" 클로저 테이블(Closure Table)")]),v._v(" "),a("p",[v._v("클로저 테이블은 부모-자식 관계의 경로만 저장하는 것이 아니라, 트리의 모든 경로를 저장한다.")]),v._v(" "),a("p",[v._v("대상 데이터 테이블과 두 개의 컬럼을 가진 경로 데이터 테이블을 생성한다.\n트리 구조에 대한 정보를 경로 데이터 테이블에 저장한다.\n이 테이블에서는 트리에서 조상/자손 관계를 가진 모든 노드쌍과 자기 자신을 참조를 각 행으로 저장한다. (각 노드는 모든 후손을 표기한다)")]),v._v(" "),a("p",[v._v("클로저 테이블에서 조상이나 자손을 가져오는 방식은 직관적이다.\n만약 4번 데이터의 자손을 얻으려면 경로 테이블에서 조상이 4인 데이터를 찾으면 된다.")]),v._v(" "),a("p",[v._v("클로저 테이블은 조상/자손 조회및 계층구조 정보 유지가 쉬운편이다.")]),v._v(" "),a("h4",{attrs:{id:"모델-선택"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#모델-선택"}},[v._v("#")]),v._v(" 모델 선택")]),v._v(" "),a("ul",[a("li",[v._v("인접 목록은 가장 많이 사용되는 형태")]),v._v(" "),a("li",[v._v("재귀적 쿼리는 문법을 지원하는 DBMS를 사용해야 함")]),v._v(" "),a("li",[v._v("경로열거는 참조 정합성을 강제하지 못하고 정보를 중복 저장하므로 깨지기 쉽다")]),v._v(" "),a("li",[v._v("중첩 집합역시 참조 정합성을 강제하지 못한다. 수정은 적고 조회를 주로하는 경우 좋다")]),v._v(" "),a("li",[v._v("클로저 테이블은 가장 융통성 있는 모델이나, 깊은 계층 구조 설명을 위해 많은 행이 필요하다")])]),v._v(" "),a("h2",{attrs:{id:"id가-필요해"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#id가-필요해"}},[v._v("#")]),v._v(" ID가 필요해")]),v._v(" "),a("p",[v._v("모든 테이블이 PK를 가지더라도 PK 본질을 혼동하면 안된다.\n까다로운 부분은 PK로 사용할 컬럼을 선정하는 일이다.")]),v._v(" "),a("p",[v._v("다음과 같은 것이 필요하다면 PK 제약조건이 필요한 것이다")]),v._v(" "),a("ul",[a("li",[v._v("테이블에 중복행이 저장되는 것을 방지")]),v._v(" "),a("li",[v._v("쿼리에서 각 행을 참조")]),v._v(" "),a("li",[v._v("FK 참조 지원")])]),v._v(" "),a("p",[v._v("그러나, 대부분의 테이블에서 어느 속성값이든 하나 이상의 행에서 나타날 가능성이 있다.\n이런 테이블에는 아무런 의미도 없는 인위적 값을 저장할 필요가 있는데,\n이러한 형태의 PK를 pseudo key / surrogate key 라고 한다.")]),v._v(" "),a("p",[v._v("여러 클라이언트가 동시에 행을 삽입하는 경우에도 각 가상키 값이 유일하게 할당되는 것을 보장하기 위해,\n대부분의 DBMS는 트랜잭션 격리 범위 밖에서 유일한 정수값을 생성하는 기능을 제공한다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-만능키"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-만능키"}},[v._v("#")]),v._v(" 안티패턴: 만능키")]),v._v(" "),a("p",[v._v("다음과 같은 특성을 가지는 PK 컬럼을 만드는 관례가 있다")]),v._v(" "),a("ul",[a("li",[v._v("PK 컬럼 이름은 "),a("code",[v._v("id")]),v._v("이다")]),v._v(" "),a("li",[v._v("PK 컬럼 데이터 타입은 32/64비트 정수이다")]),v._v(" "),a("li",[v._v("유일한 값은 자동 생성된다")])]),v._v(" "),a("p",[v._v("모든 테이블에 "),a("code",[v._v("id")]),v._v(" 컬럼을 추가하는 것은 이상한 사용 문제를 초래하기도 한다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("중복 키 생성")]),v._v(" "),a("ul",[a("li",[v._v("테이블내 다른 컬럼이 자연키로 사용될 수 있는 상황에서도 "),a("code",[v._v("id")]),v._v(" 컬럼을 PK로 정의한 경우가 있다")]),v._v(" "),a("li",[v._v("그 컬럼에 "),a("code",[v._v("UNIQUE")]),v._v(" 제약조건이 설정되어 있는 경우도 있다")])])]),v._v(" "),a("li",[a("p",[v._v("중복 행 허용")]),v._v(" "),a("ul",[a("li",[v._v("복합키는 여러 컬럼을 포함한다")]),v._v(" "),a("li",[a("code",[v._v("id")]),v._v(" 컬럼을 PK로 사용하는 경우 유일해야 하는 복합키 조건을 만족하지 못할 수 있다")]),v._v(" "),a("li",[v._v("이 경우 다른 복합키 후보 컬럼에 "),a("code",[v._v("UNIQUE")]),v._v(" 제약조건을 걸어야 하는데 그렇다면 "),a("code",[v._v("id")]),v._v(" PK는 불필요하다")])])]),v._v(" "),a("li",[a("p",[v._v("모호한 키의 의미")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("id")]),v._v("란 이름은 너무 일반적이므로 아무런 의미를 갖지 못한다")]),v._v(" "),a("li",[v._v("이는 특히 "),a("code",[v._v("id")]),v._v(" 컬럼을 가진 두 테이블을 조인할 때 문제가 된다")])])]),v._v(" "),a("li",[a("p",[v._v("USING 사용")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("JOIN ON")]),v._v(" 키워드를 사용하는 대신 "),a("code",[v._v("JOIN USING")]),v._v(" 키워드를 사용해 간략한 문법으로 조인할 수 있다")]),v._v(" "),a("li",[v._v("그러나 모든 테이블에서 "),a("code",[v._v("id")]),v._v("라는 PK를 사용한다면 FK컬럼과 PK컬럼의 이름이 다르므로 이 문법을 사용할 수 없다")])])])]),v._v(" "),a("h4",{attrs:{id:"시퀀스의-특별한-범위"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#시퀀스의-특별한-범위"}},[v._v("#")]),v._v(" 시퀀스의 특별한 범위")]),v._v(" "),a("p",[v._v("최댓값에 1을 더해 새 행을 위한 키 값으로 사용하는 경우가 있다")]),v._v(" "),a("p",[v._v("그러나 여러개의 클라이언트가 동시에 쿼리를 실행할 수 있다면 이런 방식은 안전하지 않다.\n여러 클라이언트에서 같은 값을 사용할 수도 있는데, 이런 상황을 경쟁 상태(race condition)이라고 한다.")]),v._v(" "),a("p",[v._v("경쟁 상태를 피하려면 동시 삽입을 막고 최댓값을 구한다음 이를 이용에 행을 삽입해야 한다.\n그렇게 하려면 행 수준 lock으로 충분하지 않고 전체 테이블 lock을 사용해야 한다.\n테이블 lock은 클라이언트 동시 접근을 막고 요청을 순차적으로 처리하므로 병목의 원인이 된다.")]),v._v(" "),a("p",[v._v("시퀀스는 트랜잭션 범위 밖에서 동작해 이 문제를 해결한다.\n시퀀스는 여러 클라이언트에 같은 값을 할당하지 않고,\n삽입할 행에 사용한 값을 커밋했는지 여부과 상관없이 한번 할당한 값을 되돌리지도 못한다.")]),v._v(" "),a("p",[v._v("시퀀스는 이런 방식으로 동작하므로 여러 클라이언트가 동시에 중복되지 않은 유일한 값을 할당받는다고 확신할 수 있다.")]),v._v(" "),a("p",[v._v("대부분의 DBMS는 시퀀스가 생성한 마지막 값을 확인할 수 있는 함수를 제공한다.\nMySQL에서는 "),a("code",[v._v("LAST_INSERT_ID()")]),v._v(", SQL Server에서는 "),a("code",[v._v("SCOPE_IDENTITY()")]),v._v(", ORACLE에서는 "),a("code",[v._v("시퀀스이름.CURRVAL")]),v._v("이다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-인식-방법-만능키"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-인식-방법-만능키"}},[v._v("#")]),v._v(" 안티패턴 인식 방법: 만능키")]),v._v(" "),a("p",[v._v("테이블에서 PK 컬럼 이름으로 지나치게 일반적인 이름(id...)이 사용되고 있거나\n다대다 연결에서 중복이 발생하는 경우 안티패턴의 징후로 볼 수 있다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-만능키"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-만능키"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: 만능키")]),v._v(" "),a("p",[v._v("Convention으로 정해놓았거나, 지나치게 긴 자연키를 대체하기 위해 사용한다면 적절한 선택이다.")]),v._v(" "),a("h3",{attrs:{id:"해법-상황에-맞추기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-상황에-맞추기"}},[v._v("#")]),v._v(" 해법: 상황에 맞추기")]),v._v(" "),a("p",[v._v("PK는 제약조건이지 데이터 타입이 아니다.\n데이터 타입이 인덱스를 지원하기만 하면 어느 컬럼 혹은 컬럼 묶음에 대해서 PK를 선언할 수 있다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("있는 그대로 말하기")]),v._v(" "),a("ul",[a("li",[v._v("PK에 의미있는 이름을 선택해야 한다")]),v._v(" "),a("li",[v._v("가급적 FK에서도 가능한 같은 컬럼이름을 사용해야 한다")]),v._v(" "),a("li",[v._v("이는 종종 PK 이름이 스키마 내에서 유일해야 함을 뜻한다")])])]),v._v(" "),a("li",[a("p",[v._v("관례에서 벗어나기")]),v._v(" "),a("ul",[a("li",[v._v("ORM에서는 "),a("code",[v._v("id")]),v._v("라는 이름의 가상키가 사용될 것을 기대하지만 다른 이름으로 설정할 수도 있다")])])]),v._v(" "),a("li",[a("p",[v._v("자연키와 복합키")]),v._v(" "),a("ul",[a("li",[v._v("유일함이 보장되고 NULL인 경우가 없으며 행을 식별하는 용도로 사용될 수 있는 컬럼이 있으면 가상키를 사용할 필요는 없다")]),v._v(" "),a("li",[v._v("그러나 처음에는 자연키로 사용될 수 있던 컬럼이 시스템이 변경됨에 따라 중복을 허용하게 될 수도 있다")]),v._v(" "),a("li",[v._v("복합키가 적합한 경우에 이를 사용하지만, 복합키의 FK 또한 복합키가 되어야 함에 유의해야 한다")])])])]),v._v(" "),a("h2",{attrs:{id:"키가-없는-엔트리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#키가-없는-엔트리"}},[v._v("#")]),v._v(" 키가 없는 엔트리")]),v._v(" "),a("p",[v._v("RDBMS에서 참조정합성(Referential Integrity)은 데이터베이스 설계 및 운영에서 중요한 부분이다.\n어떤 컬럼(묶음)에 FK 제약조건을 선언하면 그 컬럼에 들어가는 값은 부모테이블의 PK 또는 UNIQUE KEY에 존재해야 한다.")]),v._v(" "),a("p",[v._v("그러나 어떤 개발자는 참조 정합성 제약조건을 무시하라는 말을 한다. 그 이유는 다음과 같다.")]),v._v(" "),a("ul",[a("li",[v._v("데이터 업데이트 시 제약조건과 충돌할 수 있다")]),v._v(" "),a("li",[v._v("참조 정합성 제약족너을 지원할 수 없는 매우 융통성 있는 데이터베이스 설계를 사용하고 있다")]),v._v(" "),a("li",[v._v("FK에 데이터베이스가 자동생성하는 인덱스때문에 성능에 영향이 있다고 믿는다")]),v._v(" "),a("li",[v._v("FK를 지원하지 않는 데이터베이스를 사용하고 있다")])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-제약조건-무시"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-제약조건-무시"}},[v._v("#")]),v._v(" 안티패턴: 제약조건 무시")]),v._v(" "),a("p",[v._v("FK 제약조건을 생략하는 것이 데이터베이스 설계를 단순하고 유연하게 만드는 것처럼 보이지만 다른 대가를 치러야 한다.\n참조 정합성을 보장하기 위한 코드를 직접 작성하는 책임을 떠안아야 하기 때문이다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("무결점 코드")]),v._v(" "),a("ul",[a("li",[v._v("FK 제약조건을 사용하지 않고 참조 정합성을 만족하기 위해, 변경전 별도의 SELECT 쿼리를 실행해 정합성 유지여부를 확인해야 한다.")]),v._v(" "),a("li",[v._v("확인을 위한 쿼리를 실행한 직후 다른 클라이언트의 요청으로 해당 값이 변경되는 경우 정합성이 유지되지 않는다")]),v._v(" "),a("li",[v._v("이를 방지하기 위한 유일한 해결책은 테이블을 잠근뒤 일련의 작업을 진행하는 것이지만, 엄청난 성능저하가 발생할 것이다")])])]),v._v(" "),a("li",[a("p",[v._v("오류 확인")]),v._v(" "),a("ul",[a("li",[v._v("깨진 참조를 수동으로 확인해야 한다면 얼마나 자주 해야하는지에 대한 의문이 있을 것이다")]),v._v(" "),a("li",[v._v("만약 깨진 참조를 발견한다 하여도 올바르게 수정할 수 있을지 확신할 수도 없다")])])]),v._v(" "),a("li",[a("p",[v._v("누구의 잘못인가")]),v._v(" "),a("ul",[a("li",[v._v("애플리케이션이 아니라 쿼리 도구나 스크립트를 이용해서 데이터베이스를 직접 수정할 수도 있다")]),v._v(" "),a("li",[v._v("이런 경우 깨진 참조가 발생할 가능성이 더욱크지만, 애플리케이션 수명주기상 이런 일이 발생할 수도 있음을 인정해야 한다")])])]),v._v(" "),a("li",[a("p",[v._v("진퇴양난 업데이트")]),v._v(" "),a("ul",[a("li",[v._v("많은 개발자들이 여러 테이블에 걸친 관련 컬럼 업데이트가 불편하므로 FK 제약조건 사용을 꺼린다")]),v._v(" "),a("li",[v._v("이 문제는 특히 자식행이 참조하고 있는 컬럼을 UPDATE 하려할 때 발생한다")]),v._v(" "),a("li",[v._v("부모를 업데이트 하기 전에는 자식 행을 업데이트 할 수 없고, 자신을 참조하는 자식 행을 업데이트하기 전에는 부모를 업데이트 할 수 없다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-인식-방법-제약조건-무시"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-인식-방법-제약조건-무시"}},[v._v("#")]),v._v(" 안티패턴 인식 방법: 제약조건 무시")]),v._v(" "),a("p",[v._v("다음과 같은 경우 키가 없는 엔트리 안티패턴일 가능성이 있다")]),v._v(" "),a("ul",[a("li",[v._v("어떤 값이 한 테이블에는 있고 다른 테이블에 없는지 확인하려는 쿼리 작성방법을 고민")]),v._v(" "),a("li",[v._v("테이블에 삽입하면서 다른 테이블에 어떤 값이 있는지 빠르게 확인하는 방법을 고민")])]),v._v(" "),a("h3",{attrs:{id:"해법-제약조건-선언하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-제약조건-선언하기"}},[v._v("#")]),v._v(" 해법: 제약조건 선언하기")]),v._v(" "),a("p",[v._v("데이터 정합성 오류를 찾아내 정정하는 대신 FK를 사용하여 처음부터 잘못된 데이터가 입력되지 않도록 한다.\n이 강제사항을 우회할 코드는 존재할 수 없다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("여러 테이블 변경 지원")]),v._v(" "),a("ul",[a("li",[v._v("FK는 애플리케이션 코드가 행할 수 없는 cascading update를 수행할 수 있다")]),v._v(" "),a("li",[v._v("이경우 부모행을 업데이트/삭제 하는 경우 해당 행을 참조하는 자식행을 알아서 처리한다")]),v._v(" "),a("li",[v._v("FK 제약조건의 "),a("code",[v._v("ON UPDATE")]),v._v(" 또는 "),a("code",[v._v("ON DELETE")]),v._v(" 절을 선언하는 방식에 따라 단계적 작업 결과를 제어할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("오버헤드?")]),v._v(" "),a("ul",[a("li",[v._v("FK 제약조건에 약간의 오버헤드가 있는 것은 사실이다")]),v._v(" "),a("li",[v._v("그러나 다른조건과 비교했을 때 FK가 훨씬 효율적이다\n"),a("ul",[a("li",[v._v("INSERT, UPDATE, DELETE 실행이전 데이터 확인을 위해 SELECT 실행 불필요(경쟁상태 문제도 발생할 수 있음)")]),v._v(" "),a("li",[v._v("여러 테이블을 변경하기 위해 테이블 lock을 사용할 필요가 없다")]),v._v(" "),a("li",[v._v("불필요하게 발생하는 참조가 없는 데이터를 삭제하기 위해 스크립트를 실행할 필요가 없다")])])])])])]),v._v(" "),a("h2",{attrs:{id:"엔티티-속성-값"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#엔티티-속성-값"}},[v._v("#")]),v._v(" 엔티티-속성-값")]),v._v(" "),a("p",[v._v("일반적인 테이블은 모든 행과 관계된 속성 컬럼으로 이루어져 있고, 각 행은 비슷한 객체의 인스턴스를 나타낸다.\n속성 집합이 다르면 객체의 타입도 다르다는 뜻이며, 따라서 다른 테이블에 있어야 한다.")]),v._v(" "),a("p",[v._v("객체지향 프로그래밍 모델에서는 동일한 데이터 타입을 확장하는 방법으로 객체의 타입도 관계를 가질 수 있다.\n이 때, 객체를 하나의 데이터베이스 테이블에 행으로 저장하는경우,\n각 서브타입이 베이스 타입이나 다른 서브타입에 적용되지 않는 속성을 저장하는 것(가변속성)도 허용해야 한다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-범용-속성-테이블-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-범용-속성-테이블-사용"}},[v._v("#")]),v._v(" 안티패턴: 범용 속성 테이블 사용")]),v._v(" "),a("p",[v._v("가변 속성을 지원해야 할 때 별도 테이블을 생성해 저장할 수 있다.\n이 가변 속성 테이블의 각 행은 세 가지의 컬럼을 갖는다.")]),v._v(" "),a("ul",[a("li",[v._v("엔티티: 하나의 엔티티에 대해 하나의 행을 가지는 부모 테이블에 대한 FK이다")]),v._v(" "),a("li",[v._v("속성: 각 행마다 속성 하나씩 들어간다")]),v._v(" "),a("li",[v._v("값: 모든 엔티티는 각 속성에 대한 값을 가진다")])]),v._v(" "),a("p",[v._v("이 설계는 엔티티-속성-값(Entity-Attribute-Value)라고 불린다.")]),v._v(" "),a("p",[v._v("별도 테이블은 다음과 같은 이득을 줄것으로 생각할 수 있다")]),v._v(" "),a("ul",[a("li",[v._v("객체를 확장한 데이터를 저장하는 테이블은 적은 컬럼을 갖는다")]),v._v(" "),a("li",[v._v("새로운 속성을 지원하기 위해서 컬럼 수를 늘릴필요가 없다")]),v._v(" "),a("li",[v._v("특정 속성이 해당 행에 적용되지 않을 때 "),a("code",[v._v("NULL")]),v._v("을 채워야 하는 컬럼이 발생하지 않는다")])]),v._v(" "),a("p",[v._v("그러나 데이터베이스 설계가 단순하다고 해서 쉽게 사용할 수 있는 것은 아니다")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("속성조회")]),v._v(" "),a("ul",[a("li",[v._v("EAV 설계에서 필요한 값을 찾을 때 전체 행에서 해당 속성을 가진 행을 추가로 찾아야 한다")]),v._v(" "),a("li",[v._v("이는 더 복잡하고 불명확하다")])])]),v._v(" "),a("li",[a("p",[v._v("데이터 정합성 지원")]),v._v(" "),a("ul",[a("li",[v._v("데이터베이스 설계에 적용되는 DBMS 기본 기능상 장점을 희생해야 한다")]),v._v(" "),a("li",[v._v("필수 속성(NOT NULL) 사용 불가")]),v._v(" "),a("li",[v._v("SQL 데이터 타입 사용 불가")]),v._v(" "),a("li",[v._v("참조 정합성 강제 불가(전체 행에서 참조정합성을 사용할 행만 선택할 수 없으므로)")]),v._v(" "),a("li",[v._v("속성 이름 강제 불가 (속성이름도 가변이므로)")])])]),v._v(" "),a("li",[a("p",[v._v("행 재구성")]),v._v(" "),a("ul",[a("li",[v._v("행 하나의 일부로 속성을 꺼내기 위해서는 각 속성에 대한 졷인이 필요하다")]),v._v(" "),a("li",[v._v("쿼리를 작성하는 시점에서 모든 속성의 이름을 알아야 한다")]),v._v(" "),a("li",[v._v("속성이 늘어나면 조인도 늘어나고 쿼리의 비용은 지수적으로 증가한다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-범용-속성-테이블-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-범용-속성-테이블-사용"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: 범용 속성 테이블 사용")]),v._v(" "),a("p",[v._v("관계형 데이터베이스에서 EAV 패턴사용을 합리화하기는 어렵다.\n비관계형 데이터 관리가 필요하다면 비관계형 기술을 사용하는 것이 좋다(NoSQL...)")]),v._v(" "),a("h3",{attrs:{id:"해법-서브타입-모델링"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-서브타입-모델링"}},[v._v("#")]),v._v(" 해법: 서브타입 모델링")]),v._v(" "),a("p",[v._v("서브타입 수에 제한이 잇고 각 서브타입의 속성을 알고 있다면, EAV 패턴을 사용하지 않아도 문제를 해결할 수 있다.")]),v._v(" "),a("h4",{attrs:{id:"단일-테이블-상속-single-table-inheritance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#단일-테이블-상속-single-table-inheritance"}},[v._v("#")]),v._v(" 단일 테이블 상속(Single Table Inheritance)")]),v._v(" "),a("p",[v._v("이 설계의 이름은 마틴 파울러의 Patterns of Enterprise Application Architecture에서 나왔다")]),v._v(" "),a("ul",[a("li",[v._v("가장 단순한 설계는 관련한 모든 타입을 하나의 테이블에 저장하고 모든 속성을 별도의 컬럼으로 가지도록 하는 것")]),v._v(" "),a("li",[v._v("해당 속성이 적용되지 않는 객체를 저장하는 경우 이런 컬럼에는 "),a("code",[v._v("NULL")]),v._v("을 넣어야 한다")])]),v._v(" "),a("p",[v._v("단점 또한 존재한다")]),v._v(" "),a("ul",[a("li",[v._v("이 경우 테이블에 들어가는 컬럼 수의 실질적 한계에 직면할 수도 있다")]),v._v(" "),a("li",[v._v("또한, 어떤 속성이 어느 서브타입에 속하는지 정의하는 메타데이터가 없다. 이는 개발자가 직접 관리해야 한다.")])]),v._v(" "),a("p",[v._v("단일 테이블 상속은 서브타입 개수가 적고 특정 서브타입에만 속하는 속성 개수가 적을 때,\n그리고 액티브 레코드와 같은 단일 테이블 데이터베이스 접근 패턴을 사용해야 할 때 가장 좋다.")]),v._v(" "),a("h4",{attrs:{id:"구체-테이블-상속-concrete-table-inheritance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#구체-테이블-상속-concrete-table-inheritance"}},[v._v("#")]),v._v(" 구체 테이블 상속(Concrete Table Inheritance)")]),v._v(" "),a("p",[v._v("서브 타입별로 별도의 테이블을 만들 수도 있다.\n공통 속성 뿐만 아니라 특정 서브타입에만 필요한 속성도 포함된다.")]),v._v(" "),a("p",[v._v("이 설계의 이름 역시 마틴 파울러의 책에서 나왔다.")]),v._v(" "),a("ul",[a("li",[v._v("특정 서브타입을 저장할 때 해당 서브타입에 적용되지 않는 속성은 저장할 수 없게 한다")]),v._v(" "),a("li",[v._v("단일 테이블 상속 설계에 잇어야 했던 각 행의 서브타입을 나타내는 부가적 속성이 필요하지 않다")])]),v._v(" "),a("p",[v._v("이 설계 역시 단점이 있다")]),v._v(" "),a("ul",[a("li",[v._v("서브타입 속성에서 어떤 속성이 공통 속성인지 알기 어렵다")]),v._v(" "),a("li",[v._v("새로운 공통속성이 추가되면 모든 서브타입 테이블을 변경해야 한다")]),v._v(" "),a("li",[v._v("관련 객체가 서브타입 테이블에 저장되었다는 것을 알려주는 메타 데이터도 없다\n"),a("ul",[a("li",[v._v("처음 관련 테이블을 보는 사람들은 공통 컬럼이 존재하는 것인지 단순히 비슷한 데이터를 가진 것인지 명확히 구분하기 어렵다")])])]),v._v(" "),a("li",[v._v("서브타입에 상관없이 모든 객체를 보는 것도 복잡하다\n"),a("ul",[a("li",[v._v("이 쿼리를 쉽게 하려면 각 서브타입 테이블에서 공통 속성만 선택한 뒤 이를 UNION으로 묶은 VIEW를 정의해야 한다")])])])]),v._v(" "),a("p",[v._v("구체 테이블 상속 설계는 모든 서브타입을 한번에 조회할 필요가 거의 없는 경우 적합하다")]),v._v(" "),a("h4",{attrs:{id:"클래스-테이블-상속-class-table-inheritance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#클래스-테이블-상속-class-table-inheritance"}},[v._v("#")]),v._v(" 클래스 테이블 상속(Class Table Inheritance)")]),v._v(" "),a("p",[v._v("테이블을 객체지향 클래스인 것으로 간주하여 상속을 흉내낼 수 있다.")]),v._v(" "),a("p",[v._v("서브타입에 공통속성을 포함하는 베이스 타입을 위한 테이블을 하나 만든다.\n그리고 각 서브타입에 대한 테이블을 만든다. 서브타입 테이블의 PK는 베이스 테이블에 대한 FK역할도 수행한다.")]),v._v(" "),a("p",[v._v("이 설계의 이름 역시 마틴 파울러의 책에서 나왔다.")]),v._v(" "),a("ul",[a("li",[v._v("메타데이터에 의해 1:1 관계가 강제된다. 베이스테이블의 FK는 PK이기도 하므로 유일하기 때문이다.")]),v._v(" "),a("li",[v._v("베이스 타입에 있는 속성만 참조하는 한, 모든 서브타입 검색에 대해 효율적 방법을 제공한다.")]),v._v(" "),a("li",[v._v("베이스 테이블의 행이 어떤 서브타입을 나타내는지 알 필요가 없다")]),v._v(" "),a("li",[v._v("서브타입 개수가 적다면 각 서브타입과 조인하는 쿼리를 작성해 단일 테이블 상속과 같은 결과를 만들 수 있다")])]),v._v(" "),a("p",[v._v("모든 서브타입에 대한 조회가 많고 공통컬럼을 참조하는 경우가 많다면 이 설계가 적합하다")]),v._v(" "),a("h4",{attrs:{id:"반구조적-데이터-semistructured-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#반구조적-데이터-semistructured-data"}},[v._v("#")]),v._v(" 반구조적 데이터(Semistructured Data)")]),v._v(" "),a("p",[v._v("서브타입의 수가 많거나 또는 새로운 속성을 지원해야 하는 경우가 빈번하다면,\n데이터의 속성 이름과 값을 XML/JSON으로 부호화해 TEXT/CLOB 컬럼으로 저장할 수 있다.")]),v._v(" "),a("p",[v._v("마틴 파울러는 이 패턴을 Serialized LOB라고 불렀다.")]),v._v(" "),a("ul",[a("li",[v._v("새로운 속성은 언제든 TEXT 컬럼에 저장할 수 있으므로 확장이 쉽다")])]),v._v(" "),a("p",[v._v("단점은,")]),v._v(" "),a("ul",[a("li",[v._v("이런 구조는 SQL이 특정속성에 직접 접근하는 것을 제대로 지원하지 않는다")]),v._v(" "),a("li",[v._v("TEXT 내부의 각 속성에 대해 행 기반의 제한을 하거나, 집계/정렬을 하는등의 조회가 쉽지 않다")])]),v._v(" "),a("p",[v._v("이 설계는 서브타입 개수를 제한할 수 없고 어느때나 새로운 속성을 정의할 수 있는 완전 유연성이 필요할 때 적합하다")]),v._v(" "),a("h3",{attrs:{id:"사후처리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#사후처리"}},[v._v("#")]),v._v(" 사후처리")]),v._v(" "),a("p",[v._v("EAV를 사용하는 레거시 프로젝트를 다룰 때는, 엔티티를 단일 행으로 조회하지 말고 그대로 한 행씩 꺼내야 한다.\n해당 엔티티를 모두 조회한 뒤 어플리케이션 레벨에서 속성을 분류하여 사용하도록 해야 한다.")]),v._v(" "),a("h2",{attrs:{id:"다형성-연관"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#다형성-연관"}},[v._v("#")]),v._v(" 다형성 연관")]),v._v(" "),a("p",[v._v("댓글을 갖고 있는 두 엔티티가 있다.\n엔티티는 별도의 테이블에 저장되지만 댓글은 공통으로 나타나므로 하나의 테이블에서만 관리하고자 할 수 있을 것이다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-이중-목적의-fk-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-이중-목적의-fk-사용"}},[v._v("#")]),v._v(" 안티패턴: 이중 목적의 FK 사용")]),v._v(" "),a("p",[v._v("이런 경우는 다형성 연관(Polymorphic Associations)이라고 불린다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("다형성 연관 정의")]),v._v(" "),a("ul",[a("li",[v._v("다형성 연관을 작동하게 하려면 FK 컬럼 앞에 문자열 타입의 별도 컬럼이 필요하다")]),v._v(" "),a("li",[v._v("별도 컬럼에 현재 행이 참조하는 부모 테이블 이름을 넣는다")]),v._v(" "),a("li",[v._v("FK는 하나의 테이블만 참조할 수 있으므로 사용할 수 없다")]),v._v(" "),a("li",[v._v("다형성 연관 안티패턴과 EAV 안티패턴은 유사한 특성을 지닌다")])])]),v._v(" "),a("li",[a("p",[v._v("다형성 연관에서의 조회")]),v._v(" "),a("ul",[a("li",[v._v("FK 역할을 하는 컬럼의 값은 양쪽 부모테이블에서 나타날수도 한쪽에서만 나타날수도있다")]),v._v(" "),a("li",[v._v("따라서 부모와 자식을 조인할 때 별도 컬럼에서 정의한 타입을 정확하게 사용하는 것이 중요하다")])])]),v._v(" "),a("li",[a("p",[v._v("관련없는 부모 테이블")]),v._v(" "),a("ul",[a("li",[v._v("다형성 연관은 부모 테이블이 서로 아무런 관계가 없을 때도 사용할 수 있다 (주문/사용자 - 주소)")]),v._v(" "),a("li",[v._v("당연히 하나의 자식을 둘 이상의 부모와 연관시킬 수 없다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-이중-목적의-fk-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-이중-목적의-fk-사용"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: 이중 목적의 FK 사용")]),v._v(" "),a("p",[v._v("다형성 연관 안티패턴은 사용을 피하고 FK등의 제약조건을 사용해 참조 정합성을 보장해야 한다.\n다형성 연관은 메타데이터 대신 애플리케이션 코드에 지나치게 의존하도록 만든다.")]),v._v(" "),a("p",[v._v("ORM 프레임워크를 사용하는 경우 안티패턴 사용이 불가피할 수도 있다.")]),v._v(" "),a("h3",{attrs:{id:"해법-관계-단순화"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-관계-단순화"}},[v._v("#")]),v._v(" 해법: 관계 단순화")]),v._v(" "),a("p",[v._v("다형성 연관의 단점을 피하면서 필요한 데이터 모델을 지원하기 위해서는 데이터베이스를 다시 설계하는 것이 낫다.")]),v._v(" "),a("h4",{attrs:{id:"역참조"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#역참조"}},[v._v("#")]),v._v(" 역참조")]),v._v(" "),a("p",[v._v("다형성 연관에서는 관계의 방향이 거꾸로라는 본질을 이해해야 한다")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("교차테이블 생성")]),v._v(" "),a("ul",[a("li",[v._v("자식테이블의 FK는 여러 부모테이블을 참조할 수 없다")]),v._v(" "),a("li",[v._v("대신 각 부모에 대해 교차테이블을 생성하고 교차테이블에는 부모테이블에 대한 FK와 자식에 대한 FK를 포함한다")]),v._v(" "),a("li",[v._v("이 경우 자식테이블의 타입을 위한 추가 컬럼이 불필요하다")]),v._v(" "),a("li",[v._v("또한 DBMS의 메타데이터로 데이터 정합성을 강제할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("신호등 설치")]),v._v(" "),a("ul",[a("li",[v._v("이 방식의 경우 허용하고 싶지 않은 연관이 생길 수도 있다")]),v._v(" "),a("li",[v._v("교차테이블의 경우 기본적으로 다대다 관계를 선언하기 때문이다")]),v._v(" "),a("li",[v._v("이 경우 제한하려는 FK 컬럼에 UNIQUE 제약조건을 설정할 수도 있다")]),v._v(" "),a("li",[v._v("그러나 이 방식으로도 자식이 부모의 교차테이블마다 한 번씩 참조되는 것을 방지하지는 못한다")])])]),v._v(" "),a("li",[a("p",[v._v("양쪽 다 보기")]),v._v(" "),a("ul",[a("li",[v._v("여러 부모와 연관된 자식을 부모와 함께 보려면 여러 교차 테이블로 외부조인을 사용한다")]),v._v(" "),a("li",[v._v("여러 부모테이블을 지정해야 하지만 다형성 연관 안티패턴처럼 쿼리가 복잡하지는 않다")])])]),v._v(" "),a("li",[a("p",[v._v("차선 통합")]),v._v(" "),a("ul",[a("li",[v._v("여러 부모테이블에 대해 조회한 결과를 하나의 테이블에서 조회한 것처럼 보이게 할 필요가 있다")]),v._v(" "),a("li",[v._v("UNION으로 결과를 묶는다면 컬럼 개수와 데이터 타입이 같아야 한다")]),v._v(" "),a("li",[v._v("한 방법은 한 쪽 테이블에만 존재하는 컬럼에 대해서 NULL을 만들어준다 ("),a("code",[v._v("SELECT NULL as foo")]),v._v(")")]),v._v(" "),a("li",[v._v("다른 방법은 처음으로 NULL이 아닌 인자를 반환하는 "),a("code",[v._v("COALESCE()")]),v._v(" 함수를 사용하는 것이다 ("),a("code",[v._v("COALESCE(a.foo, b.foo) as bar")]),v._v(")")]),v._v(" "),a("li",[v._v("쿼리가 복잡하므로 뷰로 만들어 애플리케이션에서 사용하자")])])])]),v._v(" "),a("h4",{attrs:{id:"공통-수퍼테이블-생성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#공통-수퍼테이블-생성"}},[v._v("#")]),v._v(" 공통 수퍼테이블 생성")]),v._v(" "),a("p",[v._v("객체지향 다형성에서는 서브타입이 공통의 수퍼타입을 공유하므로 두 서브타입을 비슷하게 참조할 수 있다.\n다형성 연관 안티패턴에서는 수퍼타입이 없는데, 모든 부모테이블이 상속할 base table을 생성해 사용할 수 있다.")]),v._v(" "),a("p",[v._v("자식테이블에 베이스테이블을 참조하는 FK를 추가한다(타입을 위한 별도 컬럼은 필요없다)")]),v._v(" "),a("p",[v._v("이 경우 특정 자식이 참조하는 여러 부모를 비교적 간단하게 조회할 수 있다.\n또한 베이스테이블과 부모테이블의 PK가 같으므로 부모테이블과 자식테이블도 직접 조인할 수 있다.\n마찬가지로, 특정 부모의 자식도 쉽게 조회할 수 있다.")]),v._v(" "),a("h2",{attrs:{id:"다중-컬럼-속성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#다중-컬럼-속성"}},[v._v("#")]),v._v(" 다중 컬럼 속성")]),v._v(" "),a("p",[v._v("속성이 여러값을 가지는 데 한 테이블에 들어가는 경우, 앞의 무단횡단 안티패턴과 유사한 문제가 발생한다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-여러-개의-컬럼-생성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-여러-개의-컬럼-생성"}},[v._v("#")]),v._v(" 안티패턴: 여러 개의 컬럼 생성")]),v._v(" "),a("p",[v._v("속성에 여러 값이 들어가는 것을 고려해야 하지만, 각 컬럼에는 하나의 값만을 저장해야 한다.\n이 경우 여러 컬럼을 만들어(col1, col2, col3 ...) 값을 저장하고 사용하지 않은 컬럼은 "),a("code",[v._v("NULL")]),v._v("로 둔다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("값 검색")]),v._v(" "),a("ul",[a("li",[v._v("주어진 값을 찾으려면 하나 이상의 컬럼을 모두 확인해야 한다")]),v._v(" "),a("li",[a("code",[v._v("OR")]),v._v(" 조건을 사용해서 여러 컬럼을 검색한다 ("),a("code",[v._v("OR")]),v._v("는 "),a("code",[v._v("AND")]),v._v(" 보다 우선순위가 낮음에 주의)")])])]),v._v(" "),a("li",[a("p",[v._v("값 추가와 삭제")]),v._v(" "),a("ul",[a("li",[v._v("어느 컬럼이 비어있는지 알 수 없으므로 단순히 "),a("code",[v._v("UPDATE")]),v._v("를 사용하는 것은 안전하지 않다")]),v._v(" "),a("li",[v._v("다른 클라이이언트가 접근하여 동일 행을 갱신한다면 충돌이 발생한다")])])]),v._v(" "),a("li",[a("p",[v._v("유일성 보장")]),v._v(" "),a("ul",[a("li",[v._v("동일 값이 여러 컬럼 속성에 나타나는 것을 막지 못한다")])])]),v._v(" "),a("li",[a("p",[v._v("값의 수 증가 처리")]),v._v(" "),a("ul",[a("li",[v._v("사전에 생성해 둔 컬럼 숫자가 부족할 수 있다")]),v._v(" "),a("li",[v._v("필요에 따라 테이블을 확장하는 것은 많은 비용을 수반한다")]),v._v(" "),a("li",[v._v("해당 테이블을 사용하는 애플리케이션에서 추가한 컬럼을 지원하도록 코드를 수정해야 한다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-여러-개의-컬럼-생성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-여러-개의-컬럼-생성"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: 여러 개의 컬럼 생성")]),v._v(" "),a("p",[v._v("속성의 개수가 고정되고 위치나 순서가 중요한 경우가 있을 수 있다.\n조회의 복잡성이 있더라도 다른 경우의 단순함을 위해 이런 구조를 수용할 수 있다.")]),v._v(" "),a("h3",{attrs:{id:"해법-종속-테이블-생성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-종속-테이블-생성"}},[v._v("#")]),v._v(" 해법: 종속 테이블 생성")]),v._v(" "),a("p",[v._v("가장 좋은 해법은 다중 값 속성을 위한 컬럼을 하나 가지는 종속 테이블을 만드는 것이다.\n여러 값을 여러 컬럼 대신 여러 행에 저장한다.\n또한 종속 테이블에 FK를 정의해 해당 값이 부모 행과 연관되도록 한다.")]),v._v(" "),a("h2",{attrs:{id:"메타데이터-트리블-metadata-tribble"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#메타데이터-트리블-metadata-tribble"}},[v._v("#")]),v._v(" 메타데이터 트리블(Metadata Tribble)")]),v._v(" "),a("p",[v._v("데이터 양이 늘어나면 어떤 쿼리든 성능이 떨어진다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-테이블-또는-컬럼-복제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-테이블-또는-컬럼-복제"}},[v._v("#")]),v._v(" 안티패턴: 테이블 또는 컬럼 복제")]),v._v(" "),a("p",[v._v("트리블(tribble)은 스타트랙에서 나오는 번식력 강한 동물이다.\n다른 모든 조건이 동일하다면, 행이 적은 테이블을 조회하는 것이 더 빠르다.")]),v._v(" "),a("ul",[a("li",[v._v("테이블 분리\n"),a("ul",[a("li",[v._v("많은 행을 가진 큰 테이블을 여러 개의 작은 테이블로 분리한다")]),v._v(" "),a("li",[v._v("분리한 테이블 이름은 기존 테이블 속성 중 하나의 값을 기준으로 한다")])])]),v._v(" "),a("li",[v._v("컬럼 분리\n"),a("ul",[a("li",[v._v("하나의 컬럼을 여러개의 컬럼으로 분리한다")]),v._v(" "),a("li",[v._v("컬럼 일므은 다른 속성값을 기준으로 한다")])])])]),v._v(" "),a("p",[v._v("이를 위해서는 지나치게 많은 컬럼을 가진 테이블을 생성하거나 엄청나게 많은 테이블을 생성해야 한다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("지나치게 많은 테이블")]),v._v(" "),a("ul",[a("li",[v._v("연도 같은 값을 기준으로 테이블을 분리할 수 있다")]),v._v(" "),a("li",[v._v("값에 따라 올바른 테이블을 선택하는 것은 사용자 책임이된다")]),v._v(" "),a("li",[v._v("연말이 지나 새로운 연도가 되었을 때, 다음 연도 테이블이 없다면 에러가 발생한다")])])]),v._v(" "),a("li",[a("p",[v._v("데이터 정합성 관리")]),v._v(" "),a("ul",[a("li",[v._v("특정연도 테이블에 이전 연도 자료가 들어갈 수도 있다")]),v._v(" "),a("li",[v._v("테이블 이름에 맞춰 제한할 수는 없지만 각 테이블에서 "),a("code",[v._v("CHECK")]),v._v(" 제약조건을 선언할 수는 있다")])])]),v._v(" "),a("li",[a("p",[v._v("데이터 동기화")]),v._v(" "),a("ul",[a("li",[v._v("날짜를 변경했다고 가정하자, 날짜가 이전년도로 바뀌었다면 테이블이 변경되어야 한다")]),v._v(" "),a("li",[v._v("결국 "),a("code",[v._v("UPDATE")]),v._v(" 대신 삭제 후 삽입을 실행해야 한다")])])]),v._v(" "),a("li",[a("p",[v._v("유일성 보장")]),v._v(" "),a("ul",[a("li",[v._v("PK 값은 모든 분할된 테이블에 걸쳐 유일서응ㄹ 보장받아야 한다")]),v._v(" "),a("li",[v._v("시퀀스를 별도로 지원한다면 하나의 시퀀스를 사용하면 된다")]),v._v(" "),a("li",[v._v("다른 경우는 PK만을 위한 테이블을 관리해야 할 것이다")])])]),v._v(" "),a("li",[a("p",[v._v("여러 테이블에 걸쳐 조회")]),v._v(" "),a("ul",[a("li",[v._v("불가피하게 여러 테이블에 걸쳐 데이터를 조회한다면 "),a("code",[v._v("UNION")]),v._v("으로 묶어 쿼리를 실행해야 한다")])])]),v._v(" "),a("li",[a("p",[v._v("메타데이터 동기화")]),v._v(" "),a("ul",[a("li",[v._v("특정 테이블에서 필요에 따라 컬럼을 추가할 수 있다")]),v._v(" "),a("li",[v._v("다른 테이블을 그냥 둘 수도 있지만, "),a("code",[v._v("UNION")]),v._v("등을 사용해서 함께 사용하는 경우가 있다면 이에 맞춰 대응해야 한다")])])]),v._v(" "),a("li",[a("p",[v._v("참조 정합성 관리")]),v._v(" "),a("ul",[a("li",[v._v("자식테이블을 갖고 있는 경우 분할하였다면 FK를 사용할 수 없다")]),v._v(" "),a("li",[v._v("FK는 하나의 부모테이블을 대상으로 지정 가능하다")]),v._v(" "),a("li",[v._v("분할대상이 자식테이블이어도 문제가 발생한다")]),v._v(" "),a("li",[v._v("부모 데이터에 해당하는 자식을 모두 조회하려면 복잡한 쿼리 작성이 필요하다")])])]),v._v(" "),a("li",[a("p",[v._v("메타데이터 트리블 컬럼 식별")]),v._v(" "),a("ul",[a("li",[v._v("컬럼도 동일한 형태로 메타데이터 트리블이 될 수 있다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-테이블-또는-컬럼-복제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-테이블-또는-컬럼-복제"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: 테이블 또는 컬럼 복제")]),v._v(" "),a("p",[v._v("자주 사용하는 데이터와 오래된 데이터를 분리해 별도 보관하는 방식으로 수동 분할 할 수 있다.\n두 종류의 데이터를 함께 조회할 필요가 없다면 오래된 데이터는 옮기고 삭제하는 것이 적절하다.")]),v._v(" "),a("h3",{attrs:{id:"해법-파티션과-정규화"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-파티션과-정규화"}},[v._v("#")]),v._v(" 해법: 파티션과 정규화")]),v._v(" "),a("p",[v._v("테이블이 매우 커졌을 때 테이블 직접 분리보다 좋은 방법이 있다")]),v._v(" "),a("h4",{attrs:{id:"수평-분할-horizontal-partitioning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#수평-분할-horizontal-partitioning"}},[v._v("#")]),v._v(" 수평 분할(Horizontal partitioning)")]),v._v(" "),a("p",[v._v("수평 분할에서는 행을 여러 파티션으로 분리하는 규칙과 함께 논리 테이블을 하나 정의하면 DBMS가 알아서 처리한다.\n테이블은 분리되어 있지만 SQL에서는 하나의 테이블처럼 사용할 수 있다.")]),v._v(" "),a("p",[v._v("MySQL의 파티셔닝 같은 기능으로 각 테이블에서 각 행을 별도 스토리지로 분리하는 방식도 정의할 수 있다.")]),v._v(" "),a("h4",{attrs:{id:"수직-분할-vertical-partitioning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#수직-분할-vertical-partitioning"}},[v._v("#")]),v._v(" 수직 분할(Vertical partitioning)")]),v._v(" "),a("p",[v._v("수평 분할은 테이블을 행으로 나누고, 수직 분할은 컬럼으로 테이블을 나눈다.\n컬럼으로 테이블을 나누는 방법은 크기가 큰 컬럼이나 거의 사용되지 않는 컬럼이 있을 때 유용하다.")]),v._v(" "),a("p",[v._v("BLOB, TEXT는 크기가 가변적이고 매우 커질 수 있다.\n테이블의 BLOB, TEXT를 참조하지 않는 쿼리를 실행하면 다른 컬럼에 효율적으로 접근할 수 있다.")]),v._v(" "),a("p",[v._v("일반적으로 테이블을 조회할 때 wildcard(*)를 사용하지 않고, 컬럼을 명시한다면 해당 컬럼을 배제할 수 있다.\n다른 방식으로는, 해당 테이블에 종속된 추가 테이블을 생성하고 FK를 사용해 BLOB, TEXT를 별도 저장한다.")]),v._v(" "),a("h4",{attrs:{id:"메타데이터-트리블-컬럼-고치기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#메타데이터-트리블-컬럼-고치기"}},[v._v("#")]),v._v(" 메타데이터 트리블 컬럼 고치기")]),v._v(" "),a("p",[v._v("다중 컬럼 속상과 비슷하게 메타데이터 트리블 컬럼에 대한 해결 방법도 종속 테이블을 생성하는 것이다.")]),v._v(" "),a("h2",{attrs:{id:"반올림-오류"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#반올림-오류"}},[v._v("#")]),v._v(" 반올림 오류")]),v._v(" "),a("p",[v._v("정수가 아닌 수를 저장하고 이를 산술연산에 사용하는데, 산술연산의 결과가 정확해야 한다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-float-데이터-타입-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-float-데이터-타입-사용"}},[v._v("#")]),v._v(" 안티패턴: FLOAT 데이터 타입 사용")]),v._v(" "),a("p",[v._v("대부분의 프로그래밍 언어는 float, double 같은 실수를 표현하는 데이터 타입을 지원한다.\nSQL도 마찬가지로 비슷한 데이터타입을 비슷한 이름으로 제공한다.")]),v._v(" "),a("p",[v._v("SQL의 FLOAT 데이터 타입은 다른 프로그래밍 언어와 마찬가지로 IEEE 754 표준에 의해 실수를 이진형식으로 부호화한다.\n이 데이터 타입을 정확히 사용하려면, 부동 소수점 특성을 이해해야 한다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("필요에 의한 반올림")]),v._v(" "),a("ul",[a("li",[v._v("부동 소수점의 특성상 어떤 십진수는 이진수로 표현할 수 없다")]),v._v(" "),a("li",[v._v("무한 소수는 무한대의 자리수가 필요하므로 근사값으로 저장될 것이다")]),v._v(" "),a("li",[v._v("IEEE 754에서 부동 소수점은 밑수가 2인 형식이므로, 10진수에서 유한해도 정확한 표현을 할 수 없을 때가 있다")]),v._v(" "),a("li",[v._v("FLOAT을 애플리케이션에서 사용할 때는 어떤 값이든 반올림 된 상태라는 가정을 해야 한다")])])]),v._v(" "),a("li",[a("p",[v._v("SQL에서 FLOAT 사용")]),v._v(" "),a("ul",[a("li",[v._v("어떤 데이터베이스는 값을 보정해 표현하기도 한다, 그러나 정확한 값을 가지고 있는 것은 아니다")]),v._v(" "),a("li",[v._v("이러한 오차는 합과 곱에서 중복 발생하므로 계산마다 커지게 된다 (곱의 경우 엄청난 차이가 누적된다)")]),v._v(" "),a("li",[v._v("만약 동등비교에 이 값을 사용한다면 부정확한 결과가 출력된다")]),v._v(" "),a("li",[v._v("문제를 회피하는 방법은 두 값의 차이의 절대값을 구한다음 오차 범위보다 작은지 확인하는 것이다 ("),a("code",[v._v("a - b < 0.00001")]),v._v(")")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-인식-방법-float-데이터-타입-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-인식-방법-float-데이터-타입-사용"}},[v._v("#")]),v._v(" 안티패턴 인식 방법: FLOAT 데이터 타입 사용")]),v._v(" "),a("p",[v._v("FLOAT, REAL, DOUBLE, PRECISION 데이터 타입이 사용되는 곳이면 어디든 오류의 후보이다.")]),v._v(" "),a("h3",{attrs:{id:"해법-numeric-데이터-타입-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-numeric-데이터-타입-사용"}},[v._v("#")]),v._v(" 해법: NUMERIC 데이터 타입 사용")]),v._v(" "),a("p",[v._v("고정 소수점은 FLOAT 혹은 유사 타입대신 NUMERIC 또는 DECIMAL 타입을 사용해야 한다.\n이런 데이터 타입은 컬럼에서 지정한 정도까지 정확한 수치를 표현한다.")]),v._v(" "),a("p",[v._v("NUMERIC/DECIMAL 타입은 저장될 때 이진변환시 반올림 되지 않고 정확히 저장된다.")]),v._v(" "),a("h2",{attrs:{id:"_31가지-맛"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_31가지-맛"}},[v._v("#")]),v._v(" 31가지 맛")]),v._v(" "),a("p",[v._v("컬럼의 값을 고정된 집합의 값으로 제한하는 것은 유용하다. (유효성 관리)")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-컬럼-정의에-값-지정"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-컬럼-정의에-값-지정"}},[v._v("#")]),v._v(" 안티패턴: 컬럼 정의에 값 지정")]),v._v(" "),a("p",[v._v("컬럼을 정의할 때 유효한 데이터 값을 지정하는 경우가 있다. (테이블 구조 정의)")]),v._v(" "),a("p",[v._v("MySQL은 컬럼을 특정 값의 집합으로 제한하는 ENUM이라는 비표준 데이터 타입을 지원한다.\n값의 선언은 문자열 이지만, 내부적으로는 해당 문자열이 몇 번째인지를 나타내는 ordinal number로 저장하도록 되어있다.")]),v._v(" "),a("p",[v._v("미리 혀용한 값을 검사하는 트리거를 사용할 수도 있다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("중간에 있는 값은?")]),v._v(" "),a("ul",[a("li",[v._v("아직까지는 특정 값만 저쟝되어, 전체 목록을 보려면 데이터베이스 메타데이터를 조회해야 할 수도 있다")])])]),v._v(" "),a("li",[a("p",[v._v("새로운 종류 추가")]),v._v(" "),a("ul",[a("li",[v._v("ENUM이나 CHECK 제약조건에 값을 추가하거나 삭제하는 문법은 없다 (재정의 해야한다)")]),v._v(" "),a("li",[v._v("어떤 DBMS에서는 테이블이 비어있지 않으면 컬럼 정의를 변경할 수 없다")]),v._v(" "),a("li",[v._v("메타데이터를 변경하는 것은 드물어야 하고 주의를 요한다")])])]),v._v(" "),a("li",[a("p",[v._v("이전 값의 제거")]),v._v(" "),a("ul",[a("li",[v._v("값을 더 이상 사용하지 않게 만들면 과거 데이터가 망가질 수 있다")]),v._v(" "),a("li",[v._v("과거 값을 위해 제약을 그대로 둔다면, 활성 제약이 어떤 것인지 구분하기 어렵다")])])]),v._v(" "),a("li",[a("p",[v._v("포팅이 어렵다")]),v._v(" "),a("ul",[a("li",[v._v("제약은 여러 DBMS에서 균일하게 지원하는 기능이 아니다")]),v._v(" "),a("li",[v._v("다른 DBMS를 지원해야 할 필요가 있는 경우 사용이 어렵다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-인식-방법-컬럼-정의에-값-지정"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-인식-방법-컬럼-정의에-값-지정"}},[v._v("#")]),v._v(" 안티패턴 인식 방법: 컬럼 정의에 값 지정")]),v._v(" "),a("p",[v._v("ENUM이나 CHECK 제약조건을 사용할 때는 값의 집합이 변할 것 같은지 사전 고려해야 한다.")]),v._v(" "),a("h3",{attrs:{id:"해법-데이터로-값을-지정하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-데이터로-값을-지정하기"}},[v._v("#")]),v._v(" 해법: 데이터로 값을 지정하기")]),v._v(" "),a("p",[v._v("컬럼 값을 제한할 컬럼에 들어갈 데이터를 행으로 하는 색인 테이블을 생성하고, 색인 테이블을 참조하도록 FK 제약조건을 설정한다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("값의 집합 쿼리")]),v._v(" "),a("ul",[a("li",[v._v("허용된 값의 집합은 메타데이터가 아니라 데이터이다")]),v._v(" "),a("li",[v._v("다른 테이블을 조회할 때처럼 값의 집합을 쉽게 조회할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("색인 테이블 값 갱신")]),v._v(" "),a("ul",[a("li",[v._v("색인 값을 쉽게 갱신할 수 있다")]),v._v(" "),a("li",[v._v("FK를 "),a("code",[v._v("ON UPDATE CASCADE")]),v._v(" 옵션으로 선언했다면 값의 이름도 쉽게 바꿀 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("더 이상 사용하지 않는 값 지원")]),v._v(" "),a("ul",[a("li",[v._v("참조되는 곳이 있는한 색인 테이블에서 데이터 삭제가 불가능하다")]),v._v(" "),a("li",[v._v("색인 테이블에 컬럼을 추가해 사용여부를 표시할 수 있다")])])])]),v._v(" "),a("h2",{attrs:{id:"유령-파일"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#유령-파일"}},[v._v("#")]),v._v(" 유령 파일")]),v._v(" "),a("p",[v._v("이미지를 저장하고 이를 데이터베이스 엔티티와 연관을 갖게 하는 경우가 있다")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-파일을-사용해야-한다고-가정한다"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-파일을-사용해야-한다고-가정한다"}},[v._v("#")]),v._v(" 안티패턴: 파일을 사용해야 한다고 가정한다")]),v._v(" "),a("p",[v._v("개념적으로 이미지는 테이블의 속성이다.\n이미지에 대한 데이터 타입 선정은 논란이 있는 주제이다.")]),v._v(" "),a("p",[v._v("이미지의 바이너리 데이터는 BLOB 데이터 타입에 저장될 수 있다.\n그러나 많은 경우 이미지를 파일 시스템에 파일로 저장하고 파일에 대한 경로만 VARCHAR로 데이터베이스에 저장한다.")]),v._v(" "),a("p",[v._v("일반적으로 파일을 데이터 베이스 밖에 저장해야 한다는 의견이 있다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("DELETE 문제")]),v._v(" "),a("ul",[a("li",[v._v("데이터베이스에서 이미지를 참조하는 행을 삭제할 때")]),v._v(" "),a("li",[v._v("이미지 파일도 함께 삭제하도록 애플리케이션을 설계하지 않는다면")]),v._v(" "),a("li",[v._v("참조가 없는 이미지 파일들이 계속 쌓일 것이다")])])]),v._v(" "),a("li",[a("p",[v._v("TRANSACTION 문제")]),v._v(" "),a("ul",[a("li",[v._v("파일을 삭제하면 즉시 다른 클라이언트에서 접근하지 못한다")]),v._v(" "),a("li",[v._v("이는 트랜잭션이 아직 커밋되지 않은 상태라고 그렇다")]),v._v(" "),a("li",[v._v("트랜잭션이 실패한다면 이미지 누락이 발생한다")])])]),v._v(" "),a("li",[a("p",[v._v("ROLLBACK 문제")]),v._v(" "),a("ul",[a("li",[v._v("에러가 발생한 경우 또는 애플리케이션 로직이 변경사항을 취소하는 경우 트랜잭션을 롤백하는 것이 보통이다")]),v._v(" "),a("li",[v._v("데이터베이스에서는 롤백이 적용되지만 지워진 파일은 되살아나지 않는다")])])]),v._v(" "),a("li",[a("p",[v._v("BACKUP 문제")]),v._v(" "),a("ul",[a("li",[v._v("DBMS는 데이터베이스 백업을 위한 클라이언트 도구를 제공한다")]),v._v(" "),a("li",[v._v("백업도구는 테이블에 문자열로 가지고 있는 파일 경로를 포함하는 방법을 모른다")]),v._v(" "),a("li",[v._v("백업 이후에도 파일시스템은 별도로 변하기 때문에 데이터가 제대로 동기화 되지 않는다")])])]),v._v(" "),a("li",[a("p",[v._v("SQL 접근권한 문제")]),v._v(" "),a("ul",[a("li",[v._v("외부 파일은 GRANT/REVOKE 같은 DBMS의 접근권한을 우회한다")])])]),v._v(" "),a("li",[a("p",[v._v("SQL 데이터 타입 문제")]),v._v(" "),a("ul",[a("li",[v._v("데이터 베이스의 파일 경로는 문자열일 뿐이다")]),v._v(" "),a("li",[v._v("문자열을 경로로 다루는 로직은 애플리케이션 코드에 의존할 수 밖에 없다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-파일을-사용해야-한다고-가정한다"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-파일을-사용해야-한다고-가정한다"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: 파일을 사용해야 한다고 가정한다")]),v._v(" "),a("ul",[a("li",[v._v("이미지가 없다면 데이터베이스가 훨씬 가벼워진다")]),v._v(" "),a("li",[v._v("이미지를 제외하면 데이터베이스 백업이 빨라지고 크기도 작아진다")]),v._v(" "),a("li",[v._v("데이터 베이스 외부의 파일로 존재하면 이미지 미리보기나 편집이 쉽다")])]),v._v(" "),a("p",[v._v("어떤 DBMS는 투명하게 외부 파일을 참조하는 특수 데이터 타입을 지원한다 (Oracle의 BFILE ...)")]),v._v(" "),a("h3",{attrs:{id:"해법-필요한-경우에는-blob-데이터-타입을-사용하라"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-필요한-경우에는-blob-데이터-타입을-사용하라"}},[v._v("#")]),v._v(" 해법: 필요한 경우에는 BLOB 데이터 타입을 사용하라")]),v._v(" "),a("p",[v._v("안티패턴에 해당하는 것이 있다면, 이미지를 외부 파일이 아닌 데이터베이스 내부에 저장하는 것을 고려해야한다.")]),v._v(" "),a("p",[v._v("모든 데이터베이스 제품은 바이너리 데이터 저장에 사용할 수 있는 BLOB 데이터 타입을 지원한다.")]),v._v(" "),a("p",[v._v("어떤 DBMS는 외부 파일을 불러오는 함수를 제공한다 (MySQL "),a("code",[v._v("LOAD_FILE()")]),v._v(" ...)\n반대로 BLOB을 이미지파일로 내보낼 수도 있다 ("),a("code",[v._v("SELECT ~ INTO DUMPFILE ~")]),v._v(")")]),v._v(" "),a("h2",{attrs:{id:"인덱스-샷건"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#인덱스-샷건"}},[v._v("#")]),v._v(" 인덱스 샷건")]),v._v(" "),a("p",[v._v("데이터베이스 성능을 향상시키는 가장 좋은 방법은 인덱스를 잘 활용하는 것이다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-무계획하게-인덱스-사용하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-무계획하게-인덱스-사용하기"}},[v._v("#")]),v._v(" 안티패턴: 무계획하게 인덱스 사용하기")]),v._v(" "),a("p",[v._v("인덱스를 언제 사용하는지 오해하면 다음 실수를 하게 된다")]),v._v(" "),a("ul",[a("li",[v._v("인덱스를 불충분하게 정의하거나 아예 정의하지 않는다")]),v._v(" "),a("li",[v._v("너무 많은 인덱스를 정의하거나 도움이 되지 않는 인덱스를 정의한다")]),v._v(" "),a("li",[v._v("어떤 인덱스도 활용되지 않는 쿼리를 실행한다")])]),v._v(" "),a("h4",{attrs:{id:"없는-인덱스"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#없는-인덱스"}},[v._v("#")]),v._v(" 없는 인덱스")]),v._v(" "),a("p",[v._v("인덱스를 최신으로 유지하는데 오버헤드가 있다는 이야기를 듣곤한다.\n우리는 오버헤드가 낭비를 뜻한다고 생각하도록 훈련되었다. 따라서 오버헤드를 제거하고 싶어한다.")]),v._v(" "),a("p",[v._v("오버헤드는 낭비가 아니다.\n일반적인 애플리케이션의 경우 테이블을 한 번 업데이트할 때 조회는 백번은 할 것이다.")]),v._v(" "),a("p",[v._v("인덱스를 사용하는 쿼리를 실행할 때마다, 인덱스를 유지하는데 드는 오버헤드를 상쇄하고도 남을 이득을 얻는다.\n또한 인덱스는 원하는 행을 빨리 찾게 하므로 UPDATE, DELETE에도 도움을 준다.")]),v._v(" "),a("blockquote",[a("p",[v._v("인덱스는 ANSI SQL 표준에 명시되어 있지 않으므로, 벤더사마다 각자의 구현이 있다")])]),v._v(" "),a("h4",{attrs:{id:"너무-많은-인덱스"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#너무-많은-인덱스"}},[v._v("#")]),v._v(" 너무 많은 인덱스")]),v._v(" "),a("p",[v._v("인덱스를 사용하는 쿼리를 실행해야 인덱스에 의미가 있다")]),v._v(" "),a("ul",[a("li",[v._v("PK: 대부분의 데이터베이스는 PK에 대해 자동으로 인덱스를 생성하므로 PK에 대한 추가 인덱스는 불필요하다")]),v._v(" "),a("li",[v._v("긴 문자열 타입: 긴 문자열타입에 대한 인덱스는 유지비용이 크다")]),v._v(" "),a("li",[v._v("검색 조건이 되지 않을 컬럼")]),v._v(" "),a("li",[v._v("복합 인덱스: 복합 인덱스에서는 컬럼 순서가 중요하다. 검색조건, 조인조건, 정렬조건에 맞춰 순서를 정해야 한다.")])]),v._v(" "),a("h4",{attrs:{id:"인덱스가-도움이-되지-않는-경우"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#인덱스가-도움이-되지-않는-경우"}},[v._v("#")]),v._v(" 인덱스가 도움이 되지 않는 경우")]),v._v(" "),a("p",[v._v("아무런 인덱스도 사용하지 않는 쿼리를 실행하는 경우가 있다")]),v._v(" "),a("ul",[a("li",[v._v("복합 인덱스의 순서를 따르지 않고 검색, 조인, 정렬을 요청하는 경우")]),v._v(" "),a("li",[v._v("수식이나 계산된 컬럼에 대해 인덱스를 사용하려 하는 경우 (DBMS에 따라 지원범위가 다르다)")]),v._v(" "),a("li",[v._v("복합 검색조건에서 부분적으로만 인덱스가 사용되는 경우")]),v._v(" "),a("li",[v._v("인덱스가 적용되어 있지만 전방("),a("code",[v._v("like '%foobar'")]),v._v(") 및 전후방("),a("code",[v._v("like '%foobar%'")]),v._v(") 일치 검색을 하는 경우")])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-인식-방법"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-인식-방법"}},[v._v("#")]),v._v(" 안티패턴 인식 방법")]),v._v(" "),a("p",[v._v("cardinality(selectivity)는 테이블 전체 행 수와 인덱스에 구별되는 항목수의 비율이다.")]),v._v(" "),a("p",[v._v("cardinality가 낮으면 비효율적인 인덱스이다.\n인덱스를 통해 선택된 데이터가 지나치게 많다면 추가적인 데이터 탐색을 위한 비용이 커진다.")]),v._v(" "),a("h3",{attrs:{id:"해법-인덱스를-mentor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-인덱스를-mentor"}},[v._v("#")]),v._v(" 해법: 인덱스를 MENTOR")]),v._v(" "),a("p",[v._v("데이터베이스를 분석해 좋은 인덱스를 선정하기 위한 체크리스트를 기억하기위해\nMENTOR(Measure, Explain, Nominate, Test, Optimize, Rebuild)를 사용한다.")]),v._v(" "),a("h4",{attrs:{id:"measure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#measure"}},[v._v("#")]),v._v(" MEASURE")]),v._v(" "),a("p",[v._v("대부분의 DBMS는 SQL 쿼리가 실행된 시간을 로그로 남기므로, 비용이 많이드는 작업을 알아낼 수 있다.")]),v._v(" "),a("ul",[a("li",[v._v("SQL Server, Oracle: SQL Server Profiler, TKProf")]),v._v(" "),a("li",[v._v("MySQL, PostgreSQL: slow query log, pgFouine")])]),v._v(" "),a("p",[v._v("애플리케이션에서 가장 시간이 많이 소요되는 쿼리가 드물게 실행되는 쿼리라면, 가장 고비용의 쿼리가 아닐 수 있다.\n자주 실행되는데 비용이 많이 발생하는 쿼리를 찾아야 한다.")]),v._v(" "),a("p",[v._v("쿼리 성능을 측정할 때는 쿼리 결과 캐싱 기능을 비활성화 시켜야 한다.\n캐싱 기능은 쿼리 실행과 인덱스 사용을 우회할 수 있으므로 측정에 방해가 된다.")]),v._v(" "),a("h4",{attrs:{id:"explain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#explain"}},[v._v("#")]),v._v(" EXPLAIN")]),v._v(" "),a("p",[v._v("비용이 많이 드는 쿼리를 확인했으면 쿼리가 느린 이유를 찾아야 한다.")]),v._v(" "),a("p",[v._v("모든 데이터베이스는 optimizer를 통해 쿼리가 사용할 인덱스를 고른다.\n데이터베이스의 분석결과를 리포트로 볼 수 있는데, 이를 쿼리 실행 계획 (Query Execution Plan)이라 한다.")]),v._v(" "),a("p",[v._v("실행 계획을 요청하는 문법은 DBMS마다 다르다")]),v._v(" "),a("ul",[a("li",[v._v("DB2, MySQL, PostgreSQL, SQLite: EXPLAIN")]),v._v(" "),a("li",[v._v("SQL Server: DISPLAY EXECUTION PLAN")]),v._v(" "),a("li",[v._v("Oracle: EXPLAIN PLAN")])]),v._v(" "),a("p",[v._v("쿼리 실행계획에 포함되는 정보나 리포트 형식에 대한 표준은 없다.\n보통, 실행계획은 쿼리에 어떤 테이블이 관련되어 있는지, 옵티마이저가 사용할 인덱스를 어떻게 선택하는지, 테이블에 어떤 순서로 접근하는지를 보여준다.")]),v._v(" "),a("h4",{attrs:{id:"nominate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nominate"}},[v._v("#")]),v._v(" NOMINATE")]),v._v(" "),a("p",[v._v("옵티마이저의 실행계획을 확인했으면, 쿼리에서 인덱스를 사용하지 않고 테이블에 접근하는 부분을 찾아야 한다.\n어떤 DBMS는 이런 작업을 대신 해주는 도구를 가지고 있다")]),v._v(" "),a("blockquote",[a("p",[v._v("커버링인덱스(Covering Index): 인덱스에서 필요한 컬럼 데이터를 추가로 제공하면 테이블에서 행을 읽을 필요가 없다.")])]),v._v(" "),a("h4",{attrs:{id:"test"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test"}},[v._v("#")]),v._v(" TEST")]),v._v(" "),a("p",[v._v("인덱스를 생성한 후 쿼리를 다시 프로파일링 해야 한다.")]),v._v(" "),a("h4",{attrs:{id:"optimize"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optimize"}},[v._v("#")]),v._v(" OPTIMIZE")]),v._v(" "),a("p",[v._v("인덱스는 빈번하게 사용되는 데이터 구조로, 캐시 메모리에 보관할 좋은 후보이다.\n데이터베이스 서버는 시스템 메모리의 일정량을 캐싱에 할당하도록 설정할 수 있다.")]),v._v(" "),a("p",[v._v("대부분의 데이터베이스는 다양한 시스템에서 잘 동작하는 것을 보장하기 위해 캐시 버퍼 크기가 작게 설정되어 있다.\n캐시에 얼마나 많은 메모리를 할당해야 하는지에 대한 정답은 없다.")]),v._v(" "),a("h4",{attrs:{id:"rebuild"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rebuild"}},[v._v("#")]),v._v(" REBUILD")]),v._v(" "),a("p",[v._v("인덱스는 균형잡혀있을 때 가장 효율이 좋다.\n시간이 지나면서 데이터를 변경함에 따라 인덱스도 점차 균형을 잃는다.\n따라서 주기적으로 인덱스를 정비해야 할 필요가 있다.")]),v._v(" "),a("p",[v._v("인덱스 정비기능도 DBMS에 따라 용어, 문법, 특성이 다르다")]),v._v(" "),a("ul",[a("li",[v._v("DB2: REBUILD INDEX")]),v._v(" "),a("li",[v._v("SQL SERVER: ALTER INDEX ~ REORGANIZE(REBUILD)")]),v._v(" "),a("li",[v._v("MySQL: ANALYZE(OPTIMIZE) TABLE")]),v._v(" "),a("li",[v._v("Oracle: ALTER INDEX ~ REBUILD")]),v._v(" "),a("li",[v._v("PostgreSQL VACUUM(ANALYZE)")]),v._v(" "),a("li",[v._v("SQLite: VACUUM")])]),v._v(" "),a("h2",{attrs:{id:"모르는-것에-대한-두려움"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#모르는-것에-대한-두려움"}},[v._v("#")]),v._v(" 모르는 것에 대한 두려움")]),v._v(" "),a("p",[v._v("데이터베이스의 어떤 데이터에 값이 없는 것은 피할 수 없다. SQL은 특수한 값인 "),a("code",[v._v("NULL")]),v._v("을 지원한다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-null을-일반-값처럼-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-null을-일반-값처럼-사용"}},[v._v("#")]),v._v(" 안티패턴: NULL을 일반 값처럼 사용")]),v._v(" "),a("p",[v._v("대부분의 프로그래밍 언어와 달리, SQL에서는 NULL을 0이나 false 또는 빈문자열과 다른 특별한 값으로 취급한다.\n(Oracle, Sybase에서는 NULL을 문자열로 처리할 때 길이 0인 문자열과 동일하다)")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("수식에서 NULL 사용")]),v._v(" "),a("ul",[a("li",[v._v("NULL 값을 가지는 컬럼이나 수식에 대해 산술연산을 수행하면 NULL이 반환된다.")]),v._v(" "),a("li",[v._v("NULL은 0과 같지 않다. 또한 NULL은 길이가 0인 문자열과도 같지 않다.")]),v._v(" "),a("li",[v._v("NULL은 false와도 같지 않은데, NULL이 들어간 진위판별식은 AND, OR, NOT을 사용하더라도 항상 NULL이다.")])])]),v._v(" "),a("li",[a("p",[v._v("NULL을 가질 수 있는 컬럼 검색")]),v._v(" "),a("ul",[a("li",[v._v("검색 조건을 지정했을 때 해당 컬럼이 NULL인 행은 반환하지 않는다")]),v._v(" "),a("li",[v._v("NULL과는 어떤 비교를 해도 결과가 true/false가 아닌 NULL이기 때문이다")])])]),v._v(" "),a("li",[a("p",[v._v("쿼리 파라미터로 NULL 사용")]),v._v(" "),a("ul",[a("li",[v._v("파라미터를 받는 SQL에서는 NULL을 다른 일반 값처럼 사용하기 어렵다")])])])]),v._v(" "),a("p",[v._v("문제 회피를 위해서 많은 경우 데이터베이스에서 NULL을 허용하지 않도록 한다.\n대신, 알수 없거나 적용 불가의 뜻을 의미하는 다른 기본값을 정해둔다.")]),v._v(" "),a("p",[v._v("그러나 NOT NULL을 선언하는 경우는, 해당 컬럼에 값이 없는 상태로 행이 존재할 때가 의미없는 경우여야 한다.\n해당 컬럼을 기준으로 검색을 하거나, 집계를 한다면 할당된 기본값이 사용될 수 있다.")]),v._v(" "),a("p",[v._v("누락된 값은 NULL 이어야 한다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-null을-일반-값처럼-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-null을-일반-값처럼-사용"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: NULL을 일반 값처럼 사용")]),v._v(" "),a("p",[v._v("NULL을 사용하는 것은 안티패턴이 아니다.\nNULL을 일반 값처럼 사용하거나 일반 값을 NULL처럼 사용하는 것이 안티패턴이다.")]),v._v(" "),a("p",[v._v("NULL을 일반 값 처럼 취급해야하는 경우 중 하나가 데이터를 import/export 하는 경우이다.")]),v._v(" "),a("h3",{attrs:{id:"해법-유일한-값으로-null을-사용하라"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-유일한-값으로-null을-사용하라"}},[v._v("#")]),v._v(" 해법: 유일한 값으로 NULL을 사용하라")]),v._v(" "),a("p",[v._v("NULL과 관련된 대부분의 문제는 SQL의 세 가지 값 로직의 동작을 제대로 몰라서이다")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("스칼라 수식에서의 NULL")]),v._v(" "),a("ul",[a("li",[v._v("NULL과 다른 유형의 값의 연산 결과는 항상 NULL임")]),v._v(" "),a("li",[v._v("어떤 값을 모르는 값과 연산하면 결과 값은 모른다 이기 때문")])])]),v._v(" "),a("li",[a("p",[v._v("BOOLEAN 수식에서의 NULL")]),v._v(" "),a("ul",[a("li",[v._v("NULL은 true도 false도 아니다")]),v._v(" "),a("li",[v._v("그러나 연산결과가 항상 NULL이 나오는 것은 아니다\n"),a("ul",[a("li",[a("code",[v._v("NULL AND TRUE")]),v._v(" > "),a("code",[v._v("NULL")])]),v._v(" "),a("li",[a("code",[v._v("NULL AND FALSE")]),v._v(" > "),a("code",[v._v("FALSE")])]),v._v(" "),a("li",[a("code",[v._v("NULL OR TRUE")]),v._v(" > "),a("code",[v._v("TRUE")])]),v._v(" "),a("li",[a("code",[v._v("NULL OR FALSE")]),v._v(" > "),a("code",[v._v("NULL")])]),v._v(" "),a("li",[a("code",[v._v("NOT (NULL)")]),v._v(" > "),a("code",[v._v("NULL")])])])])])]),v._v(" "),a("li",[a("p",[v._v("NULL 검색하기")]),v._v(" "),a("ul",[a("li",[v._v("SQL 표준에는 "),a("code",[v._v("IS NULL")]),v._v(" 연산자가 정의되어 있는데, 피연산자가 NULL 이면 true를 반환한다")]),v._v(" "),a("li",[a("code",[v._v("IS NOT NULL")]),v._v("은 피연산자가 NULL이면 false를 반환한다")]),v._v(" "),a("li",[v._v("SQL-99 표준에서는 "),a("code",[v._v("IS DISTINCT FROM")]),v._v("이라는 비교연산자가 정의되었다\n"),a("ul",[a("li",[v._v("이 연산자는 일반 비교연산자인 "),a("code",[v._v("<>")]),v._v("와 비슷하게 동작한다")]),v._v(" "),a("li",[v._v("피연산자가 NULL이더라도 true 또는 false를 반환한다")]),v._v(" "),a("li",[a("code",[v._v("IS DISTINCT FROM")]),v._v(" 지원은 DBMS마다 다르다 (MySQL의 경우 "),a("code",[v._v("<=>")]),v._v(")")])])])])]),v._v(" "),a("li",[a("p",[v._v("컬럼을 NOT NULL로 선언")]),v._v(" "),a("ul",[a("li",[v._v("NULL 값이 의미 없는 경우 컬럼에 NOT NULL 제약조건을 선언하는 것이 권장사항이다")]),v._v(" "),a("li",[v._v("컬럼의 상황에 따라 NULL DEFAULT 값을 설정해야 한다(디폴트가 반드시 있어야 하는 것이 아니다)")])])]),v._v(" "),a("li",[a("p",[v._v("동적 DEFAULT")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("COALESCE()")]),v._v(" 함수를 사용해 주어진 컬럼이나 수석, 특정 쿼리에서만 디폴트 값을 설정할 수 있다")]),v._v(" "),a("li",[v._v("이 함수는 가변인수를 받아 NULL이 아닌 첫 인수를 반환한다")]),v._v(" "),a("li",[v._v("DBMS에 따라 "),a("code",[v._v("NVL()")]),v._v(", "),a("code",[v._v("IFNULL()")]),v._v(" 등의 함수가 동일한 기능을 수행한다")])])])]),v._v(" "),a("h2",{attrs:{id:"애매한-그룹"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#애매한-그룹"}},[v._v("#")]),v._v(" 애매한 그룹")]),v._v(" "),a("p",[v._v("SQL 쿼리에서 GROUP BY를 사용해서, 행의 그룹에 집계함수를 적용하고 그룹당 한 행만 얻는 작업을 한다.\n그러나 GROUP BY 쿼리는 에러가 발생하거나 결과를 신뢰할수 없는 경우가 발생하기도 한다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-그룹되지-않은-컬럼-참조"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-그룹되지-않은-컬럼-참조"}},[v._v("#")]),v._v(" 안티패턴: 그룹되지 않은 컬럼 참조")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("단일 값 규칙")]),v._v(" "),a("ul",[a("li",[v._v("각 그룹의 행은 GROUP BY 절 뒤에 쓴 컬럼(목록)의 값이 같은 행이다")]),v._v(" "),a("li",[v._v("쿼리에서 SELECT 목록에 있는 모든 컬럼은 그룹당 하나의 값을 가져야 한다(Single-Value Rule)")]),v._v(" "),a("li",[v._v("따라서, GROUP BY 뒤에 나오는 컬럼(목록) 또는 집계 함수의 인수로 사용되는 컬럼 이외의 다른 컬럼은 불명확한 값으로 취급된다")])])]),v._v(" "),a("li",[a("p",[v._v("내 뜻대로 동작하는 쿼리")]),v._v(" "),a("ul",[a("li",[v._v("쿼리에 집계함수를 실행했을 때 다른 컬럼의 값은 집계함수에서 출력된 값과 동일행임을 보장할 수 없다")]),v._v(" "),a("li",[v._v("출력되는 값은 Single-Value Rule을 따라야 한다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-인식-방법-그룹되지-않은-컬럼-참조"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-인식-방법-그룹되지-않은-컬럼-참조"}},[v._v("#")]),v._v(" 안티패턴 인식 방법: 그룹되지 않은 컬럼 참조")]),v._v(" "),a("p",[v._v("대부분의 DBMS에서는 단일 값 규칙을 위반하는 쿼리에 대해 에러를 출력한다")]),v._v(" "),a("p",[v._v("SQLite, MySQL에서는 모호한 컬럼에 신뢰할 수 없는 값이 들어갈 수도 있다.\nMySQL에서는 그룹의 (물리적 스토리지의)첫 번째 행의 값이 반환된다.\nSQLite에서는 그룹의 마지막 행의 값을 반환한다.\n이는 문서화 된 것이 아니며, 향후 버전에서 변경될 가능성이 조금이라도 존재한다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-그룹되지-않은-컬럼-참조"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-그룹되지-않은-컬럼-참조"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: 그룹되지 않은 컬럼 참조")]),v._v(" "),a("p",[v._v("MySQL, SQLite는 단일 값 규칙에 맞지 않아도 신뢰할 수 없는 결과를 출력한다.")]),v._v(" "),a("p",[v._v("원칙적으로 단일 값 규칙을 위배하는 컬럼 값이, 출력되는 다른 컬럼과 명확히 1:1 대응이 되는 경우가 있을 수 있다.\n이런 종류의 명확한 관계를 functional dependency라고 부른다.")]),v._v(" "),a("p",[v._v("functional dependency의 일반적인 예는 테이블의 PK와 테이블 속성간의 관계이다")]),v._v(" "),a("h3",{attrs:{id:"해법-컬럼을-모호하게-사용하지-않기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-컬럼을-모호하게-사용하지-않기"}},[v._v("#")]),v._v(" 해법: 컬럼을 모호하게 사용하지 않기")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("functional dependency 컬럼만 쿼리")]),v._v(" "),a("ul",[a("li",[v._v("모호한 컬럼은 쿼리에서 제거한다")])])]),v._v(" "),a("li",[a("p",[v._v("상호 연관된 서브쿼리(correlated subquery) 사용")]),v._v(" "),a("ul",[a("li",[v._v("상호 연관 서브쿼리는 바깥쪽 쿼리에 대한 참조를 가지고 있어 바깥쪽 쿼리의 각 행에 대해 다른 결과를 생성할 수 있다")]),v._v(" "),a("li",[v._v("상호 연관 서브쿼리는 바깥쪽 쿼리의 한 행에 대해 한번씩 실행되므로 성능상 최적 방법이 아니다")]),v._v(" "),a("li",[a("code",[v._v("SELECT ~ FROM X a WHERE NOT EXIST (SELECT * FROM X b WHERE <식별자> AND <조건>)")])])])]),v._v(" "),a("li",[a("p",[v._v("유도 테이블(derived table) 사용")]),v._v(" "),a("ul",[a("li",[v._v("서브쿼리를 유도 테이블로 사용해 임시 결과를 만들고, 테이블과 조인해 원하는 쿼리 결과를 얻는다")]),v._v(" "),a("li",[v._v("유도 테이블을 사용하면 상호 연관 서브쿼리보다 확장성이 좋다")]),v._v(" "),a("li",[a("code",[v._v("SELECT ~ FROM X a JOIN (SELECT <식별자>, <집계(조건)> FROM X GROUP BY <식별자>) b ON <식별자> AND <조건> GROUP BY <식별자>")])])])]),v._v(" "),a("li",[a("p",[v._v("조인 사용")]),v._v(" "),a("ul",[a("li",[v._v("outer join을 사용하면 대응되는 행이 없는곳에서는 이 행에 대한 모든 컬럼에 NULL이 채워진 결과가 출력된다")]),v._v(" "),a("li",[v._v("성능이 중요한 경우 join을 사용하는 것이 가장 좋다")]),v._v(" "),a("li",[a("code",[v._v("SELECT ~ FROM X a LEFT OUTER JOIN Y b ON <식별자> AND (a.조건 < b.조건 AND a.식별자 < b.식별자) WHERE b.식별자 IS NULL")])])])]),v._v(" "),a("li",[a("p",[v._v("다른 컬럼에 집계 함수 사용")]),v._v(" "),a("ul",[a("li",[v._v("다른 컬럼에 집계함수를 사용해도 명확한 결과가 출력될 때만 사용한다")])])]),v._v(" "),a("li",[a("p",[v._v("각 그룹에 대해 모든 값을 연결")]),v._v(" "),a("ul",[a("li",[v._v("MySQL, SQLite는 그룹에 속한 모든 값을 하나의 값으로 연결하는 "),a("code",[v._v("GROUP_CONCAT()")]),v._v(" 함수를 지원한다")]),v._v(" "),a("li",[v._v("함수는 기본값으로 쉼표로 구분된 문자열을 생성한다 (해당 그룹의 컬럼 값 전체를 연결해서 출력)")]),v._v(" "),a("li",[v._v("전체가 출력될 뿐 추가 정보는 없다 (어떤 값이 최신인지...) 또한 표준 SQL이 아니다")])])])]),v._v(" "),a("h2",{attrs:{id:"임의의-선택"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#임의의-선택"}},[v._v("#")]),v._v(" 임의의 선택")]),v._v(" "),a("p",[v._v("전체 데이터 집합을 애플리케이션으로 가져와 샘플을 고르는 것보다는 데이터베이스에 샘플을 요청하는 것이 낫다")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-데이터를-임의로-정렬하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-데이터를-임의로-정렬하기"}},[v._v("#")]),v._v(" 안티패턴: 데이터를 임의로 정렬하기")]),v._v(" "),a("p",[v._v("쿼리에서 임의 행을 고르는 가장 흔한 기법은 데이터를 임의로 정렬한 다음 첫 행을 고르는 것이다.\n"),a("code",[v._v("SELECT * FROM Foobar ORDER BY RAND() LIMIT 1;")])]),v._v(" "),a("p",[a("code",[v._v("RAND()")]),v._v("와 같은 비결정적 수식으로 정렬하면 인덱스를 활용할 수 없게 된다.\n이는 쿼리 성능을 고려할 때 문제가 된다.\n또한 전체 데이터 집합을 정렬하는데 비용이 많이 드는데 작업 결과의 대부분은 낭비가 된다(하나만 사용하므로).")]),v._v(" "),a("h3",{attrs:{id:"해법-테이블-전체-정렬-피하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-테이블-전체-정렬-피하기"}},[v._v("#")]),v._v(" 해법: 테이블 전체 정렬 피하기")]),v._v(" "),a("p",[v._v("임의 정렬은 테이블 스캔과 비용이 큰 수동정렬을 동반한다")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("1과 MAX 사이에서 임의의 키 값 고르기")]),v._v(" "),a("ul",[a("li",[v._v("PK 값이 1부터 시작해서 연속적으로 존재할 때")]),v._v(" "),a("li",[v._v("1과 PK의 최댓값 사이에서 임의의 키값을 고를 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("다음으로 큰 키 값 고르기")]),v._v(" "),a("ul",[a("li",[v._v("1과 PK의 최댓값 사이에서 고른 임의의 키 값보다 크거나 같은 값중 첫번째 값을 사용한다")]),v._v(" "),a("li",[v._v("키 값이 균일하게 분포하지 않을 수 있기 때문에 모든 키 값이 동일한 빈도로 선택되는 것이 중요하지 않을 때 사용한다")])])]),v._v(" "),a("li",[a("p",[v._v("모든 키 값의 목록을 구한 다음, 임의로 하나 선택")]),v._v(" "),a("ul",[a("li",[v._v("결과 집합의 PK 값 하나를 선택하는 애플리케이션 코드를 사용할 수 있다")]),v._v(" "),a("li",[v._v("데이터베이스로부터 모든 값을 불러올 때 자원을 과다하게 사용할 수 있다")]),v._v(" "),a("li",[v._v("쿼리를 두번 해야 한다 (전체 목록 요청, 임의의 값을 선택하고 그 값을 요청)")]),v._v(" "),a("li",[v._v("결과 집합의 크기가 적당하고 불연속 목록에서 값을 선택할 때 사용할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("OFFSET을 이용해 임의 선택")]),v._v(" "),a("ul",[a("li",[v._v("데이터집합에서 행의 개수를 세고 0과 행 개수 사이에서 임의의 수를 고른다음")]),v._v(" "),a("li",[v._v("데이터 집합을 쿼리 할 때 이 수를 오프셋으로 사용한다")]),v._v(" "),a("li",[v._v("이 방법은 표준이 아닌 "),a("code",[v._v("LIMIT")]),v._v(" 절에 의존한다 (MySQL, PostgreSQL, SQLite 에서 사용가능)")]),v._v(" "),a("li",[v._v("다른 방법은 Oracle, SQL Server, DB2에서 동작하는 "),a("code",[v._v("ROW_NUMBER()")]),v._v(" 함수를 사용하는 것이다")])])]),v._v(" "),a("li",[a("p",[v._v("벤더 종속적 방법")]),v._v(" "),a("ul",[a("li",[v._v("DBMS마다 이런 종류의 작업을 처리하는 방법이 있을 수 있다")]),v._v(" "),a("li",[v._v("SQL Server(TABLESAMPLE), Oracle(SAMPLE) ...")])])])]),v._v(" "),a("h2",{attrs:{id:"가난한-자의-검색-엔진"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#가난한-자의-검색-엔진"}},[v._v("#")]),v._v(" 가난한 자의 검색 엔진")]),v._v(" "),a("p",[v._v("어느 애플리케이션이든 단어나 구절로 텍스트를 검색할 필요가 생긴다.")]),v._v(" "),a("p",[v._v("관계형 데이터베이스 기본 원리 중 하나는 컬럼의 값이 원자적이어야 한다.\n즉, 한 값을 다른 값과 비교할 수 있지만 비교할 때는 항상 전체 값이어야 한다는 것이다.")]),v._v(" "),a("p",[v._v("SQL에서 부분 문자열을 비교하는 것은 비효율적이거나 부정확하다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-패턴-매칭-사용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-패턴-매칭-사용"}},[v._v("#")]),v._v(" 안티패턴: 패턴 매칭 사용")]),v._v(" "),a("p",[v._v("SQL 문자열 비교를 위해 패턴 매칭 기능을 제공하며, 이 중 널리 지원 되는 것은 "),a("code",[v._v("LIKE")]),v._v(" 연산자이다.\n표준적인 방법은 아니지만 정규 표현식 또한 많은 데이터베이스 제품에서 지원된다.")]),v._v(" "),a("p",[v._v("패턴 매칭 연산자의 가장 중요한 단점은 성능이 나쁘다는 것이다.\n일반 인덱스를 활용할 수 없기 때문에 테이블의 모든 행을 스캔해야 한다.\n두 번째 문제는 LIKE나 정규표현식을 사용한 단순한 패턴 매칭이 원치 않은 다른 결과도 찾을 수 있다는 것이다.")]),v._v(" "),a("h3",{attrs:{id:"해법-작업에-맞는-올바른-도구-사용하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-작업에-맞는-올바른-도구-사용하기"}},[v._v("#")]),v._v(" 해법: 작업에 맞는 올바른 도구 사용하기")]),v._v(" "),a("p",[v._v("SQL 대신 특화된 검색 엔진을 사용하는 것이 제일 좋다.\n다른 대안은 검색 결과를 저장해 반복되는 비용을 줄이는 것이다.")]),v._v(" "),a("ul",[a("li",[v._v("서드파티 검색 엔진\n"),a("ul",[a("li",[v._v("Sphinx Search")]),v._v(" "),a("li",[v._v("Apache Lucene")])])])]),v._v(" "),a("h2",{attrs:{id:"스파게티-쿼리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#스파게티-쿼리"}},[v._v("#")]),v._v(" 스파게티 쿼리")]),v._v(" "),a("p",[v._v('SQL 프로그래머들이 일하면서 가장 흔하게 빠지는 문제가 "이걸 어떻게 하나의 쿼리로 할 수 있을까?"라는 생각을 하는 것이다.')]),v._v(" "),a("p",[v._v("프로그래머들은 SQL 쿼리가 어렵고, 복잡하고, 비용이 많이 든다고 배웠기 때문에, SQL 쿼리가 두개면 두배로 나쁘다고 생각한다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-복잡한-문제를-한-번에-풀기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-복잡한-문제를-한-번에-풀기"}},[v._v("#")]),v._v(" 안티패턴: 복잡한 문제를 한 번에 풀기")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("의도하지 않은 제품")]),v._v(" "),a("ul",[a("li",[v._v("모든 결과를 하나의 쿼리로 만들어내려고 할 때 나타나는 흔한 결과 중 하나가 카테시안 곱(Cartesian product)이다")]),v._v(" "),a("li",[v._v("카테시안 곱은 쿼리에 사용된 두 테이블에 이들의 관계를 제한하는 조건이 없을 때 발생한다")])])]),v._v(" "),a("li",[a("p",[v._v("충분하지 않다면")]),v._v(" "),a("ul",[a("li",[v._v("한 번에 처리하려는 쿼리는 잘못된 결과를 얻을 뿐만 아니라 작성하기도 어렵고 수정/디버깅도 어렵다")]),v._v(" "),a("li",[v._v("많은 조인과 연관된 서브쿼리, 다른 연산을 사용해야 하는 복잡한 SQL 쿼리는 엔진이 최적화하여 빠르게 실행하기도 어렵다")]),v._v(" "),a("li",[v._v("SQL 쿼리가 같은 복잡도를 가진다면 적은 수의 쿼리를 실행하는 것이 맞지만, 복잡도는 실행비용을 지수적으로 증가시킬 수도 있다")])])])]),v._v(" "),a("h3",{attrs:{id:"해법-분할-정복"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-분할-정복"}},[v._v("#")]),v._v(" 해법: 분할 정복")]),v._v(" "),a("p",[v._v("Ockham's razor: 두 이론이 동일한 예측을 한다면, 단순한 쪽이 좋은 이론이다")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("한 번에 하나씩")]),v._v(" "),a("ul",[a("li",[v._v("의도하지 않은 카테시안 곱이 생기는 두 테이블 사이에 논리적 조인 조건을 찾을 수 없다면 조건이 아예 없기 때문일 수 있다")]),v._v(" "),a("li",[v._v("카테시안 곱을 피하려면 복잡한 쿼리를 단순한 여러개의 쿼리로 나누어야 한다")]),v._v(" "),a("li",[v._v("SQL 엔진은 단순한 쿼리를 쉽계 최적화하고 실행할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("UNION 연산")]),v._v(" "),a("ul",[a("li",[v._v("UNION 연산을 사용하면 여러 쿼리의 결과를 하나의 결과 집합으로 묶을 수 있다")]),v._v(" "),a("li",[v._v("하나의 쿼리를 실행하여 하나의 결과 집합을 받는것이 정말 필요하다면 UNION이 유용할 수 있다")]),v._v(" "),a("li",[v._v("서브쿼리의 컬럼이 호환될 때만 UNION 연산을 사용할 수 있다")])])])]),v._v(" "),a("h2",{attrs:{id:"암묵적-컬럼"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#암묵적-컬럼"}},[v._v("#")]),v._v(" 암묵적 컬럼")]),v._v(" "),a("p",[v._v("프로그래머들이 타이핑을 너무 많이 해야 한다고 불평하는 예 중 하나가 사용할 모든 컬럼을 SQL 쿼리에 써야 하는 경우이다\n따라서, SQL 와일드카드를 사용하게 되는데, 이렇게 사용된 컬럼 목록은 암묵적이다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-지름길만-좋아하면-길을-잃는다"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-지름길만-좋아하면-길을-잃는다"}},[v._v("#")]),v._v(" 안티패턴: 지름길만 좋아하면 길을 잃는다")]),v._v(" "),a("p",[v._v("컬럼 이름 지정 없이 와일드카드를 사용하면 타이핑을 줄일 수는 있지만, 몇 가지 위험을 초래할 수 있다")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("리팩토링 방해")]),v._v(" "),a("ul",[a("li",[v._v("암묵적 컬럼을 사용하는 INSERT 문에서는 테이블의 모든 컬럼에 대한 값을 테이블에 정의된 순서대로 지정해야 한다")]),v._v(" "),a("li",[v._v("SELECT 쿼리를 실행한 결과 값에 접근할 때 컬럼 순서를 사용한다면, 컬럼 순서가 변경되었을 경우 다른 값이 된다")]),v._v(" "),a("li",[v._v("이를 애플리케이션 출력 부분에서 문제를 인지한다면 어느 부분에서 오류가 발생했는지 추적하기 어려워 진다")])])]),v._v(" "),a("li",[a("p",[v._v("숨겨진 비용")]),v._v(" "),a("ul",[a("li",[v._v("쿼리에서 와일드 카드를 사용하는 편리함은 성능과 확장적응성에 부정적일 수 있다")]),v._v(" "),a("li",[v._v("실제로 사용하는 데이터는 일부인데 항상 전체를 전송할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("요청한 것을 얻는다")]),v._v(" "),a("ul",[a("li",[v._v("SQL에 원하지 않는 컬럼을 제외한 모든 컬럼을 지정하는 문법은 없다")]),v._v(" "),a("li",[v._v("테이블에 모든 컬럼을 요청하는 와일드카드를 사용하거나 원하는 컬럼 목록을 명시적으로 나열해야 한다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-지름길만-좋아하면-길을-잃는다"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-지름길만-좋아하면-길을-잃는다"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: 지름길만 좋아하면 길을 잃는다")]),v._v(" "),a("p",[v._v("조인 쿼리에서는 각 테이블에 개별적으로 와일드카드를 사용할 수 있다.\n와일드카드 앞에 테이블 이름이나 별칭을 붙이면 된다.")]),v._v(" "),a("p",[v._v("때로는 실행 효율 보다 개발 효율을 중요하게 여길 때가 있다.\n이 때도 짧고 읽기 쉬운 쿼리를 작성하기 위해 와일드카드를 사용할 수 있다.")]),v._v(" "),a("h3",{attrs:{id:"해법-명시적으로-컬럼-이름-지정"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-명시적으로-컬럼-이름-지정"}},[v._v("#")]),v._v(" 해법: 명시적으로 컬럼 이름 지정")]),v._v(" "),a("p",[v._v("와일드카드나 암묵적 컬럼 목록에 의지하기보다는, 항상 필요한 컬럼을 나열해야 한다")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("오류 검증")]),v._v(" "),a("ul",[a("li",[v._v("컬럼을 명시적으로 지정하면 다음 문제에 대한 저항력이 생긴다")]),v._v(" "),a("li",[v._v("테이블에 컬럼 위치가 바뀌어도 쿼리 결과는 동일하다")]),v._v(" "),a("li",[v._v("테이블에 컬럼이 추가되어도 쿼리 결과에 나타나지 않는다")]),v._v(" "),a("li",[v._v("테이블에 컬럼이 삭제되면 쿼리가 에러를 발생시킨다 (빠르게 오류를 잡을수 있게 한다 - fail fast)")])])]),v._v(" "),a("li",[a("p",[v._v("네트워크 대역폭을 효율적으로 사용한다")])]),v._v(" "),a("li",[a("p",[v._v("항상 와일드카드를 쓸 수는 없다")]),v._v(" "),a("ul",[a("li",[v._v("특정 컬럼에 수식을 적용하거나 별칭을 적용하기 위해 컬럼을 명시해야 한다")]),v._v(" "),a("li",[v._v("개별적으로 컬럼을 다룰 변경사항이 발생한다면 와일드카드에서 변경하는 것이 보다 고통스러울 것이다")])])])]),v._v(" "),a("h2",{attrs:{id:"읽을-수-있는-패스워드"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#읽을-수-있는-패스워드"}},[v._v("#")]),v._v(" 읽을 수 있는 패스워드")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-패스워드를-평문으로-저장"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-패스워드를-평문으로-저장"}},[v._v("#")]),v._v(" 안티패턴: 패스워드를 평문으로 저장")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("패스워드 저장")]),v._v(" "),a("ul",[a("li",[v._v("패스워드를 평문으로 저장하거나 평문 상태로 네트워크를 통해 전달하는 것은 안전하지 않다")]),v._v(" "),a("li",[v._v("클라이언트 애플리케이션에서 데이터베이스 서버로 전송되는 네트워크 패킷을 가로채 SQL문을 확인할 수 있다")]),v._v(" "),a("li",[v._v("데이터베이스 서버에서 SQL 쿼리 로그를 검색할 수 있다")]),v._v(" "),a("li",[v._v("서버나 백업 미디어에 저장되어 있는 데이터베이스 백업 파일로부터 데이터를 읽을 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("패스워드 인증")]),v._v(" "),a("ul",[a("li",[v._v("사용자가 로그인을 시도하면 애플리케이션은 사용자의 입력과 데이터베이스에 저장된 인증정보 문자열을 비교한다")]),v._v(" "),a("li",[v._v("이 경우 평문은 다양한 방법으로 노출될 수 있고, 인증 요청이 발생할 때마다 위험이 존재한다")]),v._v(" "),a("li",[v._v("두 개의 다른 조건을 한 덩어리로 만들어서도 안된다\n"),a("ul",[a("li",[v._v("WHERE 절에서 "),a("code",[v._v("user_name = ? AND password = ?")]),v._v(" 같은 조건은 인증 실패 원인을 알 수 없다")]),v._v(" "),a("li",[v._v("또한 상대적으로 SQL injection 등에 취약하다")])])])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-패스워드를-평문으로-저장"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-패스워드를-평문으로-저장"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: 패스워드를 평문으로 저장")]),v._v(" "),a("ul",[a("li",[v._v("애플리케이션에서 패스워드를 이용해 다른 서드파티 서비스에 접근해야 할 수 있다")]),v._v(" "),a("li",[v._v("이런 경우에는 패스워드를 읽을 수 있는 형식으로 젖아해야 한다")]),v._v(" "),a("li",[v._v("그러나 데이터베이스에 평문으로 저장하기보다는 애플리케이션에서 풀 수 있는 암호화 기법을 사용하는 것이 좋다")])]),v._v(" "),a("h3",{attrs:{id:"해법-패스워드의-소금-친-해시-값을-저장한다"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-패스워드의-소금-친-해시-값을-저장한다"}},[v._v("#")]),v._v(" 해법: 패스워드의 소금 친 해시 값을 저장한다")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("SQL에서 해시 사용")]),v._v(" "),a("ul",[a("li",[v._v("SHA256으로 문자열을 변환하면 길이는 항상 64이다")]),v._v(" "),a("li",[v._v("해시함수는 SQL 표준에 포함되어 있지 않다")])])]),v._v(" "),a("li",[a("p",[v._v("해시에 소금 추가")]),v._v(" "),a("ul",[a("li",[v._v("패스워드 대신 해시값을 저장했으로 공격자가 데이터베이스에 접근했다면 결국 비밀번호를 알아낼 수도 있다")]),v._v(" "),a("li",[v._v("이 것을 어렵게 하는 방법 중하나는 패스워드를 부호화 할 때 소금(salt)를 추가하는 것이다")]),v._v(" "),a("li",[v._v("salt는 해시 값을 구하기 전에 원본값에 덧붙이는 무의미한 바이트열이다")])])]),v._v(" "),a("li",[a("p",[v._v("SQL에서 패스워드 숨기기")]),v._v(" "),a("ul",[a("li",[v._v("SQL 쿼리에 패스워드를 평문으로 넣지 않고 애플리케이션 코드에서 해시값을 계산해 SQL 쿼리에서 해시값을 사용하여야 한다")]),v._v(" "),a("li",[v._v("이 경우 네트워크 패킷이나 로그에 평문 패스워드가 노출되는 것을 방지할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("패스워드 복구 대신 재설정")]),v._v(" "),a("ul",[a("li",[v._v("해시값을 원복할 수는 없다")]),v._v(" "),a("li",[v._v("패스워드를 잊어버렸으면 패스워드를 변경하도록 강제해야 한다")])])])]),v._v(" "),a("h2",{attrs:{id:"sql-injection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql-injection"}},[v._v("#")]),v._v(" SQL Injection")]),v._v(" "),a("p",[v._v("SQL은 애플리케이션 코드와 함께 사용될 수 있다.\n쿼리 문자열과 애플리케이션 변수를 엮어 SQL 문자열로 만드는 것을 보통 Dynamic SQL이라고 한다.")]),v._v(" "),a("p",[v._v("이 경우 어려운 부분은 개발자가 의도하지 않은 동작은 허용하지 않도록 하는 것이다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-검증되지-않은-입력을-코드로-실행"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-검증되지-않은-입력을-코드로-실행"}},[v._v("#")]),v._v(" 안티패턴: 검증되지 않은 입력을 코드로 실행")]),v._v(" "),a("p",[v._v("SQL injection의 고전적인 예는 SQL 삽입되는 문자열에 세미콜론을 넣어 문장을 끝내고 두 번째 문장을 실행하는 것이다.")]),v._v(" "),a("p",[a("code",[v._v("SELECT FROM Bugs WHERE bug_id = 1; DELETE FROM Bugs")])]),v._v(" "),a("ul",[a("li",[a("p",[v._v("사고는 발생할 것이다")]),v._v(" "),a("ul",[a("li",[v._v("데이터에 quote가 포함되어 있을 수 있다")]),v._v(" "),a("li",[v._v("DBMS에서는 이를 문법오류로 받아들이겠지만, 유사한 오류가 여러곳에서 발생할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("최고의 웹 보안 위협")]),v._v(" "),a("ul",[a("li",[v._v("요청 파라미터가 SQL문에서 어떻게 사용되는지를 추측할 수 있는 공격자는 파라미터에 의도적인 문자열을 추가할 수 있다")]),v._v(" "),a("li",[v._v("SQL injection은 파싱되기 전의 SQL문을 조작하는 방법으로 동작한다")]),v._v(" "),a("li",[v._v("SQL문이 파싱되기 전에 동적인 부분을 삽입하는 한, SQL injection 위험이 있는 것이다")])])])]),v._v(" "),a("h4",{attrs:{id:"sql-injection-위험-대비"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql-injection-위험-대비"}},[v._v("#")]),v._v(" SQL Injection 위험 대비")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("값을 이스케이프")]),v._v(" "),a("ul",[a("li",[v._v("quote와 같은 특수 문자를 escape 처리한다")]),v._v(" "),a("li",[v._v("대부분의 데이터베이스 제품도 역슬래시를 이용한 이스케이프를 지원한다")]),v._v(" "),a("li",[v._v("이 기법은 문자열이 아닌 경우에는 효과적이지 않을 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("쿼리 파라미터")]),v._v(" "),a("ul",[a("li",[v._v("SQL injection에 대한 대비책으로 가장 자주 인용되는 것은 쿼리 파라미터를 사용하는 것이다")]),v._v(" "),a("li",[v._v("SQL 문자열에 동적 값을 삽입하는 대신 쿼리를 만들 때 파라미터가 들어갈 자리를 미리 정하는 것이다")]),v._v(" "),a("li",[v._v("DBMS는 쿼리를 준비(prepare)할 때 SQL을 파싱한다, 이후에는 SQL 쿼리에 아무런 변경을 가할 수 없다")]),v._v(" "),a("li",[v._v("사실 쿼리 파라미터를 사용하는 것은 SQL injection에 대한 강력한 방어이기는 하지만 보편적 해결이 될 수는 없다")]),v._v(" "),a("li",[v._v("쿼리 파라미터의 값은 하나의 리터럴 값으로 해석되기 때문이다\n"),a("ul",[a("li",[v._v("값의 목록을 파라미터로 전달할 수 없다: "),a("code",[v._v("IN (?)")])]),v._v(" "),a("li",[v._v("테이블 이름은 파라미터로 전달할 수 없다: "),a("code",[v._v("FROM ?")])]),v._v(" "),a("li",[v._v("컬럼 이름을 파라미터로 전달할 수 없다")]),v._v(" "),a("li",[v._v("SQL 키워드를 파라미터로 전달할 수 없다")])])])])]),v._v(" "),a("li",[a("p",[v._v("Stored Procedure")]),v._v(" "),a("ul",[a("li",[v._v("저장 프로시저는 고정된 SQL문을 포함하며, 프로시저를 정의할 때 파싱된다")]),v._v(" "),a("li",[v._v("그러나 저장 프로시저 안에서도 안전하지 않은 방법으로 동적 SQL을 사용할 수 있다 ("),a("code",[v._v("QUOTE()")]),v._v(" 함수등을 통해...)")])])]),v._v(" "),a("li",[a("p",[v._v("데이터 접근 프레임 워크")]),v._v(" "),a("ul",[a("li",[v._v("데이터 접근 프레임워크에서 SQL 문을 문자열로 작성하는 것을 허용한다면 잠재적 위험이 존재한다")]),v._v(" "),a("li",[v._v("어떠한 프레임워크도 안전한 SQL 코드만 작성하도록 강제할 수 없다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-인식-방법-검증되지-않은-입력을-코드로-실행"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-인식-방법-검증되지-않은-입력을-코드로-실행"}},[v._v("#")]),v._v(" 안티패턴 인식 방법: 검증되지 않은 입력을 코드로 실행")]),v._v(" "),a("p",[v._v("실질적으로 모든 데이터베이스 애플리케이션은 SQL 문을 동적으로 생성한다.\nSQL문의 어느 부분이든 문자열을 연결하거나 값을 문자열에 삽입해 만든다면, 잠재적인 SQL injection 공격 위험에 노출되는 것이다.")]),v._v(" "),a("h3",{attrs:{id:"해법-아무도-믿지-마라"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-아무도-믿지-마라"}},[v._v("#")]),v._v(" 해법: 아무도 믿지 마라")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("입력 값 필터링")]),v._v(" "),a("ul",[a("li",[v._v("입력에 대해 유효하지 않은 문자는 모두 제거해야 한다")]),v._v(" "),a("li",[v._v("처리 방식은 프로그래밍 언어에 따라 다르다")])])]),v._v(" "),a("li",[a("p",[v._v("파라미터를 통한 값 전달")]),v._v(" "),a("ul",[a("li",[v._v("쿼리의 동적인 부분이 단순한 값이면 쿼리 파라미터를 사용해 다른 SQL 표현과 분리해야 한다")])])]),v._v(" "),a("li",[a("p",[v._v("동적 값 인용하기")]),v._v(" "),a("ul",[a("li",[v._v("보통 쿼리 파라미터를 사용하는 것은 최상의 방법이지만, 간혹 쿼리 파라미터 사용으로 optimizer가 잘못된 인덱스를 사용할 수 있다.")]),v._v(" "),a("li",[v._v("이 경우 SQL문에 직접 값을 삽입할 수 있지만, 문자열을 주의 깊게 인용해야 한다")]),v._v(" "),a("li",[v._v("앞에서 본 IN 연산자의 경우 실행시점에 파라미터의 개수를 알 수 있다")]),v._v(" "),a("li",[v._v("이 경우 IN 연산자 다음 파라미터 위치("),a("code",[v._v("?")]),v._v(")를 동적으로 생성한 PreparedStatement를 사용할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("사용자의 입력을 코드와 격리")]),v._v(" "),a("ul",[a("li",[v._v("쿼리 파라미터와 이스케이핑은 리터럴 값을 SQL문과 묶을 수 있으나 테이블 이름이나 컬럼이름, SQL 키워드 등을 사용할 수는 없다")]),v._v(" "),a("li",[v._v("이 경우 동적 생성된 쿼리에 사용자 요청을 결합하기 전 사용자 요청을 검증해야 한다")]),v._v(" "),a("li",[v._v("문자열이나 숫자에 대해 모든 값을 선택하게 하는 것은 데이터 값에 대한 것이지 식별자나 키워드에 대한 것이 아니기 때문이다")]),v._v(" "),a("li",[v._v("선택가능한 사용자 선택을 사전정의하여 생성해두고 사용자가 제한된 선택 이내의 값을 전송했는지 확인한다")]),v._v(" "),a("li",[v._v("사전 정의된 값중 사용자의 선택을 꺼내서 SQL문과 결합한다")])])])]),v._v(" "),a("h2",{attrs:{id:"가상키-편집증"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#가상키-편집증"}},[v._v("#")]),v._v(" 가상키 편집증")]),v._v(" "),a("p",[v._v("수열 중간에 숫자가 몇 개 빠지면 불편함을 느끼는 사람들이 있다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-모든-틈-메우기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-모든-틈-메우기"}},[v._v("#")]),v._v(" 안티패턴: 모든 틈 메우기")]),v._v(" "),a("p",[v._v("틈을 발견했을 때 대다수 사람들의 반응은 틈을 메우고 싶어 한다는 것이다")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("시퀀스에서 벗어난 번호 할당")]),v._v(" "),a("ul",[a("li",[v._v("새로운 행에 키 값을 할당할 때, 가상키 자동 생성 메커니즘을 사용하는 대신 PK 값 중 사용되지 않은 첫 번째 값을 사용하고 싶을 수 있다")]),v._v(" "),a("li",[v._v("그러나 사용되지 않은 가장 작은 값을 찾으려면 불필요한 셀프조인을 실행해야 한다 (조건: "),a("code",[v._v("a.id + 1 = b.id")]),v._v(")")]),v._v(" "),a("li",[v._v("또한 사용할 수 있는 최대값을 조회한 뒤 삽입에 사용하는 것은 동시성 문제가 있음을 안다")])])]),v._v(" "),a("li",[a("p",[v._v("기존 행의 번호를 다시 매기기")]),v._v(" "),a("ul",[a("li",[v._v("기존 행에 대한 키 값을 업데이트 해 틈을 메우고 모든 값을 연속이 되도록 하는 경우가 있다")]),v._v(" "),a("li",[v._v("PK 값이 가장 큰 행을 찾아 사용하지 않는 가장 작은 키 값으로 업데이트 하는 경우가 있을 것이다")]),v._v(" "),a("li",[v._v("앞의 경우와 비슷한 방법으로 사용되지 않는 키값을 찾아야 한다")]),v._v(" "),a("li",[v._v("마찬가지로 재할당 하기 위해 UPDATE 문을 사용하는데, 이는 동시성 문제가 존재한다")]),v._v(" "),a("li",[v._v("또한 번호를 새로 붙인 행을 참조하는 모든 자식 행에 변경된 키 값을 전파해야 한다\n"),a("ul",[a("li",[v._v("ON UPDATE CASCADE 옵션으로 외래키를 선언했다면 상대적으로 작업이 쉽겠지만 누락이 없으리라는 보장은 없다")]),v._v(" "),a("li",[v._v("그렇지 않다면 수작업으로 제약조건을 비활성화 한다음 업데이트하고 제약조건을 복원해야 한다")])])]),v._v(" "),a("li",[v._v("이런 과정을 거쳤더라도 결과는 일시적이다. 다시 새로운 가상키 값에 비어있는 틈이 발생한다")])])]),v._v(" "),a("li",[a("p",[v._v("데이터 불일치 만들기")]),v._v(" "),a("ul",[a("li",[v._v("PK 값을 재사용하는 것은 좋은 생각이 아니다")]),v._v(" "),a("li",[v._v("납득할만한 이유로 행을 삭제했거나, 롤백 결과로 틈이 발생한 것일 수 있기 때문이다")])])])]),v._v(" "),a("h3",{attrs:{id:"해법-극복하라"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-극복하라"}},[v._v("#")]),v._v(" 해법: 극복하라")]),v._v(" "),a("p",[v._v("PK 값은 유일하고 NULL이 아니어서 각 행을 참조하는 데 사용할 수 있어야 한다.\n행을 식별하는 데 숫자가 연속적이어야 할 필요는 없다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("행에 번호 매기기")]),v._v(" "),a("ul",[a("li",[v._v("대부분의 가상키 생성기는 행 번호처럼 보이는 번호를 반환한다")]),v._v(" "),a("li",[v._v("이들은 단조 증가이지만 이는 유일성을 보장하는 가장 편한 방법이기 때문이다")]),v._v(" "),a("li",[v._v("행 번호를 PK와 혼동하면 안된다. PK는 한 테이블에서 한 행을 식별하지만, 행 번호는 결과 집합에서 행을 식별하는 것이기 때문이다")]),v._v(" "),a("li",[v._v("행 번호를 사용하면 좋은 때는 쿼리 결과의 부분만 반환하는 경우이다. 이를 종종 pagination이라 부른다")]),v._v(" "),a("li",[v._v("이를 위해서는 단조증가하는 행번호를 사용해야 하는데, "),a("code",[v._v("ROW_NUMBER()")]),v._v("와 같은 함수들이 존재한다")]),v._v(" "),a("li",[v._v("MySQL, SQLite 등에서는 LIMIT, SKIP을 지원한다")])])]),v._v(" "),a("li",[a("p",[v._v("GUID 사용하기")]),v._v(" "),a("ul",[a("li",[v._v("어떤 수를 한 번 이상 사용하지 않으면서 랜덤한 가상키 값을 생성할 수 있다")]),v._v(" "),a("li",[v._v("이런 목적으로 Global Unique Identifier를 지원한다")]),v._v(" "),a("li",[v._v("GUID는 128비트 의사난수로 보통 32자리 16진수로 표현된다")]),v._v(" "),a("li",[v._v("GUID를 사용하면 중복을 걱정하지 않고 여러 데이터베이스 서버에서 동시에 가상키를 생성할 수 있다")]),v._v(" "),a("li",[v._v("그러나, 값이 길고 입력하고 저장하기에 나쁘며 처리속도가 느리다. 또한, 랜덤 값이므로 패턴을 추론할 수 없다.")])])]),v._v(" "),a("li",[a("p",[v._v("정수 소진 공포증")]),v._v(" "),a("ul",[a("li",[v._v("단조 증가 가상키는 언젠가 소진될 것이란 걱정이 있다")]),v._v(" "),a("li",[v._v("32비트 정수는 최대 2^32개의 구분된 값을 표현한다")]),v._v(" "),a("li",[v._v("1초에 하나씩 하루 24시간 행을 삽입한다면 32비트 정수형의 가상키를 소진하는데 136년이 걸린다")]),v._v(" "),a("li",[v._v("64비트 정수형을 사용한다면 584,542년이 걸린다")])])]),v._v(" "),a("li",[a("p",[v._v("자연키 사용")]),v._v(" "),a("ul",[a("li",[v._v("PK 값을 받아들이기에는 너무나도 민감하다면 변경이 발생하지 않는 식별 가능한 자연키를 사용할 수도 있다")])])])]),v._v(" "),a("h2",{attrs:{id:"나쁜-것-안-보기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#나쁜-것-안-보기"}},[v._v("#")]),v._v(" 나쁜 것 안 보기")]),v._v(" "),a("p",[v._v("프로그래머에게는 가능한 코드를 제거하려는 본능적 우선순위가 있다")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-짚-없이-벽돌-만들기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-짚-없이-벽돌-만들기"}},[v._v("#")]),v._v(" 안티패턴: 짚 없이 벽돌 만들기")]),v._v(" "),a("p",[v._v("개발자는 다음과 같은 두 가지 형태로 나쁜 것 안보기 안티패턴을 사용한다\n하나는 데이터베이스 API 반환값을 무시하는 것이고, 다른 하나는 애플리케이션 코드에 산재해있는 SQL 코드의 단편만을 보는 것이다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("진단 없는 진료")]),v._v(" "),a("ul",[a("li",[v._v("데이터베이스를 연결하고 처리하는 함수로부터 반환되는 값을 무시하는 경우가 있다")]),v._v(" "),a("li",[v._v("반환 값을 무시한다면 어디에서 문제가 발생했는지 알 수 없다")])])]),v._v(" "),a("li",[a("p",[v._v("행간 읽기")]),v._v(" "),a("ul",[a("li",[v._v("SQL 쿼리를 문자열로 생성하는 애플리케이션 코드만 계속 쳐다볼 수 있다")]),v._v(" "),a("li",[v._v("이런식으로 디버깅하는 것은 그림을 보지않고 그림 맞추기 퍼즐을 푸는 것과 같다")])])])]),v._v(" "),a("h3",{attrs:{id:"해법-에러에서-우아하게-복구하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-에러에서-우아하게-복구하기"}},[v._v("#")]),v._v(" 해법: 에러에서 우아하게 복구하기")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("리듬 유지하기")]),v._v(" "),a("ul",[a("li",[v._v("데이터베이스 API 호출 후 리턴 상태나 예외를 확인하는 것이 가장 좋은 방법이다")])])]),v._v(" "),a("li",[a("p",[v._v("스텝 되짚기")]),v._v(" "),a("ul",[a("li",[v._v("문제를 디버깅하는데 SQL 쿼리를 생성하는 코드를 보는 대신 실제 SQL 쿼리를 확인하는 것 또한 중요하다")])])])]),v._v(" "),a("h2",{attrs:{id:"외교적-면책특권"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#외교적-면책특권"}},[v._v("#")]),v._v(" 외교적 면책특권")]),v._v(" "),a("p",[v._v("전문적인 프로그래머들은 프로젝트에서 좋은 소프트웨어 공학적 best practice를 따르려 노력한다.")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-sql을-2등-시민으로-만들기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-sql을-2등-시민으로-만들기"}},[v._v("#")]),v._v(" 안티패턴: SQL을 2등 시민으로 만들기")]),v._v(" "),a("p",[v._v("애플리케이션 코드를 개발할 때 관례를 따르는 개발자조차도 데이터베이스 코드를 작성할 때는 이런 관례로 부터 면제된다고 생각하는 경향이 있다.")]),v._v(" "),a("h3",{attrs:{id:"해법-초당적-품질-문화-확립"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-초당적-품질-문화-확립"}},[v._v("#")]),v._v(" 해법: 초당적 품질 문화 확립")]),v._v(" "),a("p",[v._v("소프트웨어 공학의 전체 생명주기에는 다음 세 부분이 포함되는데 QA도 수반된다")]),v._v(" "),a("ol",[a("li",[v._v("프로젝트 요구사항을 문서로 명확하게 명세한다")]),v._v(" "),a("li",[v._v("요구사항에 대한 솔루션을 설계하고 개발한다")]),v._v(" "),a("li",[v._v("솔루션 요구사항이 맞는지 검토하고 테스트한다")])]),v._v(" "),a("h4",{attrs:{id:"스키마-도구"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#스키마-도구"}},[v._v("#")]),v._v(" 스키마 도구")]),v._v(" "),a("p",[v._v("RoR은 소스 관리하에 데이터베이서 업그레이드를 관리하는 마이그레이션(migration)이라는 기법을 보급했다.")]),v._v(" "),a("p",[v._v("데이터베이스를 한 단계 업그레이드 하는 스크립트를 Ruby에 기반해 작성한다.\n업그레이드 함수의 변경을 반대로 하는 다운그레이드 스크립트도 함께 작성한다.")]),v._v(" "),a("p",[v._v("마이그레이션 도구는 마이그레이션을 자동으로 실행하고 테이블을 생성해 현재 데이터베이스에 적용한 리비전을 기록한다.")]),v._v(" "),a("h2",{attrs:{id:"마법의-콩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#마법의-콩"}},[v._v("#")]),v._v(" 마법의 콩")]),v._v(" "),a("p",[v._v("MVC 모델에서 모델이 단지 접근 객체일 뿐이라 가정하는 지나친 단순화가 존재할 수 있다")]),v._v(" "),a("h3",{attrs:{id:"안티패턴-액티브-레코드인-모델"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-액티브-레코드인-모델"}},[v._v("#")]),v._v(" 안티패턴: 액티브 레코드인 모델")]),v._v(" "),a("p",[v._v("간단한 애플리케이션에서 모델에 맞춤 로직이 많이 필요하지 않다.\n모델 객체의 필드를 데이터베이스 테이블 하나의 컬럼과 매치하는 것은 상대적으로 쉽고 단순하다.")]),v._v(" "),a("p",[v._v("마틴 파울러는 이런 매핑을 지원하는 디자인 패턴을 Active Record라 불렀다.")]),v._v(" "),a("p",[v._v("액티브 레코드는 데이터 접근 패턴이다.\n데이터베이스의 테이블이나 뷰에 대응하는 클래스를 정의하고, CRUD에 대응하는 메소드를 호출한다.")]),v._v(" "),a("p",[v._v("RoR은 액티브 레코드를 보급했고, 이 패턴은 웹 개발 프레임워크에서 Data Access Object의 사실상 표준이 되었다.")]),v._v(" "),a("p",[v._v("액티브 레코드를 사용하는 것은 아무런 잘못이 없다.\n하나의 테이블에 있는 개별 행에 대한 단순한 인터페이스를 제공하는 좋은 패턴이다.")]),v._v(" "),a("p",[v._v("안티패턴은 MVC 애플리케이션에서 모든 모델 클래스가 액티브 레코드 클래스를 상속하는 관행이다.")]),v._v(" "),a("h4",{attrs:{id:"누설되기-쉬운-추상화"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#누설되기-쉬운-추상화"}},[v._v("#")]),v._v(" 누설되기 쉬운 추상화")]),v._v(" "),a("p",[v._v("조엘 스폴스키는 추상화를 사용해서 생산적이 되려고 할 때, 내부 구조를 알아야 한다면 누설되기 쉬운 추상화라 표현했다.\nMVC에서 액티브 레코드를 모델로 사용하는 것은 누설되기 쉬운 추상화의 예이다.")]),v._v(" "),a("p",[v._v("액티브 레코드에서 간단한 작업을 할 경우 마법처럼 동작하지만,\n모든 형태의 데이터베이스 접근에 사용하려 할 경우 SQL에서는 간단한 것이 복잡하게 표현된다는 것을 알게된다.")]),v._v(" "),a("h4",{attrs:{id:"액티브-레코드와-안티패턴"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#액티브-레코드와-안티패턴"}},[v._v("#")]),v._v(" 액티브 레코드와 안티패턴")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("액티브 레코드는 모델을 스키마와 결합시킨다")]),v._v(" "),a("ul",[a("li",[v._v("액티브 레코드 클래스는 데이터베이스의 테이블 하나 또는 뷰 하나를 나타낸다")]),v._v(" "),a("li",[v._v("액티브 레코드 객체의 각 필드는 대응 되는 테이블의 각 컬럼과 매치된다")]),v._v(" "),a("li",[v._v("이는 새로운 구조의 데이터를 표현하기 위해 데이터베이스를 리팩토링 할 때 모델클래스도 수정하고 애플리케이션 코드도 수정해야 함을 뜻한다")])])]),v._v(" "),a("li",[a("p",[v._v("액티브 레코드는 CRUD 함수를 노출시킨다")]),v._v(" "),a("ul",[a("li",[v._v("모델 클래스를 사용하는 사람이 의도한 사용방법을 우회해 직접 CRUD 함수로 데이터를 업데이트 할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("액티브 레코드는 빈약한 도메인 모델을 조장한다")]),v._v(" "),a("ul",[a("li",[v._v("모델이 기본적인 CRUD 메소드 외에는 아무런 동작도 가지지 않는 경우가 많다")]),v._v(" "),a("li",[v._v("모델을 단순한 데이터 접근 객체로 취급하면 비즈니스 로직은 모델 외부에 존재하게 되고 이로인해 모델 동작의 응집도가 낮아진다")]),v._v(" "),a("li",[v._v("마틴 파울러는 이러한 안티패턴을 빈약한 도메인 모델(Anemic Domain Model)이라 불렀다")])])]),v._v(" "),a("li",[a("p",[v._v("마법의 콩은 단위 테스트가 어렵다")]),v._v(" "),a("ul",[a("li",[v._v("마법의 콩 안티패턴을 사용하면 MVC 각 계층을 테스트하기 어려워진다")]),v._v(" "),a("li",[v._v("모델\n"),a("ul",[a("li",[v._v("액티브 레코드와 같은 클래스로 만들었기 때문에, 데이터 접근과 분리해 모델의 동작을 테스트할 수 없다")]),v._v(" "),a("li",[v._v("모델을 테스트하려면 실제로 데이터베이스 쿼리를 실행해야 한다")])])]),v._v(" "),a("li",[v._v("컨트롤러\n"),a("ul",[a("li",[v._v("데이터 접근 객체인 모델로 인하여 여러 컨트롤러에 동일한 코드가 반복해서 나타나는데 이를 모두 테스트해야 한다")])])])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-인식-방법-액티브-레코드인-모델"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-인식-방법-액티브-레코드인-모델"}},[v._v("#")]),v._v(" 안티패턴 인식 방법: 액티브 레코드인 모델")]),v._v(" "),a("p",[v._v("다음 단서가 안티패턴의 징후이다")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("모델에 맞춤 SQL 쿼리를 어떻게 넘길까?")]),v._v(" "),a("ul",[a("li",[v._v("이는 모델 클래스를 데이터베이스 접근 클래스로 사용하는 것이다")]),v._v(" "),a("li",[v._v("모델에 SQL 쿼리를 넘길 필요가 없어야 한다")]),v._v(" "),a("li",[v._v("모델 클래스는 필요한 쿼리가 어떤 것이든 캡슐화 해야 한다")])])]),v._v(" "),a("li",[a("p",[v._v("복잡한 모델 쿼리를 어떻게 하면 반복하지 않을까?")]),v._v(" "),a("ul",[a("li",[v._v("모델안에 쿼리를 코딩하고 모델의 인터페이스로 노출해야 한다")])])]),v._v(" "),a("li",[a("p",[v._v("모델을 단위 테스트 하기위해 데이터베이스 픽스처를 작성해야 할까?")]),v._v(" "),a("ul",[a("li",[v._v("데이터베이스 픽스처는 데이터베이스 접근을 테스트하는 것이지 비즈니스 로직을 테스트하는 것이 아니다")]),v._v(" "),a("li",[v._v("데이터베이스와 격리된 상태에서 모델을 단위테스트 할 수 있어야 한다")])])])]),v._v(" "),a("h3",{attrs:{id:"안티패턴-사용이-합당한-경우-액티브-레코드인-모델"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#안티패턴-사용이-합당한-경우-액티브-레코드인-모델"}},[v._v("#")]),v._v(" 안티패턴 사용이 합당한 경우: 액티브 레코드인 모델")]),v._v(" "),a("ul",[a("li",[v._v("테이블 개별행에 대해 간단한 연산만 하는 단순 데이터 접근객체만 필요한 경우")]),v._v(" "),a("li",[v._v("빠르게 작성하고 동작하는 프로토타입을 작성하는 경우")])]),v._v(" "),a("h3",{attrs:{id:"해법-액티브-레코드를-가지는-모델"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#해법-액티브-레코드를-가지는-모델"}},[v._v("#")]),v._v(" 해법: 액티브 레코드를 가지는 모델")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("정보 전문가")]),v._v(" "),a("ul",[a("li",[v._v("어떤 동작에 책임이 있는 객체는 동작을 수행하는데 필요한 모든 데이터를 가지고 있어야 한다")]),v._v(" "),a("li",[v._v("액티브 레코드는 한 번에 한 테이블과 동작하므로 여러 개의 데이터 접근 객체를 모아 합성 동작에 사용할 다른 클래스가 필요하다")]),v._v(" "),a("li",[v._v("모델과 액티브 레코드와 같은 DAO 사이의 관계는 IS-A가 아닌 HAS-A여야 한다")]),v._v(" "),a("li",[v._v("모델이 DAO 클래스를 상속하는 것이 아니라 DAO를 사용한다면 모델링이 해야 하는 도메인을 위한 모든 데이터와 코드를 포함하도록 설계할 수 있다")])])]),v._v(" "),a("li",[a("p",[v._v("창조자")]),v._v(" "),a("ul",[a("li",[v._v("모델이 데이터를 데이터베이스에 저장하는 방법은 내부적 구현 상세여야 한다")]),v._v(" "),a("li",[v._v("애플리케이션의 컨트롤러와 뷰는 모델이 데이터를 가져오고 저장하는 방법을 알 필요없이, 도메인 모델의 인터페이스만을 사용해야 한다")])])]),v._v(" "),a("li",[a("p",[v._v("낮은 결합도")]),v._v(" "),a("ul",[a("li",[v._v("논리적으로 독립적인 코드 블록을 분리해야 한다")]),v._v(" "),a("li",[v._v("애플리케이션에 대한 요구사항이 있으므로 복잡도가 코드 어느곳에는 존재해야 하는데, 최적의 위치를 잘 판단해야 한다")])])]),v._v(" "),a("li",[a("p",[v._v("높은 응집도")]),v._v(" "),a("ul",[a("li",[v._v("도메인 모델 클래스의 인터페이스는 의도된 사용법을 반영해야지 데이터베이스의 물리적 구조나 CRUD 동작을 반영하면 안된다")]),v._v(" "),a("li",[v._v("액티브 레코드의 인터페이스인 "),a("code",[v._v("find()")]),v._v(", "),a("code",[v._v("save()")]),v._v(" 등으로는 애플리케이션의 어떤 요구사항에 적용되는지 제대로 알기 어렵다")]),v._v(" "),a("li",[a("code",[v._v("assignUser()")]),v._v("와 같은 메소드가 명시적이고 이해하기도 쉽다")])])])]),v._v(" "),a("p",[v._v("Eric Evans는 도메인 모델이라는 더 좋은 방식을 설명한다.")]),v._v(" "),a("p",[v._v("모델은 애플리케이션을 위한 비즈니스 로직을 구현하는 곳이다.\n데이터를 데이터베이스에 저장하는 것은 모델의 내부적 구현 상세이다.")]),v._v(" "),a("p",[v._v("모델을 데이터베이스 레이아웃이 아닌 애플리케이션 개념에 따라 설계하면 데이터베이스 동작을 모델 클래스 속에 완전히 숨길 수 있다.")]),v._v(" "),a("p",[v._v("또한 모델을 DAO에서 분리하면 DAO의 stub과 mock을 생성하여 모델의 단위테스트를 도울 수 있다.")]),v._v(" "),a("h2",{attrs:{id:"정규화-규칙"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#정규화-규칙"}},[v._v("#")]),v._v(" 정규화 규칙")]),v._v(" "),a("p",[v._v("정규화(normalization) 규칙은 복잡하지 않지만 미묘하다.")]),v._v(" "),a("h3",{attrs:{id:"관계형의-뜻"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#관계형의-뜻"}},[v._v("#")]),v._v(" 관계형의 뜻")]),v._v(" "),a("p",[v._v("관계형(relational)이란 용어는 테이블 사이의 관계를 뜻하는게 아니라, 테이블 자체 또는 테이블과 컬럼 사이의 관계를 뜻한다.\n관계란 규칙과, 규칙을 따르는 쌍의 부분집합이란 두 가지 뜻으로 사용된다.")]),v._v(" "),a("p",[v._v("테이블 정규화를 시작하기 전에, 이들이 적절한 관계인지 확인해야 한다.")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("행은 위아래 순서를 가지지 않는다")]),v._v(" "),a("ul",[a("li",[v._v("SQL에서 ORDER BY 절을 사용해 순서를 지정하지 않는 한, 쿼리는 예상할 수 없는 순서의 결과를 반환한다")])])]),v._v(" "),a("li",[a("p",[v._v("컬럼은 좌우 순서를 가지지 않는다")])]),v._v(" "),a("li",[a("p",[v._v("중복 행은 허용되지 않는다")]),v._v(" "),a("ul",[a("li",[v._v("중복을 방지하기 위해 한 행을 다른 행과 구분하는 방법이 있어야 하고 개별행에 접근할 수 있어야 한다")]),v._v(" "),a("li",[v._v("SQL에서는 이를 보장하기 위해 유일하게 행을 식별하도록 PK 제약조건을 선언한다")]),v._v(" "),a("li",[v._v("모든 컬럼은 하나의 타입만 갖고, 각 행당 하나의 값만 갖는다")])])]),v._v(" "),a("li",[a("p",[v._v("행은 숨은 컴포넌트를 갖지 않는다")]),v._v(" "),a("ul",[a("li",[v._v("컬럼은 데이터 값을 포함하며, 행 ID나 객체 ID와 같은 물리적 스토리지 지시자를 갖지 않는다")])])])]),v._v(" "),a("h3",{attrs:{id:"정규화에-대한-미신"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#정규화에-대한-미신"}},[v._v("#")]),v._v(" 정규화에 대한 미신")]),v._v(" "),a("ul",[a("li",[v._v("정규화를 적용한 후에 다른 테이블 속성을 가져오기 위해 조인이 필요하다")]),v._v(" "),a("li",[v._v("반정규화는 한 형태의 쿼리에 대해서는 편해지고 성능에도 도움이되지만, 다른 쿼리에 대해서는 많은 비용을 초래한다")]),v._v(" "),a("li",[v._v("반정규화 사용이 합당한 경우도 있지만, 데이터베이스를 정규화된 형태로 만드는 것이 우선이다")]),v._v(" "),a("li",[v._v("정규화에서 데이터를 자식으로 분리하고 가상키를 반드시 사용해야 하는 것은 아니다")]),v._v(" "),a("li",[v._v("비즈니스 데이터베이스의 20% 이상이 제 3정규형 까지는 만족하지만, 제 4정규형에는 위배된다고 한다")])]),v._v(" "),a("h3",{attrs:{id:"정규화란"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#정규화란"}},[v._v("#")]),v._v(" 정규화란")]),v._v(" "),a("p",[v._v("정규화의 목표는 다음과 같다")]),v._v(" "),a("ul",[a("li",[v._v("우리가 이해할 수 있는 방법으로 실세계에 대한 사실을 표현한다")]),v._v(" "),a("li",[v._v("사실을 중복해 저장하는 것을 줄이고 데이터에 이상(anomaly)이 생기거나 모순이 생기는 것을 방지한다")]),v._v(" "),a("li",[v._v("정합성을 지원한다")])]),v._v(" "),a("p",[v._v("정규화는 데이터를 올바르게 저장하고 문제가 생기는 것을 회피하는 것이지 성능을 높이는 것은 아니다.")]),v._v(" "),a("p",[v._v("테이블이 정규화 규칙을 만족하면, 그 테이블을 정규형(normal form)이라고 한다.\n정규화의 각 단계를 나타내는 전통적인 정규형은 다섯 개가 있다.\n각 정규형은 관계를 설계함에 있어 특정 형태의 중복이나 이상을 제거한다.")]),v._v(" "),a("p",[v._v("보통 테이블이 한 정규형을 만족하면, 이전의 정규형을 모두 만족한다.")]),v._v(" "),a("ul",[a("li",[v._v("1NF")]),v._v(" "),a("li",[v._v("2NF")]),v._v(" "),a("li",[v._v("3NF")]),v._v(" "),a("li",[v._v("(BCNF)")]),v._v(" "),a("li",[v._v("4NF")]),v._v(" "),a("li",[v._v("5NF\n"),a("ul",[a("li",[v._v("DKNF")])])]),v._v(" "),a("li",[v._v("6NF")])])])}),[],!1,null,null,null);_.default=i.exports}}]);