(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{409:function(v,e,_){"use strict";_.r(e);var a=_(27),t=Object(a.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"git-for-teams"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#git-for-teams"}},[v._v("#")]),v._v(" GIT for Teams")]),v._v(" "),_("h2",{attrs:{id:"커밋-메시지"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#커밋-메시지"}},[v._v("#")]),v._v(" 커밋 메시지")]),v._v(" "),_("div",{staticClass:"language-text line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("add: 게시물 조회기능\n───  ─────────────\n│     │\n│     └─> 작업내용 요약\n│\n└───────> 커밋 메시지 타입\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br")])]),_("ul",[_("li",[_("code",[v._v("add")]),v._v(": 코드에 새로운 부분(기능적으로)이 추가됨")]),v._v(" "),_("li",[_("code",[v._v("update")]),v._v(": 새로 추가된 부분이 아니면서 issue("),_("code",[v._v("fix || resolve")]),v._v(") 없이 변경된 코드")]),v._v(" "),_("li",[_("code",[v._v("fix")]),v._v(": 오류나 이상작동을 수정함")]),v._v(" "),_("li",[_("code",[v._v("resolve")]),v._v(": issue상의 요구 사항이 반영됨")]),v._v(" "),_("li",[_("code",[v._v("refactor")]),v._v(": 코드 리팩토링")]),v._v(" "),_("li",[_("code",[v._v("format")]),v._v(": 코드 포맷 수정")]),v._v(" "),_("li",[_("code",[v._v("test")]),v._v(": 테스트 관련 코드 추가/수정")]),v._v(" "),_("li",[_("code",[v._v("docs")]),v._v(": 문서관련 작업")]),v._v(" "),_("li",[_("code",[v._v("chore")]),v._v(": production code에 영향을 미치지 않는 작업 (빌드 설정, 의존성 관리...)")]),v._v(" "),_("li",[_("code",[v._v("bump")]),v._v(": version to x.y.z")])]),v._v(" "),_("h2",{attrs:{id:"브랜치-전략"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#브랜치-전략"}},[v._v("#")]),v._v(" 브랜치 전략")]),v._v(" "),_("p",[v._v("모든 Git 저장소에는 커밋 pool이 있다. 이 커밋들은 자신의 메타데이터를 통해 서로 연결돼있다.\n모든 커밋은 자신의 부모에 대한 참조를 갖는다. 병합 커밋의 경우, 하나 이상의 부모 커밋이 참조될 수 있다.")]),v._v(" "),_("p",[v._v("Git의 브랜치는 특정 커밋에 대한 이름이 있는 포인터라고 할 수 있다.\n브랜치를 살펴본다는 것은, 포인터가 가리키는 커밋 객체에 담긴 데이터를 복사한다는 것을 의미한다.\n일단 데이터가 작업 폴더로 복사되면 원하는 대로 고칠 수 있다.")]),v._v(" "),_("p",[v._v("커밋 객체는 처음 생성했을 때 로컬에 속하고, 오직 생성한 사람의 것이다.")]),v._v(" "),_("h2",{attrs:{id:"규약"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#규약"}},[v._v("#")]),v._v(" 규약")]),v._v(" "),_("h3",{attrs:{id:"메인라인-브랜치-개발"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#메인라인-브랜치-개발"}},[v._v("#")]),v._v(" 메인라인 브랜치 개발")]),v._v(" "),_("p",[v._v("개발자들은 지속해서 하나의 중앙 브랜치에 작업을 커밋한다.\n중앙 브랜치는 항상 배포 준비 상태로 유지한다. 다른말로 하면 프로젝트의 메인 브랜치는 오직 이미 검토완료된 작업만 담아야 하고 오류가 없어야 한다.")]),v._v(" "),_("p",[v._v("보통 자동 빌드 과정을 사용하는 팀들이 하나의 작업 브랜치로 일하는 경우가 많다.")]),v._v(" "),_("p",[v._v("작업을 하다보면 로컬 작업코드와 완성품 코드를 구분할 필요가 생긴다.\n이 점 때문에 완전한 연속배포 전략을 취하지 않고, 여러개의 브랜치와 정기배포 전략을 사용한다.")]),v._v(" "),_("h3",{attrs:{id:"기능별-브랜치-배포"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#기능별-브랜치-배포"}},[v._v("#")]),v._v(" 기능별 브랜치 배포")]),v._v(" "),_("p",[v._v("기능별 브랜치 배포 전략에서 새로운 모든 작업은 기능 브랜치에서 이뤄진다.\n기능 브랜치는 하나의 온전한 아이디어를 담을 만큼으로 크기를 한정한다.")]),v._v(" "),_("p",[v._v("기능 브랜치는 통합 브랜치를 통해 다른 개발자의 작업을 가져와 최신 코드상태를 유지한다.")]),v._v(" "),_("p",[v._v("기능브랜치와 하나의 통합브랜치(릴리즈 브랜치)를 추가하면 배포 준비가 완료된 코드를 가질 수 있다.")]),v._v(" "),_("p",[v._v("마스터에 병합된 브랜치는 삭제해야 한다.")]),v._v(" "),_("h3",{attrs:{id:"상태-브랜칭"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#상태-브랜칭"}},[v._v("#")]),v._v(" 상태 브랜칭")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("브랜치 이름은 구체적으로 작업 상황을 설명하고 당면 작업과 관련이 있어야한다.")])]),v._v(" "),_("li",[_("p",[v._v("개별 브랜치의 목적을 추측할 필요가 없어 사람들이 자신의 작업을 병합할 올바른 브랜치를 찾기 쉽다.")])]),v._v(" "),_("li",[_("p",[v._v("이름이 아무리 구체적이라 해도 안내없이 어떤 브랜치를 사용할지 분명한 것은 아니다")])]),v._v(" "),_("li",[_("p",[v._v("브랜치 이름이 해당팀의 상황을 구체적으로 설명하기 때문에 여러 프로젝트간 일관성을 유지하기 어렵다.")])])]),v._v(" "),_("h3",{attrs:{id:"정기배포"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#정기배포"}},[v._v("#")]),v._v(" 정기배포")]),v._v(" "),_("p",[v._v("완전한 테스트 자동화 프로그램들이 없고 정기적으로 배포해야 하는 상황이라면, 정기 배포 전략이 가장 적절하다.")]),v._v(" "),_("p",[v._v("처음 프로젝트는 하나의 브랜치 develop을 가진다. 이 브랜치로부터 브랜치를 생성하여 기능을 추가한다.\n기능은 버그수정, 리팩토링, 완전히 새로운기능일 수도 있다.")]),v._v(" "),_("p",[v._v("티켓을 통해 작업할 기능을 설명하고 해당 브랜치의 이름은 티켓의 이름에서 따온다.\n"),_("code",[v._v("[티켓id]-[제목]")]),v._v(" 또는 "),_("code",[v._v("[tag]-[제목](#티켓id)")]),v._v(" 형식으로 사용할 수 있다.")]),v._v(" "),_("p",[v._v("기능추가가 목표지점에 이르렀다면 기능을 동결한다. develop 브랜치로부터 새로운 브랜치를 생성하고 해당 브랜치에는 오직 버그수정 커밋만 허용된다.\nrelease 브랜치에 커밋된 버그수정은 다시 develop 브랜치에 백포트 해야한다.\n품질 관리기간이 길어질수록 develop 브랜치와 release 브랜치 양쪽에서 작업하게 될 확률이 높아질 것이다.")]),v._v(" "),_("p",[v._v("테스트를 진행한 후 배포준비가 끝났다고 판단되면 새로운 브랜치 main에 커밋되고, 당시 소프트웨어 버전을 태그로 단다.\n만약 main에서 버그가 발견되어 수정이 필요하다면 hotfix 브랜치를 만들어 main과 develop에 동시 반영한다.")]),v._v(" "),_("h2",{attrs:{id:"브랜치-업데이트-하기"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#브랜치-업데이트-하기"}},[v._v("#")]),v._v(" 브랜치 업데이트 하기")]),v._v(" "),_("p",[v._v("브랜치를 업데이트할 때는 병합과 리베이스 중 하나를 선택할 수 있다.")]),v._v(" "),_("p",[v._v("원격참조를 통해 추적 브랜치를 업데이트 하는 과정은 일반적으로 pull 명령어를 사용해 실행한다.\n단, pull은 두 가지 별개의 과정, fetch와 merge 또는 fetch와 rebase의 조합이다.")]),v._v(" "),_("p",[v._v("기본적으로 pull 명령어는 병합 전략을 사용해 로컬 브랜치를 업데이트 한다.\n그러나 "),_("code",[v._v("-rebase")]),v._v("라는 매개변수를 사용하면 리베이스전략을 사용해 로컬 브랜치를 업데이트 할 수 있다.")]),v._v(" "),_("blockquote",[_("p",[v._v("리베이스를 사용하는 방법에는 두가지가 있다. 첫째, 병합 방법의 대안으로 새로운 작업을 관련 브랜치에 통합하는것. 둘째, 기존의 브랜치에 개별 커밋을 추가, 변경, 삭제하는 식으로 히스토리를 고쳐 해당 히스토리를 간결하게 만드는 것.")])]),v._v(" "),_("p",[v._v("두 개의 브랜치가 FF-Merge나 Rebase를 사용하여 병합하면 결과 그래프(history)는 사실상 같다.\n하지만 업데이트를 위해 병합하면 연결이 양방향이 되면서 히스토리 그래프는 상당히 달라질 수 있다.")]),v._v(" "),_("p",[v._v("이런 동기화 문제 때문에 일반적으로 프로젝트에 다시 합칠 작업을 할 때는 추적 브랜치에서 작업하지 않는다.\n브랜치 전략과 상관없이 추적 브랜치는 보통 장기적 브랜치(main / release)에 연결하고 작업 브랜치는 기능이나 티켓 또는 핫픽스 브랜치가 된다.")]),v._v(" "),_("p",[v._v("리베이스를 통한 브랜치 업데이트 작업을 하면 히스토리를 단순화시켜 읽기 쉽게 해준다.\n그러나 여기에는 대가가 따른다. 해당 브랜치 사본에 개발자가 생성한 커밋 객체가 포함된 경우 특히 그렇다.\n자신만의 커밋을 가진 브랜치를 리베이스 하려면 해당 커밋을 새로운 브랜치 팁에 다시 재생해야한다.\n각각의 커밋은 새로운 부모를 갖게 되면서 완전히 새로운 확인자를 할당받게 된다.\n특히 새로운 부모를 할당받는 커밋이 이전에 원격 저장소를 통해 공유된 적이 있다면 혼란을 초래한다.\n새로운 확인자 뿐만아니라 커밋을 재생할 때마다 충돌 해결에 시간이 소요된다.")])])}),[],!1,null,null,null);e.default=t.exports}}]);