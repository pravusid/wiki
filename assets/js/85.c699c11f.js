(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{457:function(t,a,s){"use strict";s.r(a);var n=s(28),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"functional-interface"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#functional-interface"}},[t._v("#")]),t._v(" Functional Interface")]),t._v(" "),s("p",[t._v("메소드를 first-class-citizen으로 활용하기 위해\n추상 메소드가 하나만 선언된 인터페이스를 함수형 인터페이스로 정의한다.")]),t._v(" "),s("p",[t._v("해당 인터페이스가 함수형 인터페이스임을 명시적으로 나타내기 위해 "),s("code",[t._v("@FucntionalInterface")]),t._v(" 애노테이션을 붙인다.")]),t._v(" "),s("p",[s("code",[t._v("java.util.function")]),t._v(" 패키지의 함수형 인터페이스는\n크게 "),s("code",[t._v("Consumer")]),t._v(", "),s("code",[t._v("Supplier")]),t._v(", "),s("code",[t._v("Function")]),t._v(", "),s("code",[t._v("Operator")]),t._v(", "),s("code",[t._v("Predicate로")]),t._v(" 구분된다.")]),t._v(" "),s("h2",{attrs:{id:"consumer-함수형-인터페이스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#consumer-함수형-인터페이스"}},[t._v("#")]),t._v(" Consumer 함수형 인터페이스")]),t._v(" "),s("p",[s("code",[t._v("Consumer")]),t._v(" 함수형 인터페이스는 매개 값을 받아 사용만 하고 리턴값이 없는 "),s("code",[t._v("accept()")]),t._v(" 메소드를 가지고 있다.")]),t._v(" "),s("p",[t._v("매개 변수의 타입과 수에 따라서 아래와 같은 Consumer 인터페이스가 있다")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Consumer<T>")]),t._v(": "),s("code",[t._v("void accept(T t)")])]),t._v(" "),s("li",[s("code",[t._v("BiConsumer<T, U>")]),t._v(": "),s("code",[t._v("void accept(T t, U u)")])]),t._v(" "),s("li",[s("code",[t._v("DoubleConsumer")]),t._v(": "),s("code",[t._v("void accept(double value)")])]),t._v(" "),s("li",[s("code",[t._v("IntConsumer")]),t._v(": "),s("code",[t._v("void accept(int value)")])]),t._v(" "),s("li",[s("code",[t._v("LongConsumer")]),t._v(": "),s("code",[t._v("void accept(long value)")])]),t._v(" "),s("li",[s("code",[t._v("ObjDoubleConsumer<T>")]),t._v(": "),s("code",[t._v("void accept(T t, double value)")])]),t._v(" "),s("li",[s("code",[t._v("ObjIntConsumer<T>")]),t._v(": "),s("code",[t._v("void accept(T t, int value)")])]),t._v(" "),s("li",[s("code",[t._v("ObjLongConsumer<T>")]),t._v(": "),s("code",[t._v("void accept(T t, long value)")])])]),t._v(" "),s("h2",{attrs:{id:"supplier-함수형-인터페이스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#supplier-함수형-인터페이스"}},[t._v("#")]),t._v(" Supplier 함수형 인터페이스")]),t._v(" "),s("p",[s("code",[t._v("Supplier")]),t._v(" 함수형 인터페이스의는 매개 값이 없고 리턴값이 있는 "),s("code",[t._v("getXXX()")]),t._v(" 메소드를 가지고 있다.")]),t._v(" "),s("p",[t._v("리턴 타입에 따라서 아래와 같은 Supplier 함수형 인터페이스들이 있다.")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Supplier<T>")]),t._v(": "),s("code",[t._v("T get()")])]),t._v(" "),s("li",[s("code",[t._v("BooleanSupplier")]),t._v(": "),s("code",[t._v("boolean getAsBoolean()")])]),t._v(" "),s("li",[s("code",[t._v("DoubleSupplier")]),t._v(": "),s("code",[t._v("double getAsDouble()")])]),t._v(" "),s("li",[s("code",[t._v("IntSupplier<T>")]),t._v(": "),s("code",[t._v("int getAsInt()")])]),t._v(" "),s("li",[s("code",[t._v("LongSupplier<T>")]),t._v(": "),s("code",[t._v("long getAsLong()")])])]),t._v(" "),s("h2",{attrs:{id:"function-함수형-인터페이스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-함수형-인터페이스"}},[t._v("#")]),t._v(" Function 함수형 인터페이스")]),t._v(" "),s("p",[s("code",[t._v("Function")]),t._v(" 함수형 인터페이스는 매개 값과 리턴값이 있는 "),s("code",[t._v("applyXXX()")]),t._v(" 메소드를 가지고 있다.")]),t._v(" "),s("p",[t._v("매개 변수 타입과 리턴 타입에 따라서 아래와 같은 Function 함수형 인터페이스가 있다.")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Function<T, R>")]),t._v(": "),s("code",[t._v("R apply(T t)")])]),t._v(" "),s("li",[s("code",[t._v("BiFunction<T, U, R>")]),t._v(": "),s("code",[t._v("R apply(T t, U u)")])]),t._v(" "),s("li",[s("code",[t._v("DoubleFunction<R>")]),t._v(": "),s("code",[t._v("R apply(double value)")])]),t._v(" "),s("li",[s("code",[t._v("IntFunction<R>")]),t._v(": "),s("code",[t._v("R apply(int value)")])]),t._v(" "),s("li",[s("code",[t._v("IntToDoubleFunction")]),t._v(": "),s("code",[t._v("double applyAsDouble(int value)")])]),t._v(" "),s("li",[s("code",[t._v("IntToLongFunction")]),t._v(": "),s("code",[t._v("long applyAsLong(int value)")])]),t._v(" "),s("li",[s("code",[t._v("LongToDoubleFunction")]),t._v(": "),s("code",[t._v("double applyAsDouble(long value)")])]),t._v(" "),s("li",[s("code",[t._v("LongToIntFunction")]),t._v(": "),s("code",[t._v("int applyAsDouble(long value)")])]),t._v(" "),s("li",[s("code",[t._v("ToDoubleFunction<T>")]),t._v(": "),s("code",[t._v("double applyAsDouble(T t)")])]),t._v(" "),s("li",[s("code",[t._v("ToDoubleBiFunction<T, U>")]),t._v(": "),s("code",[t._v("double applyAsDouble(T t, U u)")])]),t._v(" "),s("li",[s("code",[t._v("ToIntFunction<T>")]),t._v(": "),s("code",[t._v("int applyAsInt(T t)")])]),t._v(" "),s("li",[s("code",[t._v("ToIntBiFunction<T, U>")]),t._v(": "),s("code",[t._v("int applyAsInt(T t, U u)")])]),t._v(" "),s("li",[s("code",[t._v("ToLongFunction<T>")]),t._v(": "),s("code",[t._v("long applyAsLong(T t)")])]),t._v(" "),s("li",[s("code",[t._v("ToLongBiFunction<T, U>")]),t._v(": "),s("code",[t._v("long applyAsLong(T t, U u)")])])]),t._v(" "),s("h2",{attrs:{id:"operator-함수형-인터페이스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#operator-함수형-인터페이스"}},[t._v("#")]),t._v(" Operator 함수형 인터페이스")]),t._v(" "),s("p",[s("code",[t._v("Operator")]),t._v(" 함수형 인터페이스는 매개 값와 리턴값이 있는 "),s("code",[t._v("applyXXX()")]),t._v(" 메소드를 가지고 있다.\n"),s("code",[t._v("Function")]),t._v(" 함수형 인터페이스와 동일하게 매개 변수를 받아 실행한 후 반환하지만, 타입이 유지된다는 점에서 차이가 있다.")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("UnaryOperator<T>")]),t._v(": "),s("code",[t._v("Function<T, R>")]),t._v(" 확장")]),t._v(" "),s("li",[s("code",[t._v("BinaryOperator<T>")]),t._v(": "),s("code",[t._v("BiFunction<T, U, R>")]),t._v(" 확장")]),t._v(" "),s("li",[s("code",[t._v("DoubleUnaryOperator")]),t._v(": "),s("code",[t._v("double applyAsDouble(double value)")])]),t._v(" "),s("li",[s("code",[t._v("DoubleBinaryOperator")]),t._v(": "),s("code",[t._v("double applyAsDouble(double val1, double val2)")])]),t._v(" "),s("li",[s("code",[t._v("IntUnaryOperator")]),t._v(": "),s("code",[t._v("int applyAsInt(int value)")])]),t._v(" "),s("li",[s("code",[t._v("IntBinaryOperator")]),t._v(": "),s("code",[t._v("int applyAsInt(int val1, int val2)")])]),t._v(" "),s("li",[s("code",[t._v("LongUnaryOperator")]),t._v(": "),s("code",[t._v("long applyAsLong(long value)")])]),t._v(" "),s("li",[s("code",[t._v("LongBinaryOperator")]),t._v(": "),s("code",[t._v("long applyAsLong(long val1, long val2)")])])]),t._v(" "),s("h2",{attrs:{id:"predicate-함수형-인터페이스"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#predicate-함수형-인터페이스"}},[t._v("#")]),t._v(" Predicate 함수형 인터페이스")]),t._v(" "),s("p",[s("code",[t._v("Predicate")]),t._v(" 함수형 인터페이스는 매개 변수와 boolean 리턴값이 있는 "),s("code",[t._v("testXXX()")]),t._v(" 메소드를 가지고 있다.\n이 메소드들은 조건에 맞춰 비교한 결과를 반환한다.")]),t._v(" "),s("p",[t._v("매개 변수 타입과 수에 따라서 아래와 같은 Predicate 함수형 인터페이스들이 있다.")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Predicate<T>")]),t._v(": "),s("code",[t._v("boolean test(T t)")])]),t._v(" "),s("li",[s("code",[t._v("BiPredicate<T, U>")]),t._v(": "),s("code",[t._v("boolean test(T t, U u)")])]),t._v(" "),s("li",[s("code",[t._v("DoublePredicate")]),t._v(": "),s("code",[t._v("boolean test(double value)")])]),t._v(" "),s("li",[s("code",[t._v("IntPredicate<T>")]),t._v(": "),s("code",[t._v("boolean test(int value)")])]),t._v(" "),s("li",[s("code",[t._v("LongPredicate<T>")]),t._v(": "),s("code",[t._v("boolean test(long value)")])])]),t._v(" "),s("h2",{attrs:{id:"andthen-compose"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#andthen-compose"}},[t._v("#")]),t._v(" andThen() / compose()")]),t._v(" "),s("p",[t._v("함수형 인터페이스의 조건은 하나의 추상메소드만 존재하는 것이다.\n따라서 인터페이스에 default 메소드 및 static 메소드가 정의되어 있더라도 함수형 인터페이스의 성질을 유지할 수 있다.")]),t._v(" "),s("p",[s("code",[t._v("java.util.function")]),t._v(" 패키지의 함수형 인터페이스들도 하나 이상의 default 및 static 메소드를 가지고 있다.")]),t._v(" "),s("p",[s("code",[t._v("Comsumer")]),t._v(", "),s("code",[t._v("Function")]),t._v(", "),s("code",[t._v("Operator")]),t._v(" 함수형 인터페이스는 "),s("code",[t._v("andThen()")]),t._v("과 "),s("code",[t._v("compose()")]),t._v(" default 메소드를 가지고 있다.")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("andThen()")]),t._v(": "),s("code",[t._v("consumer")]),t._v(", "),s("code",[t._v("function")]),t._v(", "),s("code",[t._v("operator")]),t._v(" 모두지원")]),t._v(" "),s("li",[s("code",[t._v("compose()")]),t._v(": "),s("code",[t._v("Function<T, R>")]),t._v("을 상속하는 인터페이스에서 지원")])]),t._v(" "),s("p",[s("code",[t._v("andThen()")]),t._v("과 "),s("code",[t._v("compose()")]),t._v(" 메소드는 두 개의 함수형 인터페이스를 연결하는데 사용한다.\n"),s("code",[t._v("andThen()")]),t._v("과 "),s("code",[t._v("compose()")]),t._v("의 차이점은 어떤 함수형 인터페이스부터 먼저 처리하느냐에 따라 다르다.")]),t._v(" "),s("p",[s("code",[t._v("andThen()")]),t._v("은 앞의 인터페이스에서 값을 처리하고 이어진 "),s("code",[t._v("andThen(interface)")]),t._v("의 매개함수로 값을 넘겨 처리한다.")]),t._v(" "),s("p",[s("code",[t._v("compose()")]),t._v("의 경우 함수의 합성과 동일하며 "),s("code",[t._v("f(g(x))")]),t._v("와 같은 형태이다.\n"),s("code",[t._v("compose(interface)")]),t._v("의 매개함수에서 처리한 값을 "),s("code",[t._v("compose()")]),t._v("를 호출한 인터페이스로 넘겨 최종 값을 계산한다.")]),t._v(" "),s("h2",{attrs:{id:"consumer의-순차적-연결"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#consumer의-순차적-연결"}},[t._v("#")]),t._v(" Consumer의 순차적 연결")]),t._v(" "),s("p",[s("code",[t._v("Consumer")]),t._v(" 함수형 인터페이스는 처리 결과를 반환하지 않으므로 "),s("code",[t._v("andThen()")]),t._v(" 메소드는 함수형 인터페이스의 호출 순서만 정하게 된다.")]),t._v(" "),s("h2",{attrs:{id:"function과-operator의-순차적-연결"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function과-operator의-순차적-연결"}},[t._v("#")]),t._v(" Function과 Operator의 순차적 연결")]),t._v(" "),s("p",[t._v("Function과 Operator 종류의 함수형 인터페이스는 먼저 실행한 함수형 인터페이스의 결과 값을\n다음 함수형 인터페이스의 매개값으로 넘겨주고, 최종 처리 결과를 리턴한다.")]),t._v(" "),s("h2",{attrs:{id:"and-or-negate-디폴트-메소드와-isequal-정적-메소드"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#and-or-negate-디폴트-메소드와-isequal-정적-메소드"}},[t._v("#")]),t._v(" and(), or(), negate() 디폴트 메소드와 isEqual() 정적 메소드")]),t._v(" "),s("p",[s("code",[t._v("Predicate")]),t._v(" 함수형 인터페이스는 "),s("code",[t._v("and()")]),t._v(", "),s("code",[t._v("or()")]),t._v(", "),s("code",[t._v("negate()")]),t._v(", "),s("code",[t._v("isEqual()")]),t._v(" 메소드를 가지고 있다.")]),t._v(" "),s("p",[t._v("이 메소드들은 각각 논리 연산자인 "),s("code",[t._v("&&")]),t._v(", "),s("code",[t._v("||")]),t._v(", "),s("code",[t._v("!")]),t._v(", "),s("code",[t._v("==")]),t._v("과 대응된다.")]),t._v(" "),s("p",[s("code",[t._v("isEqual()")]),t._v(" 메소드는 "),s("code",[t._v("test()")]),t._v(" 매개 값인 "),s("code",[t._v("sourceObject")]),t._v("와\n"),s("code",[t._v("isEqual()")]),t._v("의 매개 값인 "),s("code",[t._v("targetObject")]),t._v("를 "),s("code",[t._v("java.util.Objects")]),t._v(" 클래스의 "),s("code",[t._v("eqauls()")]),t._v("의 매개값으로 제공하고,\nObjects.equals(source, targetObject)의 리턴값을 얻는 새로운 "),s("code",[t._v("Predicate<Object>")]),t._v("를 생성한다.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Predicate")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" predicate "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Predicate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEqual")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("targetObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" predicate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sourceObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("h2",{attrs:{id:"minby-maxby-정적-메소드"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#minby-maxby-정적-메소드"}},[t._v("#")]),t._v(" minBy(), maxBy() 정적 메소드")]),t._v(" "),s("p",[s("code",[t._v("BinaryOperator<T>")]),t._v(" 함수형 인터페이스는 "),s("code",[t._v("minBy()")]),t._v("와 "),s("code",[t._v("maxBy()")]),t._v(" 메소드를 제공한다.")]),t._v(" "),s("p",[t._v("이 두 메소드는 매개 값으로 제공되는 "),s("code",[t._v("Comparator")]),t._v("를 이용하여 최대와 최소를 얻는 "),s("code",[t._v("BinaryOperator<T>")]),t._v("를 리턴한다.")]),t._v(" "),s("p",[t._v("o1과 o2를 비교해서 o1이 작으면 음수를, o1과 o2가 동일하면 0을, o1이 크면 양수를 리턴하는 "),s("code",[t._v("compare()")]),t._v(" 메소드가 있을 때")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@FunctionalInterface")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Comparator")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" o1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" o2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[s("code",[t._v("Comparator<T>")]),t._v("를 타겟 타입으로 하고 int타입의 크기를 비교하는 람다식을 다음과 같이 작성할 수 있다.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" o2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" o2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("OperatorMinByMaxByExam")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BinaryOperator")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fruit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" binaryOperator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fruit")]),t._v(" fruit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        binaryOperator "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BinaryOperator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("minBy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" f2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("price"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" f2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("price"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        fruit "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" binaryOperator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fruit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Strawberry"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fruit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Graph"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fruit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        binaryOperator "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BinaryOperator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("maxBy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" f2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("price"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" f2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("price"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        fruit "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" binaryOperator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fruit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Strawberry"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fruit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Graph"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fruit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br")])]),s("h2",{attrs:{id:"method-reference"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#method-reference"}},[t._v("#")]),t._v(" Method Reference")]),t._v(" "),s("p",[t._v("일반적으로 함수형 메소드 (accept, get, apply...)가 실행할 본문을 람다식으로 구현하여 넘긴다.\n단순히 메소드를 호출하는 작업이라면, 직접 메소드를 참조하도록 하는 방법이다.")]),t._v(" "),s("h3",{attrs:{id:"활용-case"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#활용-case"}},[t._v("#")]),t._v(" 활용 case")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("(arg) -> Class.staticMethod(arg)")]),t._v(" / "),s("code",[t._v("Class::staticMethod")]),t._v(" / 정적 메소드 참조")]),t._v(" "),s("li",[s("code",[t._v("(arg, rest) -> arg.instanceMethod(rest)")]),t._v(" / "),s("code",[t._v("Class::instanceMethod")]),t._v(" / 매개변수 참조")]),t._v(" "),s("li",[s("code",[t._v("(arg) -> instance.instanceMethod(arg)")]),t._v(" / "),s("code",[t._v("instance::instanceMethod")]),t._v(" / 외부 인스턴스 참조 - Lambda Capturing")]),t._v(" "),s("li",[s("code",[t._v("(arg) -> new Class(arg)")]),t._v(" / "),s("code",[t._v("Class::new")]),t._v(" / 생성자 참조")])])])}),[],!1,null,null,null);a.default=e.exports}}]);